<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <title>Edge Scanner</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <header class="app-header">
    <div>
      <h1>Edge Scanner</h1>
      <p data-i18n="tagline">Arbitrage â€¢ Middles â€¢ +EV</p>
    </div>
    <div class="header-controls">
      <div class="odds-format" id="odds-toggle" role="button" tabindex="0">
        <span data-format="decimal" class="active" data-i18n="odds_decimal">Decimal</span>
        <span data-format="american" data-i18n="odds_american">American</span>
      </div>
      <div class="odds-format" id="language-toggle" role="button" tabindex="0" aria-label="Toggle language">
        <span data-lang="en" class="active">EN</span>
        <span data-lang="zh">ä¸­æ–‡</span>
      </div>
      <button class="icon-btn" id="theme-toggle" title="Toggle theme">ğŸŒ™</button>
    </div>
  </header>

  <main>
    <section class="card config-card">
      <form id="scan-form">
        <div class="config-grid">
          {% if has_env_key %}
          <div class="field">
            <label class="field-label" data-i18n="api_key_label">API Key</label>
            <div class="env-key-notice" data-i18n="env_key_notice">âœ“ Using API key from .env</div>
          </div>
          {% else %}
          <div class="field">
            <label class="field-label" data-i18n="api_key_label">API Key</label>
            <div class="input-wrap">
              <input type="password" id="api-key" placeholder="sk_xxx" required />
              <button type="button" id="toggle-key" class="icon-btn" aria-label="Show API key">ğŸ‘</button>
            </div>
          </div>
          {% endif %}
          <div class="field">
            <label class="field-label" data-i18n="total_stake_label">Total Stake ($)</label>
            <input type="number" id="stake-input" min="1" step="1" value="100" />
            <p class="helper" data-i18n="stake_helper">Used for arbitrage + middles stake splits.</p>
          </div>
          <div class="field">
            <label class="field-label" data-i18n="sports_label">Sports</label>
            <div id="sports-list" class="sports-grid">
              {% for sport in default_sports %}
              <label class="checkbox">
                <input type="checkbox" name="sports" value="{{ sport.key }}" checked />
                <span data-sport-key="{{ sport.key }}">{{ sport.label }}</span>
              </label>
              {% endfor %}
            </div>
            <label class="checkbox all-toggle">
              <input type="checkbox" id="all-sports" />
              <span data-i18n="all_sports_label">Scan all active sports (uses more API credits)</span>
            </label>
            <p class="helper" data-i18n="sports_helper">Each selected sport consumes one API request.</p>
          </div>
          <div class="field">
            <label class="field-label" data-i18n="regions_label">Regions</label>
            <div id="regions-list" class="regions-grid">
              {% for region in region_options %}
              <label class="checkbox">
                <input type="checkbox" name="regions" value="{{ region.key }}" {% if region.default %}checked{% endif %} />
                <span data-region-key="{{ region.key }}">{{ region.label }}</span>
              </label>
              {% endfor %}
            </div>
            <p class="helper" data-i18n="regions_helper">Select at least one region. EU is always included for sharp reference.</p>
          </div>
          <div class="field commission-field">
            <div class="commission-box">
              <div>
                <label class="field-label" data-i18n="commission_label">Exchange Commission (%)</label>
                <p class="helper" data-i18n="commission_helper">Applied to Betfair, Matchbook, Sportsbet Exchange, etc.</p>
              </div>
              <div class="input-wrap">
                <input type="number" id="commission-input" min="0" max="15" step="0.5" value="{{ default_commission_percent }}" />
              </div>
              <p class="helper" data-i18n="commission_note">Net ROI/EV already reflects this commission.</p>
            </div>
          </div>
        </div>
        <div class="actions">
          <button type="submit" id="scan-btn" data-i18n="scan_now">Scan Now</button>
          <div id="status" class="status"></div>
        </div>
      </form>
    </section>

    <nav class="tabs">
      <button type="button" class="tab-btn active" data-tab="arbitrage" data-i18n="tab_arbitrage">Arbitrage</button>
      <button type="button" class="tab-btn" data-tab="middles" data-i18n="tab_middles">Middles</button>
      <button type="button" class="tab-btn" data-tab="plus-ev" data-i18n="tab_plus_ev">+EV</button>
    </nav>

    <section class="card middle-config hidden" id="middles-config">
      <div class="middle-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="middle_min_gap">Minimum Gap (points)</label>
          <input type="number" id="min-gap-input" min="0" max="10" step="0.5" value="1.5" />
          <p class="helper" data-i18n="middle_min_gap_helper">Only show middles with at least this many points between the lines.</p>
        </div>
        <div class="field toggle-field">
          <label class="field-label" data-i18n="filters_label">Filters</label>
          <label class="checkbox">
            <input type="checkbox" id="positive-ev-toggle" checked />
            <span data-i18n="positive_ev_only">Show only positive EV middles</span>
          </label>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="middle-sort">
            <option value="ev" data-i18n="sort_ev">Estimated EV</option>
            <option value="probability" data-i18n="sort_probability">Probability</option>
            <option value="gap" data-i18n="sort_gap">Gap size</option>
            <option value="time" data-i18n="sort_time">Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section class="card plus-config hidden" id="plus-ev-config">
      <div class="plus-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="sharp_reference_book">Sharp Reference Book</label>
          <select id="sharp-book-select">
            {% for book in sharp_books %}
            <option value="{{ book.key }}" {% if book.key == default_sharp_book %}selected{% endif %}>{{ book.name }}</option>
            {% endfor %}
          </select>
          <p class="helper" data-i18n="sharp_book_helper">Used as the "true" odds source. Pinnacle recommended.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="min_edge_label">Minimum Edge (%)</label>
          <input type="number" id="min-edge-input" min="0" max="20" step="0.5" value="{{ default_min_edge_percent }}" />
          <p class="helper" data-i18n="min_edge_helper">Filter +EV bets below this edge.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="kelly_staking">Kelly Staking</label>
          <div class="kelly-grid">
            <input type="number" id="bankroll-input" min="0" step="50" value="{{ default_bankroll }}" />
            <select id="kelly-select">
              {% for opt in kelly_options %}
              <option value="{{ opt.value }}" data-kelly-value="{{ opt.value }}" {% if opt.value == default_kelly_fraction %}selected{% endif %}>{{ opt.label }}</option>
              {% endfor %}
            </select>
          </div>
          <p class="helper" data-i18n="kelly_helper">Bankroll + Kelly fraction are not persisted between scans.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="plus-ev-sort">
            <option value="edge" data-i18n="sort_edge">Edge %</option>
            <option value="ev" data-i18n="sort_ev_value">EV ($)</option>
            <option value="kelly" data-i18n="sort_kelly">Kelly stake</option>
            <option value="time" data-i18n="sort_time">Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section id="arbitrage-panel">
      <section class="stats-row">
        <div class="stat-card" id="stat-opps">
          <span class="stat-label" data-i18n="stat_opportunities">Opportunities</span>
          <span class="stat-value">0</span>
        </div>
        <div class="stat-card" id="stat-events">
          <span class="stat-label" data-i18n="stat_events_scanned">Events Scanned</span>
          <span class="stat-value">0</span>
        </div>
        <div class="stat-card" id="stat-sports">
          <span class="stat-label" data-i18n="stat_sports">Sports</span>
          <span class="stat-value">0</span>
        </div>
        <div class="stat-card" id="stat-calls">
          <span class="stat-label" data-i18n="stat_api_calls">API Calls</span>
          <span class="stat-value">0</span>
        </div>
      </section>

      <section id="summary-info" class="card summary-info hidden"></section>
      <div id="partial-warning" class="alert warning hidden"></div>

      <section class="summary-grid">
        <div class="card summary-card" id="roi-card">
          <div class="card-head">
            <h3 data-i18n="by_roi_band">By ROI Band</h3>
          </div>
          <div id="roi-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card" id="sport-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="sport-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="opportunities_title">Opportunities</h3>
          <div class="table-meta">
            <span id="table-count">0 results</span>
            <span class="muted" data-i18n="sorted_by_roi">Sorted by ROI</span>
          </div>
        </div>
        <table id="results-table">
          <thead>
            <tr>
              <th data-i18n="table_net_roi">Net ROI</th>
              <th data-i18n="table_gross_roi">Gross ROI</th>
              <th data-i18n="table_profit">Profit</th>
              <th data-i18n="table_exchange">Exchange</th>
              <th data-i18n="table_sport">Sport</th>
              <th data-i18n="table_event">Event</th>
              <th data-i18n="table_time">Time</th>
              <th data-i18n="table_market">Market</th>
              <th data-i18n="table_outcome_1">Outcome 1</th>
              <th data-i18n="table_outcome_2">Outcome 2</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div id="table-empty" class="empty" data-i18n="empty_arbitrage">No arbitrage opportunities yet.</div>
      </section>
    </section>

    <section id="middles-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_middles_found">Middles Found</span>
          <span class="stat-value" id="middle-stat-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_positive_middles">+EV Middles</span>
          <span class="stat-value" id="middle-stat-positive">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_avg_ev">Avg EV</span>
          <span class="stat-value" id="middle-stat-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_best_ev">Best EV</span>
          <span class="stat-value" id="middle-stat-best">0%</span>
        </div>
      </section>

      <section id="middles-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="middles-sport-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card" id="middles-key-card">
          <div class="card-head">
            <h3 data-i18n="key_numbers_label">Key Numbers</h3>
          </div>
          <div id="middles-key-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="middles_title">Middles</h3>
          <div class="table-meta">
            <span id="middles-table-count">0 results</span>
            <span class="muted" data-i18n="sorted_by_ev">Sorted by EV</span>
          </div>
        </div>
        <table id="middles-table">
          <thead>
            <tr>
              <th data-i18n="table_ev">EV</th>
              <th data-i18n="table_prob">Prob</th>
              <th data-i18n="table_gap">Gap</th>
              <th data-i18n="table_sport">Sport</th>
              <th data-i18n="table_event">Event</th>
              <th data-i18n="table_time">Time</th>
              <th data-i18n="table_market">Market</th>
              <th data-i18n="table_side_a">Side A</th>
              <th data-i18n="table_side_b">Side B</th>
              <th data-i18n="table_middle">Middle</th>
              <th data-i18n="table_win_both">Win Both</th>
              <th data-i18n="table_miss">Miss</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div id="middles-empty" class="empty" data-i18n="empty_middles">No middle opportunities meet your filters.</div>
      </section>

      <section class="card middle-caveat">
        <p data-i18n-html="caveat_middles"><strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 &amp; 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.</p>
      </section>
    </section>

    <section id="plus-ev-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_plus_ev_bets">+EV Bets</span>
          <span class="stat-value" id="plus-ev-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_avg_edge">Avg Edge</span>
          <span class="stat-value" id="plus-ev-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_best_edge">Best Edge</span>
          <span class="stat-value" id="plus-ev-best">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_total_ev">Total EV ($100)</span>
          <span class="stat-value" id="plus-ev-total">$0</span>
        </div>
      </section>

      <section id="plus-ev-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="plus-ev-sport-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_edge_band">By Edge Band</h3>
          </div>
          <div id="plus-ev-edge-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="plus_ev_title">+EV Opportunities</h3>
          <div class="table-meta">
            <span id="plus-ev-table-count">0 results</span>
            <span class="muted" data-i18n="sorted_by_edge">Sorted by Edge</span>
          </div>
        </div>
        <table id="plus-ev-table">
          <thead>
            <tr>
              <th data-i18n="table_edge">Edge</th>
              <th data-i18n="table_ev_100">EV ($100)</th>
              <th data-i18n="table_kelly">Kelly</th>
              <th data-i18n="table_sport">Sport</th>
              <th data-i18n="table_event">Event</th>
              <th data-i18n="table_time">Time</th>
              <th data-i18n="table_market">Market</th>
              <th data-i18n="table_bet">Bet</th>
              <th data-i18n="table_soft_odds">Soft Odds</th>
              <th data-i18n="table_fair_odds">Fair Odds</th>
              <th data-i18n="table_true_prob">True Prob</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div id="plus-ev-empty" class="empty" data-i18n="empty_plus_ev">No +EV bets at the current thresholds.</div>
      </section>

      <section class="card middle-caveat">
        <p data-i18n-html="caveat_plus_ev"><strong>Understanding +EV Betting:</strong> Sharp books (Pinnacle, Betfair, Matchbook) provide near "true" odds. When a soft book posts a higher price than fair value, the bet has positive expected value. +EV bets still lose roughly half the timeâ€”the edge shows up over many wagers. Kelly staking helps size bets, but variance can still be high. Always confirm odds before betting; edges disappear quickly.</p>
      </section>
    </section>
  </main>

  <script>
    window.edgeScannerConfig = {
      hasEnvKey: {{ 'true' if has_env_key else 'false' }},
      sharpBooks: {{ sharp_books | tojson }},
      defaultSharpBook: "{{ default_sharp_book }}",
      defaultMinEdgePercent: {{ default_min_edge_percent }},
      defaultBankroll: {{ default_bankroll }},
      defaultKellyFraction: {{ default_kelly_fraction }},
      kellyOptions: {{ kelly_options | tojson }}
    };
  </script>

  <script>
    const appConfig = window.edgeScannerConfig || {};
    const hasEnvKey = appConfig.hasEnvKey === true || appConfig.hasEnvKey === 'true';
    const form = document.getElementById('scan-form');
    const apiKeyInput = document.getElementById('api-key');
    const stakeInput = document.getElementById('stake-input');
    const scanBtn = document.getElementById('scan-btn');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary-info');
    const resultsBody = document.querySelector('#results-table tbody');
    const emptyState = document.getElementById('table-empty');
    const allSportsToggle = document.getElementById('all-sports');
    const summaryROI = document.getElementById('roi-bars');
    const summarySport = document.getElementById('sport-bars');
    const tableCount = document.getElementById('table-count');
    const statOpps = document.querySelector('#stat-opps .stat-value');
    const statEvents = document.querySelector('#stat-events .stat-value');
    const statSports = document.querySelector('#stat-sports .stat-value');
    const statCalls = document.querySelector('#stat-calls .stat-value');
    const themeToggle = document.getElementById('theme-toggle');
    const toggleKeyBtn = document.getElementById('toggle-key');
    let currencyFormatter;
    const partialWarning = document.getElementById('partial-warning');
    const commissionInput = document.getElementById('commission-input');
    const tabs = document.querySelectorAll('.tab-btn');
    const arbitragePanel = document.getElementById('arbitrage-panel');
    const middlesPanel = document.getElementById('middles-panel');
    const plusEvPanel = document.getElementById('plus-ev-panel');
    const middlesConfig = document.getElementById('middles-config');
    const plusEvConfig = document.getElementById('plus-ev-config');
    const minGapInput = document.getElementById('min-gap-input');
    const positiveEvToggle = document.getElementById('positive-ev-toggle');
    const middleSortSelect = document.getElementById('middle-sort');
    const middleStatCount = document.getElementById('middle-stat-count');
    const middleStatPositive = document.getElementById('middle-stat-positive');
    const middleStatAvg = document.getElementById('middle-stat-avg');
    const middleStatBest = document.getElementById('middle-stat-best');
    const middleSummaryInfo = document.getElementById('middles-summary-info');
    const middleSportBars = document.getElementById('middles-sport-bars');
    const middleKeyBars = document.getElementById('middles-key-bars');
    const middleKeyCard = document.getElementById('middles-key-card');
    const middlesTableBody = document.querySelector('#middles-table tbody');
    const middlesTableCount = document.getElementById('middles-table-count');
    const middlesEmpty = document.getElementById('middles-empty');
    const sharpSelect = document.getElementById('sharp-book-select');
    const minEdgeInput = document.getElementById('min-edge-input');
    const bankrollInput = document.getElementById('bankroll-input');
    const kellySelect = document.getElementById('kelly-select');
    const plusEvSortSelect = document.getElementById('plus-ev-sort');
    const plusEvCount = document.getElementById('plus-ev-count');
    const plusEvAvg = document.getElementById('plus-ev-avg');
    const plusEvBest = document.getElementById('plus-ev-best');
    const plusEvTotal = document.getElementById('plus-ev-total');
    const plusEvSummaryInfo = document.getElementById('plus-ev-summary-info');
    const plusEvSportBars = document.getElementById('plus-ev-sport-bars');
    const plusEvEdgeBars = document.getElementById('plus-ev-edge-bars');
    const plusEvTableBody = document.querySelector('#plus-ev-table tbody');
    const plusEvTableCount = document.getElementById('plus-ev-table-count');
    const plusEvEmpty = document.getElementById('plus-ev-empty');
    const oddsToggle = document.getElementById('odds-toggle');
    const languageToggle = document.getElementById('language-toggle');
    const defaultCommissionPercent = parseFloat(commissionInput.value) || 5;
    let lastCommissionRate = defaultCommissionPercent / 100;
    let lastScanData = null;
    let activeTab = 'arbitrage';
    let oddsFormat = localStorage.getItem('edge-odds-format') || 'decimal';
    let isScanning = false;
    let lastStatus = null;

    const TRANSLATIONS = {
      en: {
        tagline: 'Arbitrage / Middles / +EV',
        odds_decimal: 'Decimal',
        odds_american: 'American',
        toggle_theme: 'Toggle theme',
        toggle_language: 'Toggle language',
        api_key_label: 'API Key',
        env_key_notice: 'âœ“ Using API key from .env',
        api_key_show: 'Show API key',
        api_key_hide: 'Hide API key',
        total_stake_label: 'Total Stake ($)',
        stake_helper: 'Used for arbitrage + middles stake splits.',
        sports_label: 'Sports',
        all_sports_label: 'Scan all active sports (uses more API credits)',
        sports_helper: 'Each selected sport consumes one API request.',
        regions_label: 'Regions',
        regions_helper: 'Select at least one region. EU is always included for sharp reference.',
        commission_label: 'Exchange Commission (%)',
        commission_helper: 'Applied to Betfair, Matchbook, Sportsbet Exchange, etc.',
        commission_note: 'Net ROI/EV already reflects this commission.',
        scan_now: 'Scan Now',
        scanning: 'Scanning...',
        scanning_wait: 'Scanning, please wait...',
        tab_arbitrage: 'Arbitrage',
        tab_middles: 'Middles',
        tab_plus_ev: '+EV',
        middle_min_gap: 'Minimum Gap (points)',
        middle_min_gap_helper: 'Only show middles with at least this many points between the lines.',
        filters_label: 'Filters',
        positive_ev_only: 'Show only positive EV middles',
        sort_by: 'Sort By',
        sort_ev: 'Estimated EV',
        sort_probability: 'Probability',
        sort_gap: 'Gap size',
        sort_time: 'Event time',
        sharp_reference_book: 'Sharp Reference Book',
        sharp_book_helper: 'Used as the \"true\" odds source. Pinnacle recommended.',
        min_edge_label: 'Minimum Edge (%)',
        min_edge_helper: 'Filter +EV bets below this edge.',
        kelly_staking: 'Kelly Staking',
        kelly_helper: 'Bankroll + Kelly fraction are not persisted between scans.',
        sort_edge: 'Edge %',
        sort_ev_value: 'EV ($)',
        sort_kelly: 'Kelly stake',
        kelly_full: 'Full Kelly',
        kelly_half: 'Half Kelly',
        kelly_quarter: 'Quarter Kelly',
        kelly_tenth: 'Tenth Kelly',
        stat_opportunities: 'Opportunities',
        stat_events_scanned: 'Events Scanned',
        stat_sports: 'Sports',
        stat_api_calls: 'API Calls',
        stat_middles_found: 'Middles Found',
        stat_positive_middles: '+EV Middles',
        stat_avg_ev: 'Avg EV',
        stat_best_ev: 'Best EV',
        stat_plus_ev_bets: '+EV Bets',
        stat_avg_edge: 'Avg Edge',
        stat_best_edge: 'Best Edge',
        stat_total_ev: 'Total EV ($100)',
        by_roi_band: 'By ROI Band',
        by_sport: 'By Sport',
        by_edge_band: 'By Edge Band',
        key_numbers_label: 'Key Numbers',
        opportunities_title: 'Opportunities',
        middles_title: 'Middles',
        plus_ev_title: '+EV Opportunities',
        sorted_by_roi: 'Sorted by ROI',
        sorted_by_ev: 'Sorted by EV',
        sorted_by_edge: 'Sorted by Edge',
        table_net_roi: 'Net ROI',
        table_gross_roi: 'Gross ROI',
        table_profit: 'Profit',
        table_exchange: 'Exchange',
        table_sport: 'Sport',
        table_event: 'Event',
        table_time: 'Time',
        table_market: 'Market',
        table_outcome_1: 'Outcome 1',
        table_outcome_2: 'Outcome 2',
        table_ev: 'EV',
        table_prob: 'Prob',
        table_gap: 'Gap',
        table_side_a: 'Side A',
        table_side_b: 'Side B',
        table_middle: 'Middle',
        table_win_both: 'Win Both',
        table_miss: 'Miss',
        table_edge: 'Edge',
        table_ev_100: 'EV ($100)',
        table_kelly: 'Kelly',
        table_bet: 'Bet',
        table_soft_odds: 'Soft Odds',
        table_fair_odds: 'Fair Odds',
        table_true_prob: 'True Prob',
        empty_arbitrage: 'No arbitrage opportunities yet.',
        empty_middles: 'No middle opportunities meet your filters.',
        empty_plus_ev: 'No +EV bets at the current thresholds.',
        caveat_middles:
          '<strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 &amp; 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.',
        caveat_plus_ev:
          '<strong>Understanding +EV Betting:</strong> Sharp books (Pinnacle, Betfair, Matchbook) provide near \"true\" odds. When a soft book posts a higher price than fair value, the bet has positive expected value. +EV bets still lose roughly half the time - the edge shows up over many wagers. Kelly staking helps size bets, but variance can still be high. Always confirm odds before betting; edges disappear quickly.',
        summary_title: 'Summary',
        summary_found: 'Found {count} opportunities across {events} events in {sports} sports.',
        summary_profit: 'Total potential profit: {profit}{staked}',
        summary_profit_staked: ' on {staked} staked',
        summary_calls: 'API calls used: {calls}{regions}',
        summary_regions_suffix: ' | Regions: {regions}',
        summary_commission: 'Exchange commission applied: {commission}.',
        summary_roi_note: 'ROI = return on total stake. 2% ROI means $2 profit on a $100 stake.',
        middle_summary_counts: 'Middles matching filters: {count}, with {positive} positive EV.',
        middle_summary_avg: 'Average EV: {avg}{best}',
        middle_summary_best: ' | Best: {event}',
        middle_spreads_only: 'Spreads only',
        plus_summary: '+EV bets: {count} | Average edge {avg}{best}',
        plus_summary_best: ' | Best: {event}',
        results_count: '{count} results',
        results_profit: '{count} results | {profit} profit',
        partial_results: '<strong>Partial results:</strong> Failed to fetch odds for {details}.',
        tbd: 'TBD',
        gross: 'Gross',
        net_at: 'Net @ {odds}',
        odds_label: 'Odds: {odds}',
        stake_label: 'Stake: {stake}',
        exchange: 'Exchange',
        no: 'No',
        no_data: 'No data',
        gap_points: '{points} pts',
        gap_separator: ' / ',
        kelly_roll: '{percent}% roll',
        net_roi_negative: 'Net ROI is negative after commission.',
        scan_complete: 'Scan complete at {time}',
        scan_failed: 'Scan failed',
        enter_api_key: 'Please enter your API key.',
        select_region: 'Select at least one region.',
        unknown: 'Unknown',
        unknown_error: 'Unknown error',
      },
      zh: {
        tagline: 'å¥—åˆ© / ä¸­é—´ç›˜ / +EV',
        odds_decimal: 'åè¿›åˆ¶',
        odds_american: 'ç¾å¼',
        toggle_theme: 'åˆ‡æ¢ä¸»é¢˜',
        toggle_language: 'åˆ‡æ¢è¯­è¨€',
        api_key_label: 'API å¯†é’¥',
        env_key_notice: 'âœ“ ä½¿ç”¨ .env ä¸­çš„ API å¯†é’¥',
        api_key_show: 'æ˜¾ç¤º API å¯†é’¥',
        api_key_hide: 'éšè— API å¯†é’¥',
        total_stake_label: 'æ€»ä¸‹æ³¨é‡‘é¢ ($)',
        stake_helper: 'ç”¨äºå¥—åˆ©å’Œä¸­é—´ç›˜çš„ä¸‹æ³¨æ‹†åˆ†è®¡ç®—ã€‚',
        sports_label: 'ä½“è‚²é¡¹ç›®',
        all_sports_label: 'æ‰«ææ‰€æœ‰æ´»è·ƒé¡¹ç›®ï¼ˆæ¶ˆè€—æ›´å¤š API é¢åº¦ï¼‰',
        sports_helper: 'æ¯ä¸ªå·²é€‰é¡¹ç›®ä¼šæ¶ˆè€—ä¸€æ¬¡ API è¯·æ±‚ã€‚',
        regions_label: 'åœ°åŒº',
        regions_helper: 'è‡³å°‘é€‰æ‹©ä¸€ä¸ªåœ°åŒºã€‚ä¸ºé”ç›˜å‚è€ƒå°†å§‹ç»ˆåŒ…å« EUã€‚',
        commission_label: 'äº¤æ˜“æ‰€æ‰‹ç»­è´¹ (%)',
        commission_helper: 'é€‚ç”¨äº Betfairã€Matchbookã€Sportsbet Exchange ç­‰ã€‚',
        commission_note: 'å‡€ ROI/EV å·²è®¡å…¥è¯¥æ‰‹ç»­è´¹ã€‚',
        scan_now: 'å¼€å§‹æ‰«æ',
        scanning: 'æ‰«æä¸­...',
        scanning_wait: 'æ­£åœ¨æ‰«æï¼Œè¯·ç¨å€™...',
        tab_arbitrage: 'å¥—åˆ©',
        tab_middles: 'ä¸­é—´ç›˜',
        tab_plus_ev: '+EV',
        middle_min_gap: 'æœ€å°é—´éš”ï¼ˆåˆ†ï¼‰',
        middle_min_gap_helper: 'ä»…æ˜¾ç¤ºç›˜å£å·®è‡³å°‘è¾¾åˆ°è¯¥åˆ†æ•°çš„ä¸­é—´ç›˜ã€‚',
        filters_label: 'ç­›é€‰',
        positive_ev_only: 'ä»…æ˜¾ç¤ºæ­£ EV çš„ä¸­é—´ç›˜',
        sort_by: 'æ’åº',
        sort_ev: 'é¢„è®¡ EV',
        sort_probability: 'æ¦‚ç‡',
        sort_gap: 'é—´éš”å¤§å°',
        sort_time: 'æ¯”èµ›æ—¶é—´',
        sharp_reference_book: 'é”ç›˜å‚è€ƒä¹¦å•†',
        sharp_book_helper: 'ä½œä¸ºâ€œçœŸå®â€èµ”ç‡å‚è€ƒæ¥æºï¼Œæ¨è Pinnacleã€‚',
        min_edge_label: 'æœ€å° Edge (%)',
        min_edge_helper: 'è¿‡æ»¤ä½äºè¯¥è¾¹é™…çš„ +EV æŠ•æ³¨ã€‚',
        kelly_staking: 'å‡¯åˆ©ä¸‹æ³¨',
        kelly_helper: 'èµ„é‡‘å’Œå‡¯åˆ©æ¯”ä¾‹ä¸ä¼šåœ¨æ‰«æä¹‹é—´ä¿å­˜ã€‚',
        sort_edge: 'Edge %',
        sort_ev_value: 'EV ($)',
        sort_kelly: 'å‡¯åˆ©ä¸‹æ³¨',
        kelly_full: 'å…¨å‡¯åˆ©',
        kelly_half: 'åŠå‡¯åˆ©',
        kelly_quarter: 'å››åˆ†ä¹‹ä¸€å‡¯åˆ©',
        kelly_tenth: 'ååˆ†ä¹‹ä¸€å‡¯åˆ©',
        stat_opportunities: 'æœºä¼š',
        stat_events_scanned: 'æ‰«æèµ›äº‹',
        stat_sports: 'é¡¹ç›®æ•°',
        stat_api_calls: 'API è°ƒç”¨',
        stat_middles_found: 'ä¸­é—´ç›˜æ•°é‡',
        stat_positive_middles: '+EV ä¸­é—´ç›˜',
        stat_avg_ev: 'å¹³å‡ EV',
        stat_best_ev: 'æœ€é«˜ EV',
        stat_plus_ev_bets: '+EV æŠ•æ³¨',
        stat_avg_edge: 'å¹³å‡ Edge',
        stat_best_edge: 'æœ€é«˜ Edge',
        stat_total_ev: 'æ€» EVï¼ˆ$100ï¼‰',
        by_roi_band: 'æŒ‰ ROI åŒºé—´',
        by_sport: 'æŒ‰é¡¹ç›®',
        by_edge_band: 'æŒ‰ Edge åŒºé—´',
        key_numbers_label: 'å…³é”®åˆ†å·®',
        opportunities_title: 'æœºä¼š',
        middles_title: 'ä¸­é—´ç›˜',
        plus_ev_title: '+EV æœºä¼š',
        sorted_by_roi: 'æŒ‰ ROI æ’åº',
        sorted_by_ev: 'æŒ‰ EV æ’åº',
        sorted_by_edge: 'æŒ‰ Edge æ’åº',
        table_net_roi: 'å‡€ ROI',
        table_gross_roi: 'æ€» ROI',
        table_profit: 'åˆ©æ¶¦',
        table_exchange: 'äº¤æ˜“æ‰€',
        table_sport: 'é¡¹ç›®',
        table_event: 'èµ›äº‹',
        table_time: 'æ—¶é—´',
        table_market: 'ç›˜å£',
        table_outcome_1: 'é€‰é¡¹ 1',
        table_outcome_2: 'é€‰é¡¹ 2',
        table_ev: 'EV',
        table_prob: 'æ¦‚ç‡',
        table_gap: 'é—´éš”',
        table_side_a: 'A è¾¹',
        table_side_b: 'B è¾¹',
        table_middle: 'ä¸­é—´åŒºé—´',
        table_win_both: 'ä¸¤è¾¹å…¨èµ¢',
        table_miss: 'æœªå‘½ä¸­',
        table_edge: 'Edge',
        table_ev_100: 'EV ($100)',
        table_kelly: 'å‡¯åˆ©',
        table_bet: 'æŠ•æ³¨',
        table_soft_odds: 'è½¯ç›˜èµ”ç‡',
        table_fair_odds: 'å…¬å¹³èµ”ç‡',
        table_true_prob: 'çœŸå®æ¦‚ç‡',
        empty_arbitrage: 'æš‚æ— å¥—åˆ©æœºä¼šã€‚',
        empty_middles: 'æ²¡æœ‰ç¬¦åˆç­›é€‰æ¡ä»¶çš„ä¸­é—´ç›˜ã€‚',
        empty_plus_ev: 'å½“å‰é˜ˆå€¼ä¸‹æš‚æ—  +EV æŠ•æ³¨ã€‚',
        caveat_middles:
          '<strong>ç†è§£ä¸­é—´ç›˜ï¼š</strong>ä¸­é—´ç›˜å±äºé«˜æ³¢åŠ¨ç©æ³•ï¼Œå¤§å¤šæ•°æ—¶å€™å°äºï¼Œæ¯”åˆ†è½åœ¨åŒºé—´å†…æ—¶å¤§èµ¢ã€‚æ¦‚ç‡ä¸ºå†å²åˆ†å¸ƒä¼°ç®—ï¼ˆNFL å…³é”®åˆ†å·®å¦‚ 3ã€7 ä¼šæ˜¾è‘—æå‡ EVï¼‰ã€‚è¯·å°† EV è§†ä¸ºå‚è€ƒå¹¶è°¨æ…ä¸‹æ³¨ã€‚',
        caveat_plus_ev:
          '<strong>ç†è§£ +EV æŠ•æ³¨ï¼š</strong>é”ç›˜ï¼ˆPinnacleã€Betfairã€Matchbookï¼‰æä¾›æ¥è¿‘â€œçœŸå®â€çš„èµ”ç‡ã€‚å½“è½¯ç›˜ç»™å‡ºé«˜äºå…¬å¹³èµ”ç‡çš„ä»·æ ¼æ—¶ï¼Œè¯¥æŠ•æ³¨ä¸ºæ­£æœŸæœ›ã€‚+EV æŠ•æ³¨ä»æœ‰çº¦ä¸€åŠæ—¶é—´ä¼šè¾“ï¼Œä¼˜åŠ¿æ¥è‡ªé•¿æœŸã€‚å‡¯åˆ©æ³•å¯å¸®åŠ©æ§åˆ¶ä¸‹æ³¨è§„æ¨¡ï¼Œä½†æ³¢åŠ¨ä»ç„¶å­˜åœ¨ã€‚ä¸‹æ³¨å‰åŠ¡å¿…ç¡®è®¤èµ”ç‡ï¼Œä¼˜åŠ¿ä¼šè¿…é€Ÿæ¶ˆå¤±ã€‚',
        summary_title: 'æ¦‚è§ˆ',
        summary_found: 'å…±å‘ç° {count} ä¸ªæœºä¼šï¼Œè¦†ç›– {events} åœºèµ›äº‹ã€{sports} ä¸ªé¡¹ç›®ã€‚',
        summary_profit: 'æ½œåœ¨æ€»åˆ©æ¶¦ï¼š{profit}{staked}',
        summary_profit_staked: 'ï¼ˆæ€»ä¸‹æ³¨ {staked}ï¼‰',
        summary_calls: 'API è°ƒç”¨æ¬¡æ•°ï¼š{calls}{regions}',
        summary_regions_suffix: ' | åœ°åŒºï¼š{regions}',
        summary_commission: 'å·²è®¡å…¥äº¤æ˜“æ‰€æ‰‹ç»­è´¹ï¼š{commission}ã€‚',
        summary_roi_note: 'ROI ä¸ºæ€»ä¸‹æ³¨å›æŠ¥ç‡ã€‚2% ROI æ„å‘³ç€ä¸‹æ³¨ $100 çº¦ç›ˆåˆ© $2ã€‚',
        middle_summary_counts: 'ç¬¦åˆç­›é€‰çš„ä¸­é—´ç›˜ï¼š{count}ï¼Œå…¶ä¸­ {positive} ä¸ºæ­£ EVã€‚',
        middle_summary_avg: 'å¹³å‡ EVï¼š{avg}{best}',
        middle_summary_best: ' | æœ€ä½³ï¼š{event}',
        middle_spreads_only: 'ä»…è®©åˆ†',
        plus_summary: '+EV æŠ•æ³¨ï¼š{count} | å¹³å‡ Edge {avg}{best}',
        plus_summary_best: ' | æœ€ä½³ï¼š{event}',
        results_count: '{count} æ¡ç»“æœ',
        results_profit: '{count} æ¡ç»“æœ | åˆ©æ¶¦ {profit}',
        partial_results: '<strong>éƒ¨åˆ†ç»“æœï¼š</strong>ä»¥ä¸‹é¡¹ç›®æœªèƒ½è·å–èµ”ç‡ï¼š{details}ã€‚',
        tbd: 'å¾…å®š',
        gross: 'æ€»',
        net_at: 'å‡€ @ {odds}',
        odds_label: 'èµ”ç‡ï¼š{odds}',
        stake_label: 'ä¸‹æ³¨ï¼š{stake}',
        exchange: 'äº¤æ˜“æ‰€',
        no: 'å¦',
        no_data: 'æš‚æ— æ•°æ®',
        gap_points: '{points} åˆ†',
        gap_separator: ' / ',
        kelly_roll: '{percent}% èµ„é‡‘',
        net_roi_negative: 'è®¡å…¥æ‰‹ç»­è´¹åå‡€ ROI ä¸ºè´Ÿã€‚',
        scan_complete: 'æ‰«æå®Œæˆï¼š{time}',
        scan_failed: 'æ‰«æå¤±è´¥',
        enter_api_key: 'è¯·è¾“å…¥ API å¯†é’¥ã€‚',
        select_region: 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåœ°åŒºã€‚',
        unknown: 'æœªçŸ¥',
        unknown_error: 'æœªçŸ¥é”™è¯¯',
      },
    };

    const SPORT_KEY_LABELS = {
      zh: {
        americanfootball_nfl: 'NFL',
        basketball_nba: 'NBA',
        baseball_mlb: 'MLB',
        icehockey_nhl: 'NHL',
        soccer_epl: 'è‹±è¶…',
        soccer_spain_la_liga: 'è¥¿ç”²',
        soccer_germany_bundesliga: 'å¾·ç”²',
        soccer_italy_serie_a: 'æ„ç”²',
        soccer_france_ligue_one: 'æ³•ç”²',
        soccer_usa_mls: 'ç¾èŒè”',
      },
    };

    const SPORT_LABELS = {
      zh: {
        NFL: 'NFL',
        NBA: 'NBA',
        MLB: 'MLB',
        NHL: 'NHL',
        'Premier League': 'è‹±è¶…',
        'La Liga': 'è¥¿ç”²',
        Bundesliga: 'å¾·ç”²',
        'Serie A': 'æ„ç”²',
        'Ligue 1': 'æ³•ç”²',
        MLS: 'ç¾èŒè”',
        Other: 'å…¶ä»–',
      },
    };

    const REGION_LABELS = {
      zh: {
        us: 'ç¾å›½',
        us2: 'ç¾å›½ï¼ˆæ›´å¤šï¼‰',
        uk: 'è‹±å›½',
        eu: 'æ¬§æ´²',
        au: 'æ¾³å¤§åˆ©äºš',
      },
    };

    const MARKET_LABELS = {
      zh: {
        h2h: 'èƒœè´Ÿ',
        spreads: 'è®©åˆ†',
        totals: 'å¤§å°åˆ†',
      },
    };

    let activeLanguage = localStorage.getItem('edge-language');
    if (!activeLanguage) {
      activeLanguage = (navigator.language || '').toLowerCase().startsWith('zh') ? 'zh' : 'en';
    }
    let activeLocale = activeLanguage === 'zh' ? 'zh-CN' : 'en-US';
    currencyFormatter = createCurrencyFormatter(activeLocale);

    function t(key, params = {}) {
      const table = TRANSLATIONS[activeLanguage] || TRANSLATIONS.en || {};
      const fallback = TRANSLATIONS.en || {};
      let template = table[key] ?? fallback[key] ?? key;
      Object.entries(params).forEach(([name, value]) => {
        template = template.replace(new RegExp(`\\{${name}\\}`, 'g'), () => String(value));
      });
      return template;
    }

    function createCurrencyFormatter(locale) {
      return new Intl.NumberFormat(locale, { style: 'currency', currency: 'USD' });
    }

    function applyTranslations() {
      document.documentElement.lang = activeLocale;
      document.querySelectorAll('[data-i18n]').forEach((el) => {
        const key = el.dataset.i18n;
        el.textContent = t(key);
      });
      document.querySelectorAll('[data-i18n-html]').forEach((el) => {
        const key = el.dataset.i18nHtml;
        el.innerHTML = t(key);
      });
      if (themeToggle) {
        themeToggle.title = t('toggle_theme');
      }
      if (languageToggle) {
        languageToggle.setAttribute('aria-label', t('toggle_language'));
      }
      updateLanguageToggle();
      updateOddsToggle();
      updateSportLabels();
      updateRegionLabels();
      updateKellyOptions();
      updateToggleKeyLabel();
      updateScanButtonText();
      refreshStatus();
      setActiveTab(activeTab);
    }

    function setLanguage(nextLang) {
      const normalized = TRANSLATIONS[nextLang] ? nextLang : 'en';
      if (normalized === activeLanguage) return;
      activeLanguage = normalized;
      activeLocale = activeLanguage === 'zh' ? 'zh-CN' : 'en-US';
      localStorage.setItem('edge-language', activeLanguage);
      currencyFormatter = createCurrencyFormatter(activeLocale);
      applyTranslations();
      renderPartialWarning(lastScanData);
    }

    function updateLanguageToggle() {
      if (!languageToggle) return;
      languageToggle.querySelectorAll('span').forEach((span) => {
        span.classList.toggle('active', span.dataset.lang === activeLanguage);
      });
    }

    function updateScanButtonText() {
      if (!scanBtn) return;
      scanBtn.textContent = isScanning ? t('scanning') : t('scan_now');
    }

    function updateToggleKeyLabel() {
      if (!toggleKeyBtn || !apiKeyInput) return;
      const key = apiKeyInput.type === 'password' ? 'api_key_show' : 'api_key_hide';
      toggleKeyBtn.setAttribute('aria-label', t(key));
    }

    function updateSportLabels() {
      document.querySelectorAll('[data-sport-key]').forEach((el) => {
        if (!el.dataset.defaultLabel) {
          el.dataset.defaultLabel = el.textContent.trim();
        }
        const key = el.dataset.sportKey;
        const fallback = el.dataset.defaultLabel;
        const translated = translateSportKey(key, fallback);
        el.textContent = translated;
      });
    }

    function updateRegionLabels() {
      document.querySelectorAll('[data-region-key]').forEach((el) => {
        if (!el.dataset.defaultLabel) {
          el.dataset.defaultLabel = el.textContent.trim();
        }
        const key = el.dataset.regionKey;
        const fallback = el.dataset.defaultLabel;
        const translated = translateRegionKey(key, fallback);
        el.textContent = translated;
      });
    }

    function updateKellyOptions() {
      if (!kellySelect) return;
      kellySelect.querySelectorAll('option[data-kelly-value]').forEach((option) => {
        const value = parseFloat(option.dataset.kellyValue);
        let key = 'kelly_tenth';
        if (value === 1) key = 'kelly_full';
        else if (value === 0.5) key = 'kelly_half';
        else if (value === 0.25) key = 'kelly_quarter';
        option.textContent = t(key);
      });
    }

    function translateSportKey(key, fallback) {
      if (activeLanguage !== 'zh') return fallback;
      const map = SPORT_KEY_LABELS[activeLanguage] || {};
      return map[key] || fallback;
    }

    function translateSportLabel(label) {
      if (!label || activeLanguage !== 'zh') return label || '';
      const map = SPORT_LABELS[activeLanguage] || {};
      return map[label] || label;
    }

    function translateRegionKey(key, fallback) {
      if (activeLanguage !== 'zh') return fallback;
      const map = REGION_LABELS[activeLanguage] || {};
      return map[key] || fallback;
    }

    function translateMarketLabel(market) {
      if (!market || activeLanguage !== 'zh') return market || '';
      const map = MARKET_LABELS[activeLanguage] || {};
      return map[market] || market;
    }

    function formatDateTime(value) {
      if (!value) return t('tbd');
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return t('tbd');
      return date.toLocaleString(activeLocale);
    }

    function formatTime(value) {
      if (!value) return t('tbd');
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return t('tbd');
      return date.toLocaleTimeString(activeLocale);
    }

    function refreshStatus() {
      if (!lastStatus) return;
      const { key, params, type, message } = lastStatus;
      if (key) {
        statusEl.textContent = t(key, params);
      } else if (message !== undefined) {
        statusEl.textContent = message;
      }
      statusEl.className = type ? `status ${type}` : 'status';
    }

    document.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('arb-theme');
      if (savedTheme) {
        document.documentElement.dataset.theme = savedTheme;
        themeToggle.textContent = savedTheme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
      }
      applyTranslations();
    });

    if (toggleKeyBtn && apiKeyInput) {
      toggleKeyBtn.addEventListener('click', () => {
        if (apiKeyInput.type === 'password') {
          apiKeyInput.type = 'text';
          toggleKeyBtn.textContent = 'ğŸ™ˆ';
        } else {
          apiKeyInput.type = 'password';
          toggleKeyBtn.textContent = 'ğŸ‘';
        }
        updateToggleKeyLabel();
      });
    }

    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.dataset.theme || 'light';
      const next = current === 'light' ? 'dark' : 'light';
      document.documentElement.dataset.theme = next;
      localStorage.setItem('arb-theme', next);
      themeToggle.textContent = next === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
    });

    if (oddsToggle) {
      oddsToggle.addEventListener('click', () => {
        oddsFormat = oddsFormat === 'decimal' ? 'american' : 'decimal';
        localStorage.setItem('edge-odds-format', oddsFormat);
        updateOddsToggle();
        renderArbitrage();
        renderMiddles();
        renderPlusEv();
      });
    }

    if (languageToggle) {
      languageToggle.addEventListener('click', (event) => {
        const target = event.target;
        const selected = target && target.dataset ? target.dataset.lang : null;
        const nextLang = selected || (activeLanguage === 'en' ? 'zh' : 'en');
        setLanguage(nextLang);
      });
    }

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        const target = tab.dataset.tab;
        if (target && target !== activeTab) {
          setActiveTab(target);
        }
      });
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      if (!hasEnvKey && !apiKeyInput?.value.trim()) {
        showStatusKey('enter_api_key', 'error');
        return;
      }
      const sports = Array.from(form.querySelectorAll('input[name="sports"]:checked')).map((el) => el.value);
      const regions = Array.from(form.querySelectorAll('input[name="regions"]:checked')).map((el) => el.value);
      if (!regions.length) {
        showStatusKey('select_region', 'error');
        return;
      }
      const stakeValue = parseFloat(stakeInput.value) || 100;
      const commissionValue = Number.isFinite(parseFloat(commissionInput.value))
        ? parseFloat(commissionInput.value)
        : defaultCommissionPercent;
      await runScan({
        apiKey: apiKeyInput ? apiKeyInput.value.trim() : '',
        sports,
        regions,
        commission: commissionValue,
        allSports: allSportsToggle.checked,
        stake: stakeValue,
        sharpBook: sharpSelect?.value || appConfig.defaultSharpBook,
        minEdgePercent: parseFloat(minEdgeInput?.value) || appConfig.defaultMinEdgePercent || 1,
        bankroll: parseFloat(bankrollInput?.value) || appConfig.defaultBankroll || 1000,
        kellyFraction: parseFloat(kellySelect?.value) || appConfig.defaultKellyFraction || 0.25,
      });
    });

    stakeInput.addEventListener('input', () => {
      if (lastScanData) {
        renderArbitrage();
        renderMiddles();
      }
    });

    minGapInput.addEventListener('input', () => renderMiddles());
    positiveEvToggle.addEventListener('change', () => renderMiddles());
    middleSortSelect.addEventListener('change', () => renderMiddles());
    minEdgeInput.addEventListener('input', () => renderPlusEv());
    bankrollInput.addEventListener('input', () => renderPlusEv());
    kellySelect.addEventListener('change', () => renderPlusEv());
    plusEvSortSelect.addEventListener('change', () => renderPlusEv());

    async function runScan(payload) {
      setScanning(true);
      try {
        const response = await fetch('/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: payload.apiKey,
            sports: payload.sports,
            allSports: payload.allSports,
            stake: payload.stake,
            regions: payload.regions,
            commission: payload.commission,
            sharpBook: payload.sharpBook,
            minEdgePercent: payload.minEdgePercent,
            bankroll: payload.bankroll,
            kellyFraction: payload.kellyFraction,
          }),
        });
        const data = await response.json();
        if (!data.success) {
          throw new Error(data.error || t('scan_failed'));
        }
        if (data?.middles?.defaults) {
          const defaults = data.middles.defaults;
          if (defaults.min_gap !== undefined) minGapInput.value = defaults.min_gap;
          if (defaults.positive_only !== undefined) positiveEvToggle.checked = defaults.positive_only;
          if (defaults.sort) middleSortSelect.value = defaults.sort;
        }
        if (data?.plus_ev?.defaults) {
          const defaults = data.plus_ev.defaults;
          if (defaults.sharp_book) sharpSelect.value = defaults.sharp_book;
          if (defaults.min_edge_percent !== undefined) minEdgeInput.value = defaults.min_edge_percent;
          if (defaults.bankroll !== undefined) bankrollInput.value = defaults.bankroll;
          if (defaults.kelly_fraction !== undefined) kellySelect.value = defaults.kelly_fraction;
        }
        renderScanData(data);
        showStatusKey('scan_complete', 'success', { time: formatTime(data.scan_time) });
      } catch (err) {
        showStatus(err.message || t('scan_failed'), 'error');
        renderScanData(null);
      } finally {
        setScanning(false);
      }
    }

    function setScanning(nextState) {
      isScanning = nextState;
      scanBtn.disabled = nextState;
      updateScanButtonText();
      statusEl.textContent = nextState ? t('scanning_wait') : '';
      statusEl.className = 'status';
      lastStatus = nextState ? { key: 'scanning_wait', params: {}, type: null } : null;
    }

    function showStatus(message, type, key = null, params = {}) {
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
      lastStatus = { message, type, key, params };
    }

    function showStatusKey(key, type, params = {}) {
      showStatus(t(key, params), type, key, params);
    }

    function renderScanData(payload) {
      lastScanData = payload;
      if (payload && typeof payload.commission_rate === 'number') {
        lastCommissionRate = payload.commission_rate;
      }
      renderArbitrage();
      renderMiddles();
      renderPlusEv();
      renderPartialWarning(payload);
    }

    function renderArbitrage() {
      const arbData = lastScanData?.arbitrage;
      const opportunities = arbData?.opportunities || [];
      const stakeValue = parseFloat(stakeInput.value) || 0;
      resultsBody.innerHTML = '';
      tableCount.textContent = t('results_count', { count: opportunities.length });
      if (!opportunities.length) {
        emptyState.classList.remove('hidden');
      } else {
        emptyState.classList.add('hidden');
        let runningProfit = 0;
        opportunities.forEach((opp) => {
          const row = document.createElement('tr');
          const calcNet = calculateStakes(opp, stakeValue, true);
          const netRoi = calcNet?.roi_percent ?? opp.roi_percent;
          row.classList.add(roiBandClass(netRoi));
          const commence = formatDateTime(opp.commence_time);
          const calcGross = opp.has_exchange ? calculateStakes(opp, stakeValue, false) : null;
          const grossRoi = opp.has_exchange ? calcGross?.roi_percent ?? opp.gross_roi_percent : null;
          const netNegative = typeof netRoi === 'number' && netRoi < 0;
          if (netNegative) row.classList.add('roi-negative');
          if (opp.has_exchange) row.classList.add('has-exchange');
          const breakdown = calcNet?.breakdown || [];
          const profitValue = calcNet?.guaranteed_profit ?? 0;
          runningProfit += profitValue || 0;
          const profitClass = profitValue > 0 ? 'gain' : profitValue < 0 ? 'loss' : '';
          const grossCell = opp.has_exchange ? formatRoiBadge(grossRoi) : '';
          const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
          row.innerHTML = `
            <td><span class="roi-badge">${formatPercent(netRoi)}</span>${netNegative ? `<span class="roi-warning" title="${t('net_roi_negative')}">âš </span>` : ''}</td>
            <td>${grossCell}</td>
            <td class="profit-cell ${profitClass}">${calcNet ? formatProfit(profitValue) : '-'}</td>
            <td>${formatExchangeCell(opp)}</td>
            <td>${sportLabel}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${formatMarket(opp)}</td>
            <td>${formatOutcome(breakdown[0])}</td>
            <td>${formatOutcome(breakdown[1])}</td>`;
          resultsBody.appendChild(row);
        });
        tableCount.textContent = t('results_profit', {
          count: opportunities.length,
          profit: formatCurrency(runningProfit),
        });
      }
      const summary = arbData?.summary;
      if (summary) {
        statOpps.textContent = arbData.opportunities_count || opportunities.length;
        statEvents.textContent = summary.events_scanned;
        statSports.textContent = summary.sports_scanned;
        statCalls.textContent = summary.api_calls_used;
        const totalProfit = opportunities.reduce((sum, opp) => {
          const calc = calculateStakes(opp, parseFloat(stakeInput.value) || stakeValue, true);
          return sum + (calc?.guaranteed_profit || 0);
        }, 0);
        renderBars(summaryROI, summary.by_roi_band, 'roi');
        renderBars(summarySport, summary.by_sport, 'sport');
        const totalStaked = stakeValue > 0 ? stakeValue * opportunities.length : 0;
        const commissionPercent = formatCommissionPercent(lastCommissionRate);
        const regionsLabel = Array.isArray(lastScanData?.regions) && lastScanData.regions.length
          ? lastScanData.regions.join(', ').toUpperCase()
          : '';
        const countText = `<strong>${arbData.opportunities_count || opportunities.length}</strong>`;
        const eventsText = `<strong>${summary.events_scanned}</strong>`;
        const sportsText = `<strong>${summary.sports_scanned}</strong>`;
        const profitText = `<strong>${formatCurrency(totalProfit)}</strong>`;
        const stakedText = totalStaked
          ? t('summary_profit_staked', { staked: `<strong>${formatCurrency(totalStaked)}</strong>` })
          : '';
        const regionsSuffix = regionsLabel ? t('summary_regions_suffix', { regions: regionsLabel }) : '';
        const callsText = t('summary_calls', { calls: summary.api_calls_used, regions: regionsSuffix });
        summaryEl.classList.remove('hidden');
        summaryEl.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('summary_found', { count: countText, events: eventsText, sports: sportsText })}</p>
          <p>${t('summary_profit', { profit: profitText, staked: stakedText })}</p>
          <p>${callsText}</p>
          <p>${t('summary_commission', { commission: commissionPercent })}</p>
          <p class="helper">${t('summary_roi_note')}</p>
        `;
      } else {
        statOpps.textContent = statEvents.textContent = statSports.textContent = statCalls.textContent = '0';
        summaryROI.innerHTML = '';
        summarySport.innerHTML = '';
        summaryEl.classList.add('hidden');
        summaryEl.innerHTML = '';
      }
    }

    function renderMiddles() {
      const data = lastScanData?.middles;
      const opportunities = data?.opportunities || [];
      const minGap = parseFloat(minGapInput.value) || 0;
      const positiveOnly = positiveEvToggle.checked;
      const sortKey = middleSortSelect.value || 'ev';
      const scannedStake = data?.stake_amount || 0;
      const desiredStake = parseFloat(stakeInput.value) || scannedStake || 100;
      const stakeRatio = scannedStake > 0 ? desiredStake / scannedStake : 1;
      const filtered = opportunities.filter((opp) => {
        const gapPoints = opp.gap?.points ?? 0;
        if (gapPoints < minGap) return false;
        if (positiveOnly && opp.ev_percent <= 0) return false;
        return true;
      });
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'probability':
            return (b.middle_probability || 0) - (a.middle_probability || 0);
          case 'gap':
            return (b.gap?.integer_count || 0) - (a.gap?.integer_count || 0);
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'ev':
          default:
            return (b.ev_percent || 0) - (a.ev_percent || 0);
        }
      });
      const stats = buildMiddleStats(filtered);
      middleStatCount.textContent = stats.count;
      middleStatPositive.textContent = stats.positive_count;
      middleStatAvg.textContent = formatPercent(stats.average_ev_percent);
      middleStatBest.textContent = formatPercent(stats.best_ev_percent);
      if (stats.count > 0) {
        middleSummaryInfo.classList.remove('hidden');
        const countText = `<strong>${stats.count}</strong>`;
        const positiveText = `<strong>${stats.positive_count}</strong>`;
        const avgText = `<strong>${formatPercent(stats.average_ev_percent)}</strong>`;
        const bestText = stats.best_event ? t('middle_summary_best', { event: stats.best_event }) : '';
        middleSummaryInfo.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('middle_summary_counts', { count: countText, positive: positiveText })}</p>
          <p>${t('middle_summary_avg', { avg: avgText, best: bestText })}</p>
        `;
        renderBars(middleSportBars, stats.by_sport, 'sport');
        if (Object.keys(stats.key_numbers).length) {
          middleKeyCard.classList.remove('hidden');
          renderBars(middleKeyBars, stats.key_numbers, 'sport');
        } else {
          middleKeyCard.classList.add('hidden');
          middleKeyBars.innerHTML = `<p class="muted">${t('middle_spreads_only')}</p>`;
        }
      } else {
        middleSummaryInfo.classList.add('hidden');
        middleSummaryInfo.innerHTML = '';
        middleSportBars.innerHTML = '';
        middleKeyCard.classList.add('hidden');
        middleKeyBars.innerHTML = `<p class="muted">${t('middle_spreads_only')}</p>`;
      }

      middlesTableBody.innerHTML = '';
      middlesTableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        middlesEmpty.classList.remove('hidden');
      } else {
        middlesEmpty.classList.add('hidden');
        filtered.forEach((opp) => {
          const row = document.createElement('tr');
          const evClass = evBandClass(opp.ev_percent);
          if (evClass) row.classList.add(evClass);
          if (opp.has_exchange) row.classList.add('has-exchange');
          const commence = formatDateTime(opp.commence_time);
          const stakeA = (opp.stakes?.side_a?.stake || 0) * stakeRatio;
          const stakeB = (opp.stakes?.side_b?.stake || 0) * stakeRatio;
          const winBoth = (opp.outcomes?.win_both_profit || 0) * stakeRatio;
          const miss = (opp.outcomes?.typical_miss_profit || 0) * stakeRatio;
          const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
          const marketLabel = translateMarketLabel(opp.market || '');
          row.innerHTML = `
            <td>${formatPercent(opp.ev_percent)}${opp.has_exchange && typeof opp.gross_ev_percent === 'number' ? `<span class="ev-gross">${t('gross')} ${formatPercent(opp.gross_ev_percent)}</span>` : ''}</td>
            <td>${formatPercent(opp.probability_percent)}</td>
            <td>${formatGapCell(opp)}</td>
            <td>${sportLabel}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${marketLabel}</td>
            <td>${formatMiddleSide(opp.side_a, stakeA)}</td>
            <td>${formatMiddleSide(opp.side_b, stakeB)}</td>
            <td>${opp.middle_zone || ''}</td>
            <td class="profit-cell">${formatProfit(winBoth)}</td>
            <td class="profit-cell">${formatProfit(miss)}</td>
          `;
          middlesTableBody.appendChild(row);
        });
      }
    }

    function renderPlusEv() {
      const plusData = lastScanData?.plus_ev;
      const opportunities = plusData?.opportunities || [];
      const minEdge = parseFloat(minEdgeInput.value) || appConfig.defaultMinEdgePercent || 1;
      const bankroll = parseFloat(bankrollInput.value) || appConfig.defaultBankroll || 1000;
      const kellyFraction = parseFloat(kellySelect.value) || appConfig.defaultKellyFraction || 0.25;
      const sortKey = plusEvSortSelect.value || 'edge';
      const filtered = opportunities.filter((opp) => (opp.edge_percent || 0) >= minEdge);
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'ev':
            return (b.ev_per_100 || 0) - (a.ev_per_100 || 0);
          case 'kelly': {
            const bkA = calculateKellyStake(oppTrueProb(a), oppEffectiveOdds(a), bankroll, kellyFraction);
            const bkB = calculateKellyStake(oppTrueProb(b), oppEffectiveOdds(b), bankroll, kellyFraction);
            return bkB.recommended - bkA.recommended;
          }
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'edge':
          default:
            return (b.edge_percent || 0) - (a.edge_percent || 0);
        }
      });
      const stats = buildPlusEvStats(filtered);
      plusEvCount.textContent = stats.count;
      plusEvAvg.textContent = formatPercent(stats.average_edge_percent);
      plusEvBest.textContent = formatPercent(stats.best_edge_percent);
      plusEvTotal.textContent = formatCurrency(stats.total_ev_per_100);
      if (stats.count > 0) {
        plusEvSummaryInfo.classList.remove('hidden');
        const countText = `<strong>${stats.count}</strong>`;
        const avgText = `<strong>${formatPercent(stats.average_edge_percent)}</strong>`;
        const bestText = stats.best_event ? t('plus_summary_best', { event: stats.best_event }) : '';
        plusEvSummaryInfo.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('plus_summary', { count: countText, avg: avgText, best: bestText })}</p>
        `;
        renderBars(plusEvSportBars, stats.by_sport, 'sport');
        renderBars(plusEvEdgeBars, stats.by_edge_band, 'roi');
      } else {
        plusEvSummaryInfo.classList.add('hidden');
        plusEvSummaryInfo.innerHTML = '';
        plusEvSportBars.innerHTML = `<p class="muted">${t('no_data')}</p>`;
        plusEvEdgeBars.innerHTML = `<p class="muted">${t('no_data')}</p>`;
      }

      plusEvTableBody.innerHTML = '';
      plusEvTableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        plusEvEmpty.classList.remove('hidden');
        return;
      }
      plusEvEmpty.classList.add('hidden');
      filtered.forEach((opp) => {
        const row = document.createElement('tr');
        if (opp.has_exchange) row.classList.add('has-exchange');
        const commence = formatDateTime(opp.commence_time);
        const kellyData = calculateKellyStake(oppTrueProb(opp), oppEffectiveOdds(opp), bankroll, kellyFraction);
        const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
        row.innerHTML = `
          <td>${formatEdgeCell(opp)}</td>
          <td class="profit-cell">${formatProfit(opp.ev_per_100 || 0)}</td>
          <td>${formatKellyCell(kellyData)}</td>
          <td>${sportLabel}</td>
          <td>${opp.event || ''}</td>
          <td>${commence}</td>
          <td>${formatPlusMarket(opp)}</td>
          <td>${formatPlusBet(opp)}</td>
          <td>${formatOddsDisplay(opp.bet?.soft_odds)}</td>
          <td>${formatOddsDisplay(opp.sharp?.fair_odds)}</td>
          <td>${formatPercent(opp.sharp?.true_probability_percent)}</td>
        `;
        plusEvTableBody.appendChild(row);
      });
    }

    function oppTrueProb(opp) {
      return opp?.sharp?.true_probability ?? (opp?.sharp?.true_probability_percent || 0) / 100;
    }

    function oppEffectiveOdds(opp) {
      return opp?.bet?.effective_odds || opp?.bet?.soft_odds || 0;
    }

    function calculateKellyStake(prob, odds, bankroll, fraction) {
      if (!prob || !odds || bankroll <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      const p = Math.max(0, Math.min(prob, 1));
      const q = 1 - p;
      const b = odds - 1;
      if (b <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      let full = (b * p - q) / b;
      if (full <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      const frac = Math.max(0, Math.min(fraction, 1));
      const adjusted = full * frac;
      const recommended = Math.max(0, bankroll * adjusted);
      return {
        fullPercent: full * 100,
        fractionPercent: adjusted * 100,
        recommended: Number(recommended.toFixed(2)),
      };
    }

    function formatEdgeCell(opp) {
      const net = formatPercent(opp.edge_percent);
      if (opp.has_exchange && typeof opp.gross_edge_percent === 'number' && opp.gross_edge_percent !== opp.edge_percent) {
        return `${net}<span class="ev-gross">${t('gross')} ${formatPercent(opp.gross_edge_percent)}</span>`;
      }
      return net;
    }

    function formatKellyCell(kellyData) {
      if (!kellyData) return '';
      const stake = kellyData.recommended || 0;
      const frac = kellyData.fractionPercent || 0;
      const rollText = t('kelly_roll', { percent: frac.toFixed(2) });
      return `<div class="kelly-cell">${formatCurrency(stake)}<span class="mono">${rollText}</span></div>`;
    }

    function formatPlusMarket(opp) {
      if (!opp) return '';
      if ((opp.market === 'spreads' || opp.market === 'totals') && opp.market_point !== undefined && opp.market_point !== null) {
        const label = translateMarketLabel(opp.market || '');
        return `${label} (${formatLine(opp.market_point)})`;
      }
      return translateMarketLabel(opp.market || '');
    }

    function formatPlusBet(opp) {
      if (!opp?.bet) return '';
      const exchangeBadge = opp.bet.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const book = opp.bet.soft_book ? ` @ ${opp.bet.soft_book}` : '';
      const point = opp.bet.point !== undefined && opp.bet.point !== null ? ` (${formatLine(opp.bet.point)})` : '';
      return `<span class="outcome">${exchangeBadge}<strong>${opp.bet.outcome || ''}${point}</strong><span>${book}</span></span>`;
    }

    function updateOddsToggle() {
      if (!oddsToggle) return;
      oddsToggle.querySelectorAll('span').forEach((span) => {
        const format = span.dataset.format;
        span.classList.toggle('active', format === oddsFormat);
      });
    }

    function formatOddsDisplay(value) {
      if (!value && value !== 0) return '-';
      if (oddsFormat === 'american') {
        const american = decimalToAmerican(value);
        return american > 0 ? `+${american}` : `${american}`;
      }
      return Number(value).toFixed(2);
    }

    function decimalToAmerican(decimal) {
      if (!decimal || decimal <= 1) return 0;
      if (decimal >= 2) {
        return Math.round((decimal - 1) * 100);
      }
      return Math.round(-100 / (decimal - 1));
    }

    function formatOutcome(item) {
      if (!item) return '';
      const point = item.point !== undefined && item.point !== null ? ` (${item.point})` : '';
      const stake = item.stake !== undefined ? formatCurrency(item.stake) : '';
      const book = item.bookmaker ? ` @ ${item.bookmaker}` : '';
      const exchangeBadge = item.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const effectiveNote =
        item.is_exchange && item.effective_price && item.effective_price !== item.price
          ? `<span class="mono net-note">${t('net_at', { odds: formatOddsDisplay(item.effective_price) })}</span>`
          : '';
      return `<span class="outcome">${exchangeBadge}<strong>${item.outcome || ''}${point}</strong><span>${stake}${book}</span><span class="mono">@ ${formatOddsDisplay(item.price)}</span>${effectiveNote}</span>`;
    }

    function formatMarket(opp) {
      const marketLabel = translateMarketLabel(opp.market || '');
      if (opp.market === 'spreads' || opp.market === 'totals') {
        const point = opp.best_odds?.[0]?.point ?? opp.point;
        if (point !== undefined && point !== null) {
          return `${marketLabel} (${point})`;
        }
      }
      return marketLabel;
    }

    function formatPrice(value) {
      if (!value && value !== 0) return '';
      return Number(value).toFixed(2);
    }

    function calculateStakes(opp, totalStake, useEffectivePrices = true) {
      const odds = (opp.best_odds || []).slice(0, 2);
      if (!totalStake || totalStake <= 0 || odds.length < 2) return null;
      const inverses = odds.map((o) => {
        if (!o) return 0;
        const price = useEffectivePrices
          ? Number(o.effective_price ?? o.price)
          : Number(o.price);
        return price > 0 ? 1 / price : 0;
      });
      const sumInv = inverses.reduce((a, b) => a + b, 0);
      if (sumInv <= 0) return null;
      const breakdown = odds.map((o, idx) => {
        if (!o || !o.price) return null;
        const fraction = inverses[idx] / sumInv;
        const stake = Number((totalStake * fraction).toFixed(2));
        const displayPrice = Number(o.price);
        const effectivePrice = Number(o.effective_price ?? o.price);
        const priceUsed = useEffectivePrices ? effectivePrice : displayPrice;
        if (!priceUsed || priceUsed <= 0) return null;
        const payout = Number((stake * priceUsed).toFixed(2));
        return {
          outcome: o.outcome,
          bookmaker: o.bookmaker,
          price: displayPrice,
          effective_price: effectivePrice,
          point: o.point,
          stake,
          payout,
          fraction,
          is_exchange: Boolean(o.is_exchange),
        };
      });
      if (breakdown.includes(null)) return null;
      const minPayout = Math.min(...breakdown.map((b) => b.payout));
      const guaranteed_profit = Number((minPayout - totalStake).toFixed(2));
      const roi_percent = totalStake ? (guaranteed_profit / totalStake) * 100 : 0;
      return { breakdown, guaranteed_profit, roi_percent };
    }

    function formatCurrency(value) {
      return currencyFormatter.format(value || 0);
    }

    function formatProfit(value) {
      const formatted = formatCurrency(Math.abs(value || 0));
      return `${value >= 0 ? '+' : '-'}${formatted}`;
    }

    function renderPartialWarning(data) {
      if (data && data.partial && Array.isArray(data.sport_errors) && data.sport_errors.length) {
        const details = data.sport_errors
          .map((err) => `${err.sport || err.sport_key || t('unknown')} (${err.error || t('unknown_error')})`)
          .join(', ');
        partialWarning.innerHTML = t('partial_results', { details });
        partialWarning.classList.remove('hidden');
      } else {
        partialWarning.classList.add('hidden');
        partialWarning.textContent = '';
      }
    }

    function formatCommissionPercent(rate) {
      if (typeof rate !== 'number') return `${defaultCommissionPercent.toFixed(1)}%`;
      const percent = (rate * 100).toFixed(2);
      return `${percent.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1')}%`;
    }

    function formatExchangeCell(opp) {
      if (!opp || !opp.has_exchange) return `<span class="exchange-flag none">${t('no')}</span>`;
      const names = Array.isArray(opp.exchange_books) && opp.exchange_books.length
        ? opp.exchange_books.join(', ')
        : t('exchange');
      const commissionText = formatCommissionPercent(lastCommissionRate);
      return `<span class="exchange-flag">${names}<span class="exchange-note">${commissionText}</span></span>`;
    }

    function setActiveTab(tab) {
      activeTab = tab;
      tabs.forEach((btn) => btn.classList.toggle('active', btn.dataset.tab === tab));
      arbitragePanel.classList.toggle('hidden', tab !== 'arbitrage');
      middlesPanel.classList.toggle('hidden', tab !== 'middles');
      plusEvPanel.classList.toggle('hidden', tab !== 'plus-ev');
      middlesConfig.classList.toggle('hidden', tab !== 'middles');
      plusEvConfig.classList.toggle('hidden', tab !== 'plus-ev');
      if (tab === 'arbitrage') {
        renderArbitrage();
      } else if (tab === 'middles') {
        renderMiddles();
      } else {
        renderPlusEv();
      }
    }

    function formatGapCell(opp) {
      const integers = opp.gap?.middle_integers || [];
      const keyFlag = opp.gap?.includes_key_number ? ' ğŸˆ' : '';
      const points =
        typeof opp.gap?.points === 'number' ? t('gap_points', { points: opp.gap.points.toFixed(1) }) : '';
      let range = '';
      if (integers.length) {
        range = integers.length === 1 ? `${integers[0]}` : `${integers[0]}-${integers[integers.length - 1]}`;
      }
      const pieces = [range, points].filter(Boolean);
      return `${pieces.join(t('gap_separator'))}${keyFlag}`;
    }

    function formatMiddleSide(side, stakeValue) {
      if (!side) return '';
      const line = side.line !== undefined && side.line !== null ? formatLine(side.line) : '';
      const book = side.bookmaker ? ` @ ${side.bookmaker}` : '';
      const odds = side.effective_price ? formatOddsDisplay(side.effective_price) : formatOddsDisplay(side.price);
      const stake = stakeValue ? t('stake_label', { stake: formatCurrency(stakeValue) }) : '';
      const exchangeBadge = side.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const oddsText = t('odds_label', { odds });
      return `<span class="outcome">${exchangeBadge}<strong>${side.team || ''} ${line}</strong><span>${oddsText}${book}</span><span>${stake}</span></span>`;
    }

    function formatLine(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      const num = Number(value);
      const sign = num > 0 ? '+' : '';
      return `${sign}${num.toFixed(1)}`;
    }

    function roiBandClass(roi) {
      if (roi >= 2) return 'band-hot';
      if (roi >= 1) return 'band-warm';
      return 'band-cool';
    }

    function renderBars(container, data, type) {
      if (!data || Object.keys(data).length === 0) {
        container.innerHTML = `<p class="muted">${t('no_data')}</p>`;
        return;
      }
      const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
      const max = entries[0][1] || 1;
      container.innerHTML = entries
        .map(([label, value]) => {
          const width = Math.max((value / max) * 100, 8);
          const bandClass = type === 'roi' ? roiBandLabelClass(label) : '';
          const displayLabel = type === 'sport' ? translateSportLabel(label) : label;
          return `
            <div class="bar-row">
              <span>${displayLabel}</span>
              <div class="bar-track">
                <div class="bar-fill ${bandClass}" style="width: ${width}%"></div>
              </div>
              <span class="bar-value">${value}</span>
            </div>`;
        })
        .join('');
    }

    function roiBandLabelClass(label) {
      if (label.includes('10')) return 'band-hot';
      if (label.includes('5')) return 'band-warm';
      return 'band-cool';
    }

    function formatPercent(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '-';
      return `${Number(value).toFixed(2)}%`;
    }

    function formatRoiBadge(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      return `<span class="roi-badge secondary">${formatPercent(value)}</span>`;
    }

    function evBandClass(evPercent) {
      if (evPercent >= 10) return 'ev-hot';
      if (evPercent >= 5) return 'ev-warm';
      if (evPercent >= 1) return 'ev-cool';
      if (evPercent < 0) return 'ev-negative';
      return '';
    }

    function buildMiddleStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          positive_count: 0,
          average_ev_percent: 0,
          best_ev_percent: 0,
          best_event: '',
          by_sport: {},
          key_numbers: {},
        };
      }
      let positive = 0;
      let evSum = 0;
      let best = list[0];
      const bySport = {};
      const keyNumbers = {};
      list.forEach((opp) => {
        const ev = Number(opp.ev_percent) || 0;
        if (ev > 0) positive += 1;
        evSum += ev;
        if (!best || ev > (best.ev_percent || 0)) {
          best = opp;
        }
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        (opp.gap?.key_numbers_crossed || []).forEach((num) => {
          const key = String(num);
          keyNumbers[key] = (keyNumbers[key] || 0) + 1;
        });
      });
      return {
        count,
        positive_count: positive,
        average_ev_percent: evSum / count,
        best_ev_percent: best?.ev_percent || 0,
        best_event: best?.event || '',
        by_sport: bySport,
        key_numbers: keyNumbers,
      };
    }

    function buildPlusEvStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          average_edge_percent: 0,
          best_edge_percent: 0,
          best_event: '',
          total_ev_per_100: 0,
          by_sport: {},
          by_edge_band: {},
        };
      }
      let edgeSum = 0;
      let best = list[0];
      let totalEv = 0;
      const bySport = {};
      const byEdge = {};
      list.forEach((opp) => {
        const edge = Number(opp.edge_percent) || 0;
        edgeSum += edge;
        totalEv += Number(opp.ev_per_100) || 0;
        if (!best || edge > (best.edge_percent || 0)) best = opp;
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        const bandLabel = edge >= 10 ? '10%+' : edge >= 5 ? '5-10%' : edge >= 3 ? '3-5%' : '1-3%';
        byEdge[bandLabel] = (byEdge[bandLabel] || 0) + 1;
      });
      return {
        count,
        average_edge_percent: edgeSum / count,
        best_edge_percent: best?.edge_percent || 0,
        best_event: best?.event || '',
        total_ev_per_100: totalEv,
        by_sport: bySport,
        by_edge_band: byEdge,
      };
    }
  </script>
</body>
</html>
