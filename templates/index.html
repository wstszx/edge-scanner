<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <title>Edge Scanner</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <header class="app-header">
    <div>
      <h1>Edge Scanner</h1>
      <p>Arbitrage ‚Ä¢ Middles</p>
    </div>
    <button class="icon-btn" id="theme-toggle" title="Toggle theme">üåô</button>
  </header>

  <main>
    <section class="card config-card">
      <form id="scan-form">
        <div class="config-grid">
          <div class="field">
            <label class="field-label">API Key</label>
            <div class="input-wrap">
              <input type="password" id="api-key" placeholder="sk_xxx" required />
              <button type="button" id="toggle-key" class="icon-btn" aria-label="Show API key">üëÅ</button>
            </div>
          </div>
          <div class="field">
            <label class="field-label">Total Stake ($)</label>
            <input type="number" id="stake-input" min="1" step="1" value="100" />
            <p class="helper">Stake splits proportionally across both outcomes.</p>
          </div>
          <div class="field">
            <label class="field-label">Sports</label>
            <div id="sports-list" class="sports-grid">
              {% for sport in default_sports %}
              <label class="checkbox">
                <input type="checkbox" name="sports" value="{{ sport.key }}" checked />
                <span>{{ sport.label }}</span>
              </label>
              {% endfor %}
            </div>
            <label class="checkbox all-toggle">
              <input type="checkbox" id="all-sports" />
              <span>Scan all active sports (uses more API credits)</span>
            </label>
            <p class="helper">Each selected sport consumes one API request.</p>
          </div>
          <div class="field">
            <label class="field-label">Regions</label>
            <div id="regions-list" class="regions-grid">
              {% for region in region_options %}
              <label class="checkbox">
                <input
                  type="checkbox"
                  name="regions"
                  value="{{ region.key }}"
                  {% if region.default %}checked{% endif %}
                />
                <span>{{ region.label }}</span>
              </label>
              {% endfor %}
            </div>
            <p class="helper">Select at least one region to include in the scan.</p>
          </div>
          <div class="field commission-field">
            <div class="commission-box">
              <div>
                <label class="field-label">Exchange Commission (%)</label>
                <p class="helper">
                  Applied to Betfair, Matchbook, Sportsbet Exchange, and other exchanges.
                </p>
              </div>
              <div class="input-wrap">
                <input
                  type="number"
                  id="commission-input"
                  min="0"
                  max="15"
                  step="0.5"
                  value="{{ default_commission_percent }}"
                />
              </div>
              <p class="helper">
                Exchanges take a fee on winnings. Net ROI reflects this commission.
              </p>
            </div>
          </div>
        </div>
        <div class="actions">
          <button type="submit" id="scan-btn">Scan Now</button>
          <div id="status" class="status"></div>
        </div>
      </form>
    </section>

    <nav class="tabs">
      <button type="button" class="tab-btn active" data-tab="arbitrage">Arbitrage</button>
      <button type="button" class="tab-btn" data-tab="middles">Middles</button>
    </nav>

    <section class="card middle-config hidden" id="middles-config">
      <div class="middle-config-grid">
        <div class="field">
          <label class="field-label">Minimum Gap (points)</label>
          <input type="number" id="min-gap-input" min="0" max="10" step="0.5" value="1.5" />
          <p class="helper">Only show middles with at least this many points between the lines.</p>
        </div>
        <div class="field toggle-field">
          <label class="field-label">Filters</label>
          <label class="checkbox">
            <input type="checkbox" id="positive-ev-toggle" checked />
            <span>Show only positive EV middles</span>
          </label>
        </div>
        <div class="field">
          <label class="field-label">Sort By</label>
          <select id="middle-sort">
            <option value="ev">Estimated EV</option>
            <option value="probability">Probability</option>
            <option value="gap">Gap size</option>
            <option value="time">Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section id="arbitrage-panel">
    <section class="stats-row">
      <div class="stat-card" id="stat-opps">
        <span class="stat-label">Opportunities</span>
        <span class="stat-value">0</span>
      </div>
      <div class="stat-card" id="stat-events">
        <span class="stat-label">Events Scanned</span>
        <span class="stat-value">0</span>
      </div>
      <div class="stat-card" id="stat-sports">
        <span class="stat-label">Sports</span>
        <span class="stat-value">0</span>
      </div>
      <div class="stat-card" id="stat-calls">
        <span class="stat-label">API Calls</span>
        <span class="stat-value">0</span>
      </div>
    </section>

    <section id="summary-info" class="card summary-info hidden"></section>
    <div id="partial-warning" class="alert warning hidden"></div>

    <section class="summary-grid">
      <div class="card summary-card" id="roi-card">
        <div class="card-head">
          <h3>By ROI Band</h3>
        </div>
        <div id="roi-bars" class="bar-list"></div>
      </div>
      <div class="card summary-card" id="sport-card">
        <div class="card-head">
          <h3>By Sport</h3>
        </div>
        <div id="sport-bars" class="bar-list"></div>
      </div>
    </section>

    <section class="card results-card">
      <div class="card-head">
        <h3>Opportunities</h3>
        <div class="table-meta">
          <span id="table-count">0 results</span>
          <span class="muted">Sorted by ROI</span>
        </div>
      </div>
      <table id="results-table">
        <thead>
          <tr>
            <th>Net ROI</th>
            <th>Gross ROI</th>
            <th>Profit</th>
            <th>Exchange</th>
            <th>Sport</th>
            <th>Event</th>
            <th>Time</th>
            <th>Market</th>
            <th>Outcome 1</th>
            <th>Outcome 2</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="table-empty" class="empty">No arbitrage opportunities yet.</div>
    </section>
    </section>

    <section id="middles-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label">Middles Found</span>
          <span class="stat-value" id="middle-stat-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">+EV Middles</span>
          <span class="stat-value" id="middle-stat-positive">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Avg EV</span>
          <span class="stat-value" id="middle-stat-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label">Best EV</span>
          <span class="stat-value" id="middle-stat-best">0%</span>
        </div>
      </section>

      <section id="middles-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3>By Sport</h3>
          </div>
          <div id="middles-sport-bars" class="bar-list"></div>
        </div>
      <div class="card summary-card" id="middles-key-card">
        <div class="card-head">
          <h3>Key Numbers</h3>
        </div>
        <div id="middles-key-bars" class="bar-list"></div>
      </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3>Middles</h3>
          <div class="table-meta">
            <span id="middles-table-count">0 results</span>
            <span class="muted">Sorted by EV</span>
          </div>
        </div>
        <table id="middles-table">
          <thead>
            <tr>
              <th>EV</th>
              <th>Prob</th>
              <th>Gap</th>
              <th>Sport</th>
              <th>Event</th>
              <th>Time</th>
              <th>Market</th>
              <th>Side A</th>
              <th>Side B</th>
              <th>Middle</th>
              <th>Win Both</th>
              <th>Miss</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div id="middles-empty" class="empty">No middle opportunities meet your filters.</div>
      </section>

      <section class="card middle-caveat">
        <p><strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 & 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.</p>
      </section>
    </section>
  </main>

      <script>
    const form = document.getElementById('scan-form');
    const apiKeyInput = document.getElementById('api-key');
    const stakeInput = document.getElementById('stake-input');
    const scanBtn = document.getElementById('scan-btn');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary-info');
    const resultsBody = document.querySelector('#results-table tbody');
    const emptyState = document.getElementById('table-empty');
    const allSportsToggle = document.getElementById('all-sports');
    const summaryROI = document.getElementById('roi-bars');
    const summarySport = document.getElementById('sport-bars');
    const tableCount = document.getElementById('table-count');
    const statOpps = document.querySelector('#stat-opps .stat-value');
    const statEvents = document.querySelector('#stat-events .stat-value');
    const statSports = document.querySelector('#stat-sports .stat-value');
    const statCalls = document.querySelector('#stat-calls .stat-value');
    const themeToggle = document.getElementById('theme-toggle');
    const toggleKeyBtn = document.getElementById('toggle-key');
    const currencyFormatter = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });
    const partialWarning = document.getElementById('partial-warning');
    const commissionInput = document.getElementById('commission-input');
    const tabs = document.querySelectorAll('.tab-btn');
    const arbitragePanel = document.getElementById('arbitrage-panel');
    const middlesPanel = document.getElementById('middles-panel');
    const middlesConfig = document.getElementById('middles-config');
    const minGapInput = document.getElementById('min-gap-input');
    const positiveEvToggle = document.getElementById('positive-ev-toggle');
    const middleSortSelect = document.getElementById('middle-sort');
    const middleStatCount = document.getElementById('middle-stat-count');
    const middleStatPositive = document.getElementById('middle-stat-positive');
    const middleStatAvg = document.getElementById('middle-stat-avg');
    const middleStatBest = document.getElementById('middle-stat-best');
    const middleSummaryInfo = document.getElementById('middles-summary-info');
    const middleSportBars = document.getElementById('middles-sport-bars');
    const middleKeyBars = document.getElementById('middles-key-bars');
    const middleKeyCard = document.getElementById('middles-key-card');
    const middlesTableBody = document.querySelector('#middles-table tbody');
    const middlesTableCount = document.getElementById('middles-table-count');
    const middlesEmpty = document.getElementById('middles-empty');
    const defaultCommissionPercent = parseFloat(commissionInput.value) || 5;
    let lastCommissionRate = defaultCommissionPercent / 100;
    let lastScanData = null;
    let activeTab = 'arbitrage';

    document.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('arb-theme');
      if (savedTheme) {
        document.documentElement.dataset.theme = savedTheme;
        themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
      }
    });

    toggleKeyBtn.addEventListener('click', () => {
      if (apiKeyInput.type === 'password') {
        apiKeyInput.type = 'text';
        toggleKeyBtn.textContent = 'üôà';
      } else {
        apiKeyInput.type = 'password';
        toggleKeyBtn.textContent = 'üëÅ';
      }
    });

    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.dataset.theme || 'light';
      const next = current === 'light' ? 'dark' : 'light';
      document.documentElement.dataset.theme = next;
      localStorage.setItem('arb-theme', next);
      themeToggle.textContent = next === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    });

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        const target = tab.dataset.tab;
        if (target && target !== activeTab) {
          setActiveTab(target);
        }
      });
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        showStatus('Please enter your API key.', 'error');
        return;
      }
      const sports = Array.from(form.querySelectorAll('input[name="sports"]:checked')).map((el) => el.value);
      const regions = Array.from(form.querySelectorAll('input[name="regions"]:checked')).map((el) => el.value);
      if (regions.length === 0) {
        showStatus('Select at least one region.', 'error');
        return;
      }
      const stakeValue = parseFloat(stakeInput.value) || 100;
      const commissionValue = Number.isFinite(parseFloat(commissionInput.value))
        ? parseFloat(commissionInput.value)
        : defaultCommissionPercent;
      await runScan({
        apiKey,
        sports,
        regions,
        commission: commissionValue,
        allSports: allSportsToggle.checked,
        stake: stakeValue,
      });
    });

    stakeInput.addEventListener('input', () => {
      if (lastScanData) {
        renderArbitrage();
        renderMiddles();
      }
    });

    minGapInput.addEventListener('input', () => renderMiddles());
    positiveEvToggle.addEventListener('change', () => renderMiddles());
    middleSortSelect.addEventListener('change', () => renderMiddles());

    async function runScan(payload) {
      setScanning(true);
      try {
        const response = await fetch('/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: payload.apiKey,
            sports: payload.sports,
            allSports: payload.allSports,
            stake: payload.stake,
            regions: payload.regions,
            commission: payload.commission,
          }),
        });
        const data = await response.json();
        if (!data.success) {
          throw new Error(data.error || 'Scan failed');
        }
        if (data?.middles?.defaults) {
          const defaults = data.middles.defaults;
          if (defaults.min_gap !== undefined) minGapInput.value = defaults.min_gap;
          if (defaults.positive_only !== undefined) positiveEvToggle.checked = defaults.positive_only;
          if (defaults.sort) middleSortSelect.value = defaults.sort;
        }
        renderScanData(data);
        showStatus(`Scan complete at ${new Date(data.scan_time).toLocaleTimeString()}`, 'success');
      } catch (err) {
        showStatus(err.message || 'Scan failed', 'error');
        renderScanData(null);
      } finally {
        setScanning(false);
      }
    }

    function setScanning(isScanning) {
      scanBtn.disabled = isScanning;
      scanBtn.textContent = isScanning ? 'Scanning‚Ä¶' : 'Scan Now';
      statusEl.textContent = isScanning ? 'Scanning, please wait‚Ä¶' : '';
      statusEl.className = 'status';
    }

    function showStatus(message, type) {
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
    }

    function renderScanData(payload) {
      lastScanData = payload;
      if (payload && typeof payload.commission_rate === 'number') {
        lastCommissionRate = payload.commission_rate;
      }
      renderArbitrage();
      renderMiddles();
      renderPartialWarning(payload);
    }

    function renderArbitrage() {
      const arbData = lastScanData?.arbitrage;
      const opportunities = arbData?.opportunities || [];
      const stakeValue = parseFloat(stakeInput.value) || 0;
      resultsBody.innerHTML = '';
      tableCount.textContent = `${opportunities.length} results`;
      if (!opportunities.length) {
        emptyState.classList.remove('hidden');
      } else {
        emptyState.classList.add('hidden');
        let runningProfit = 0;
        opportunities.forEach((opp) => {
          const row = document.createElement('tr');
          const calcNet = calculateStakes(opp, stakeValue, true);
          const netRoi = calcNet?.roi_percent ?? opp.roi_percent;
          row.classList.add(roiBandClass(netRoi));
          const commence = opp.commence_time ? new Date(opp.commence_time).toLocaleString() : 'TBD';
          const calcGross = opp.has_exchange ? calculateStakes(opp, stakeValue, false) : null;
          const grossRoi = opp.has_exchange ? calcGross?.roi_percent ?? opp.gross_roi_percent : null;
          const netNegative = typeof netRoi === 'number' && netRoi < 0;
          if (netNegative) row.classList.add('roi-negative');
          if (opp.has_exchange) row.classList.add('has-exchange');
          const breakdown = calcNet?.breakdown || [];
          const profitValue = calcNet?.guaranteed_profit ?? 0;
          runningProfit += profitValue || 0;
          const profitClass = profitValue > 0 ? 'gain' : profitValue < 0 ? 'loss' : '';
          const grossCell = opp.has_exchange ? formatRoiBadge(grossRoi) : '';
          row.innerHTML = `
            <td><span class="roi-badge">${formatPercent(netRoi)}</span>${netNegative ? '<span class="roi-warning" title="Net ROI is negative after commission.">‚ö†</span>' : ''}</td>
            <td>${grossCell}</td>
            <td class="profit-cell ${profitClass}">${calcNet ? formatProfit(profitValue) : '-'}</td>
            <td>${formatExchangeCell(opp)}</td>
            <td>${opp.sport_display || opp.sport || ''}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${formatMarket(opp)}</td>
            <td>${formatOutcome(breakdown[0])}</td>
            <td>${formatOutcome(breakdown[1])}</td>`;
          resultsBody.appendChild(row);
        });
        tableCount.textContent = `${opportunities.length} results ‚Ä¢ ${formatCurrency(runningProfit)} profit`;
      }
      const summary = arbData?.summary;
      if (summary) {
        statOpps.textContent = arbData.opportunities_count || opportunities.length;
        statEvents.textContent = summary.events_scanned;
        statSports.textContent = summary.sports_scanned;
        statCalls.textContent = summary.api_calls_used;
        const totalProfit = opportunities.reduce((sum, opp) => {
          const calc = calculateStakes(opp, stakeValue, true);
          return sum + (calc?.guaranteed_profit || 0);
        }, 0);
        renderBars(summaryROI, summary.by_roi_band, 'roi');
        renderBars(summarySport, summary.by_sport, 'sport');
        const totalStaked = stakeValue > 0 ? stakeValue * opportunities.length : 0;
        const commissionPercent = formatCommissionPercent(lastCommissionRate);
        const regionsLabel = Array.isArray(lastScanData?.regions) && lastScanData.regions.length
          ? lastScanData.regions.join(', ').toUpperCase()
          : '';
        summaryEl.classList.remove('hidden');
        summaryEl.innerHTML = `
          <h3>Summary</h3>
          <p>Found <strong>${arbData.opportunities_count || opportunities.length}</strong> opportunities across <strong>${summary.events_scanned}</strong> events in <strong>${summary.sports_scanned}</strong> sports.</p>
          <p>Total potential profit: <strong>${formatCurrency(totalProfit)}</strong>${totalStaked ? ` on ${formatCurrency(totalStaked)} staked` : ''}</p>
          <p>API calls used: ${summary.api_calls_used}${regionsLabel ? ` ‚Ä¢ Regions: ${regionsLabel}` : ''}</p>
          <p>Exchange commission applied: ${commissionPercent}.</p>
          <p class="helper">ROI = return on total stake. 2% ROI means $2 profit on a $100 stake.</p>
        `;
      } else {
        statOpps.textContent = statEvents.textContent = statSports.textContent = statCalls.textContent = '0';
        summaryROI.innerHTML = '';
        summarySport.innerHTML = '';
        summaryEl.classList.add('hidden');
        summaryEl.innerHTML = '';
      }
    }

    function renderMiddles() {
      const data = lastScanData?.middles;
      const opportunities = data?.opportunities || [];
      const minGap = parseFloat(minGapInput.value) || 0;
      const positiveOnly = positiveEvToggle.checked;
      const sortKey = middleSortSelect.value || 'ev';
      const scannedStake = data?.stake_amount || 0;
      const desiredStake = parseFloat(stakeInput.value) || scannedStake || 100;
      const stakeRatio = scannedStake > 0 ? desiredStake / scannedStake : 1;
      const filtered = opportunities.filter((opp) => {
        const gapPoints = opp.gap?.points ?? 0;
        if (gapPoints < minGap) return false;
        if (positiveOnly && opp.ev_percent <= 0) return false;
        return true;
      });
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'probability':
            return (b.middle_probability || 0) - (a.middle_probability || 0);
          case 'gap':
            return (b.gap?.integer_count || 0) - (a.gap?.integer_count || 0);
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'ev':
          default:
            return (b.ev_percent || 0) - (a.ev_percent || 0);
        }
      });
      const stats = buildMiddleStats(filtered);
      middleStatCount.textContent = stats.count;
      middleStatPositive.textContent = stats.positive_count;
      middleStatAvg.textContent = formatPercent(stats.average_ev_percent);
      middleStatBest.textContent = formatPercent(stats.best_ev_percent);
      if (stats.count > 0) {
        middleSummaryInfo.classList.remove('hidden');
        const bestText = stats.best_event ? ` ‚Ä¢ Best: ${stats.best_event}` : '';
        middleSummaryInfo.innerHTML = `
          <h3>Summary</h3>
          <p>Middles matching filters: <strong>${stats.count}</strong>, with <strong>${stats.positive_count}</strong> positive EV.</p>
          <p>Average EV: <strong>${formatPercent(stats.average_ev_percent)}</strong>${bestText}</p>
        `;
        renderBars(middleSportBars, stats.by_sport, 'sport');
        if (Object.keys(stats.key_numbers).length) {
          middleKeyCard.classList.remove('hidden');
          renderBars(middleKeyBars, stats.key_numbers, 'sport');
        } else {
          middleKeyCard.classList.add('hidden');
          middleKeyBars.innerHTML = '<p class="muted">Spreads only</p>';
        }
      } else {
        middleSummaryInfo.classList.add('hidden');
        middleSummaryInfo.innerHTML = '';
        middleSportBars.innerHTML = '';
        middleKeyCard.classList.add('hidden');
        middleKeyBars.innerHTML = '<p class="muted">Spreads only</p>';
      }

      middlesTableBody.innerHTML = '';
      middlesTableCount.textContent = `${filtered.length} results`;
      if (!filtered.length) {
        middlesEmpty.classList.remove('hidden');
      } else {
        middlesEmpty.classList.add('hidden');
        filtered.forEach((opp) => {
          const row = document.createElement('tr');
          const evClass = evBandClass(opp.ev_percent);
          if (evClass) row.classList.add(evClass);
          if (opp.has_exchange) row.classList.add('has-exchange');
          const commence = opp.commence_time ? new Date(opp.commence_time).toLocaleString() : 'TBD';
          const stakeA = (opp.stakes?.side_a?.stake || 0) * stakeRatio;
          const stakeB = (opp.stakes?.side_b?.stake || 0) * stakeRatio;
          const winBoth = (opp.outcomes?.win_both_profit || 0) * stakeRatio;
          const miss = (opp.outcomes?.typical_miss_profit || 0) * stakeRatio;
          row.innerHTML = `
            <td>${formatPercent(opp.ev_percent)}${opp.has_exchange && typeof opp.gross_ev_percent === 'number' ? `<span class="ev-gross">Gross ${formatPercent(opp.gross_ev_percent)}</span>` : ''}</td>
            <td>${formatPercent(opp.probability_percent)}</td>
            <td>${formatGapCell(opp)}</td>
            <td>${opp.sport_display || opp.sport || ''}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${opp.market || ''}</td>
            <td>${formatMiddleSide(opp.side_a, stakeA)}</td>
            <td>${formatMiddleSide(opp.side_b, stakeB)}</td>
            <td>${opp.middle_zone || ''}</td>
            <td class="profit-cell">${formatProfit(winBoth)}</td>
            <td class="profit-cell">${formatProfit(miss)}</td>
          `;
          middlesTableBody.appendChild(row);
        });
      }
    }

    function roiBandClass(roi) {
      if (roi >= 2) return 'band-hot';
      if (roi >= 1) return 'band-warm';
      return 'band-cool';
    }

    function renderBars(container, data, type) {
      if (!data || Object.keys(data).length === 0) {
        container.innerHTML = '<p class="muted">No data</p>';
        return;
      }
      const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
      const max = entries[0][1] || 1;
      container.innerHTML = entries
        .map(([label, value]) => {
          const width = Math.max((value / max) * 100, 8);
          const bandClass = type === 'roi' ? roiBandLabelClass(label) : '';
          return `
            <div class="bar-row">
              <span>${label}</span>
              <div class="bar-track">
                <div class="bar-fill ${bandClass}" style="width: ${width}%"></div>
              </div>
              <span class="bar-value">${value}</span>
            </div>`;
        })
        .join('');
    }

    function roiBandLabelClass(label) {
      if (label.includes('2')) return 'band-hot';
      if (label.includes('1-2')) return 'band-warm';
      return 'band-cool';
    }

    function formatOutcome(item) {
      if (!item) return '';
      const point = item.point !== undefined && item.point !== null ? ` (${item.point})` : '';
      const stake = item.stake !== undefined ? formatCurrency(item.stake) : '';
      const book = item.bookmaker ? ` @ ${item.bookmaker}` : '';
      const exchangeBadge = item.is_exchange ? '<span class="exchange-badge">Exchange</span>' : '';
      const effectiveNote =
        item.is_exchange && item.effective_price && item.effective_price !== item.price
          ? `<span class="mono net-note">Net @ ${formatPrice(item.effective_price)}</span>`
          : '';
      return `<span class="outcome">${exchangeBadge}<strong>${item.outcome || ''}${point}</strong><span>${stake}${book}</span><span class="mono">@ ${formatPrice(item.price)}</span>${effectiveNote}</span>`;
    }

    function formatMarket(opp) {
      if (opp.market === 'spreads' || opp.market === 'totals') {
        const point = opp.best_odds?.[0]?.point ?? opp.point;
        if (point !== undefined && point !== null) {
          return `${opp.market} (${point})`;
        }
      }
      return opp.market || '';
    }

    function formatPrice(value) {
      if (!value && value !== 0) return '';
      return Number(value).toFixed(2);
    }

    function calculateStakes(opp, totalStake, useEffectivePrices = true) {
      const odds = (opp.best_odds || []).slice(0, 2);
      if (!totalStake || totalStake <= 0 || odds.length < 2) return null;
      const inverses = odds.map((o) => {
        if (!o) return 0;
        const price = useEffectivePrices
          ? Number(o.effective_price ?? o.price)
          : Number(o.price);
        return price > 0 ? 1 / price : 0;
      });
      const sumInv = inverses.reduce((a, b) => a + b, 0);
      if (sumInv <= 0) return null;
      const breakdown = odds.map((o, idx) => {
        if (!o || !o.price) return null;
        const fraction = inverses[idx] / sumInv;
        const stake = Number((totalStake * fraction).toFixed(2));
        const displayPrice = Number(o.price);
        const effectivePrice = Number(o.effective_price ?? o.price);
        const priceUsed = useEffectivePrices ? effectivePrice : displayPrice;
        if (!priceUsed || priceUsed <= 0) return null;
        const payout = Number((stake * priceUsed).toFixed(2));
        return {
          outcome: o.outcome,
          bookmaker: o.bookmaker,
          price: displayPrice,
          effective_price: effectivePrice,
          point: o.point,
          stake,
          payout,
          fraction,
          is_exchange: Boolean(o.is_exchange),
        };
      });
      if (breakdown.includes(null)) return null;
      const minPayout = Math.min(...breakdown.map((b) => b.payout));
      const guaranteed_profit = Number((minPayout - totalStake).toFixed(2));
      const roi_percent = totalStake ? (guaranteed_profit / totalStake) * 100 : 0;
      return { breakdown, guaranteed_profit, roi_percent };
    }

    function formatCurrency(value) {
      return currencyFormatter.format(value || 0);
    }

    function formatProfit(value) {
      const formatted = formatCurrency(Math.abs(value || 0));
      return `${value >= 0 ? '+' : '-'}${formatted}`;
    }

    function renderPartialWarning(data) {
      if (data && data.partial && Array.isArray(data.sport_errors) && data.sport_errors.length) {
        const details = data.sport_errors
          .map((err) => `${err.sport || err.sport_key || 'Unknown'} (${err.error || 'Unknown error'})`)
          .join(', ');
        partialWarning.innerHTML = `<strong>Partial results:</strong> Failed to fetch odds for ${details}.`;
        partialWarning.classList.remove('hidden');
      } else {
        partialWarning.classList.add('hidden');
        partialWarning.textContent = '';
      }
    }

    function formatCommissionPercent(rate) {
      if (typeof rate !== 'number') return `${defaultCommissionPercent.toFixed(1)}%`;
      const percent = (rate * 100).toFixed(2);
      return `${percent.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1')}%`;
    }

    function formatExchangeCell(opp) {
      if (!opp || !opp.has_exchange) return '<span class="exchange-flag none">No</span>';
      const names = Array.isArray(opp.exchange_books) && opp.exchange_books.length
        ? opp.exchange_books.join(', ')
        : 'Exchange';
      const commissionText = formatCommissionPercent(lastCommissionRate);
      return `<span class="exchange-flag">${names}<span class="exchange-note">${commissionText}</span></span>`;
    }

    function setActiveTab(tab) {
      activeTab = tab;
      tabs.forEach((btn) => btn.classList.toggle('active', btn.dataset.tab === tab));
      arbitragePanel.classList.toggle('hidden', tab !== 'arbitrage');
      middlesPanel.classList.toggle('hidden', tab !== 'middles');
      middlesConfig.classList.toggle('hidden', tab !== 'middles');
      if (tab === 'arbitrage') {
        renderArbitrage();
      } else {
        renderMiddles();
      }
    }

    function formatGapCell(opp) {
      const integers = opp.gap?.middle_integers || [];
      const keyFlag = opp.gap?.includes_key_number ? ' üèà' : '';
      const points = typeof opp.gap?.points === 'number' ? `${opp.gap.points.toFixed(1)} pts` : '';
      let range = '';
      if (integers.length) {
        range = integers.length === 1 ? `${integers[0]}` : `${integers[0]}-${integers[integers.length - 1]}`;
      }
      const pieces = [range, points].filter(Boolean);
      return `${pieces.join(' ¬∑ ')}${keyFlag}`;
    }

    function formatMiddleSide(side, stakeValue) {
      if (!side) return '';
      const line = side.line !== undefined && side.line !== null ? formatLine(side.line) : '';
      const book = side.bookmaker ? ` @ ${side.bookmaker}` : '';
      const odds = side.effective_price ? formatPrice(side.effective_price) : formatPrice(side.price);
      const stake = stakeValue ? `Stake: ${formatCurrency(stakeValue)}` : '';
      const exchangeBadge = side.is_exchange ? '<span class="exchange-badge">Exchange</span>' : '';
      return `<span class="outcome">${exchangeBadge}<strong>${side.team || ''} ${line}</strong><span>Odds: ${odds}${book}</span><span>${stake}</span></span>`;
    }

    function formatLine(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      const num = Number(value);
      const sign = num > 0 ? '+' : '';
      return `${sign}${num.toFixed(1)}`;
    }

    function evBandClass(evPercent) {
      if (evPercent >= 10) return 'ev-hot';
      if (evPercent >= 5) return 'ev-warm';
      if (evPercent >= 1) return 'ev-cool';
      if (evPercent < 0) return 'ev-negative';
      return '';
    }

    function formatPercent(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '-';
      return `${Number(value).toFixed(2)}%`;
    }

    function formatRoiBadge(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      return `<span class="roi-badge secondary">${formatPercent(value)}</span>`;
    }

    function buildMiddleStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          positive_count: 0,
          average_ev_percent: 0,
          best_ev_percent: 0,
          best_event: '',
          by_sport: {},
          key_numbers: {},
        };
      }
      let positive = 0;
      let evSum = 0;
      let best = list[0];
      const bySport = {};
      const keyNumbers = {};
      list.forEach((opp) => {
        const ev = Number(opp.ev_percent) || 0;
        if (ev > 0) positive += 1;
        evSum += ev;
        if (!best || ev > (best.ev_percent || 0)) {
          best = opp;
        }
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        (opp.gap?.key_numbers_crossed || []).forEach((num) => {
          const key = String(num);
          keyNumbers[key] = (keyNumbers[key] || 0) + 1;
        });
      });
      return {
        count,
        positive_count: positive,
        average_ev_percent: evSum / count,
        best_ev_percent: best?.ev_percent || 0,
        best_event: best?.event || '',
        by_sport: bySport,
        key_numbers: keyNumbers,
      };
    }
  </script>


</body>
</html>
