<!doctype html>
<html lang="en" data-theme="{{ default_theme }}">
<head>
  <meta charset="utf-8" />
  <title>Edge Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet" />
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <header class="app-header">
    <div class="brand-block">
      <span class="brand-kicker">EDGE SCANNER</span>
      <h1>Live Market Intelligence</h1>
      <p data-i18n="tagline">Arbitrage / Middles / +EV</p>
    </div>
    <div class="header-controls">
      <div class="odds-format" id="odds-toggle" role="button" tabindex="0">
        <span data-format="decimal" class="active" data-i18n="odds_decimal">Decimal</span>
        <span data-format="american" data-i18n="odds_american">American</span>
      </div>
      <div class="odds-format" id="language-toggle" role="button" tabindex="0" aria-label="Toggle language">
        <span data-lang="en" class="active" data-i18n="lang_en">EN</span>
        <span data-lang="zh" data-i18n="lang_zh">ZH</span>
      </div>
      <div class="odds-format" id="density-toggle" role="button" tabindex="0" aria-label="Toggle density">
        <span data-density="comfort" class="active" data-i18n="density_comfort">Comfort</span>
        <span data-density="compact" data-i18n="density_compact">Compact</span>
      </div>
      <button class="icon-btn" id="theme-toggle" title="Toggle theme">Theme</button>
      <button type="button" id="open-advanced" class="secondary-btn header-settings-btn" data-i18n="advanced_settings" aria-haspopup="dialog" aria-expanded="false" aria-controls="advanced-modal">Advanced settings</button>
      <span id="advanced-summary" class="summary-chip header-summary"></span>
    </div>
  </header>

  <main>
    <div class="layout">
      <aside class="sidebar">
    <section class="card config-card">
      <form id="scan-form">
        <div class="config-grid">
          {% if not has_env_key %}
          <div class="field">
            <label class="field-label" data-i18n="api_key_label">API Key</label>
            <div class="input-wrap">
              <input type="password" id="api-key" placeholder="sk_xxx" required />
              <button type="button" id="toggle-key" class="icon-btn" aria-label="Show API key">Show</button>
            </div>
          </div>
          {% endif %}
          <div class="field">
            <label class="field-label" data-i18n="total_stake_label">Total Stake ($)</label>
            <input type="number" id="stake-input" min="1" step="1" value="{{ default_stake_amount }}" />
            <p class="helper" data-i18n="stake_helper">Used for arbitrage + middles stake splits.</p>
          </div>
        </div>
        <div class="advanced-trigger">
          <button type="button" id="open-advanced-hidden" class="secondary-btn" tabindex="-1" aria-hidden="true">Advanced settings</button>
          <span id="advanced-summary-hidden" class="summary-chip" aria-hidden="true"></span>
        </div>
        <div class="modal hidden" id="advanced-modal" role="dialog" aria-modal="true" aria-labelledby="advanced-title" aria-hidden="true">
          <div class="modal-backdrop" data-close="modal"></div>
          <div class="modal-panel">
            <div class="modal-head">
              <h3 id="advanced-title" data-i18n="advanced_settings">Advanced settings</h3>
            </div>
            <p class="helper" data-i18n="advanced_hint">Less frequently adjusted options live here.</p>
            <div class="advanced-layout">
              <section class="advanced-panel">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="regions_label">Regions</span>
                    <p class="helper" data-i18n="regions_helper">Select at least one region. EU is always included for sharp reference.</p>
                  </div>
                  <div class="panel-actions">
                    <button type="button" class="chip-btn" data-quick-action="select" data-quick-target="regions" data-i18n="select_all">Select all</button>
                    <button type="button" class="chip-btn" data-quick-action="clear" data-quick-target="regions" data-i18n="clear_all">Clear</button>
                  </div>
                </div>
                <div class="panel-body">
                  <div class="regions-grid">
                    {% for region in region_options %}
                    <label class="checkbox">
                      <input type="checkbox" name="regions" value="{{ region.key }}" {% if region.default %}checked{% endif %} />
                      <span data-region-key="{{ region.key }}">{{ region.label }}</span>
                    </label>
                    {% endfor %}
                  </div>
                </div>
              </section>
              <section class="advanced-panel">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="sports_label">Sports</span>
                    <p class="helper" data-i18n="sports_helper">Each selected sport consumes one API request.</p>
                  </div>
                  <div class="panel-actions">
                    <button type="button" class="chip-btn" data-quick-action="select" data-quick-target="sports" data-i18n="select_all">Select all</button>
                    <button type="button" class="chip-btn" data-quick-action="clear" data-quick-target="sports" data-i18n="clear_all">Clear</button>
                  </div>
                </div>
                <div class="panel-body">
                  <div id="sports-list" class="sports-grid">
                    {% for sport in default_sports %}
                    <label class="checkbox">
                      <input type="checkbox" name="sports" value="{{ sport.key }}" checked />
                      <span data-sport-key="{{ sport.key }}">{{ sport.label }}</span>
                    </label>
                    {% endfor %}
                  </div>
                </div>
                <div class="panel-foot">
                  <label class="checkbox all-toggle">
                    <input type="checkbox" id="all-sports" {% if default_all_sports %}checked{% endif %} />
                    <span data-i18n="all_sports_label">Scan all active sports (uses more API credits)</span>
                  </label>
                  <label class="checkbox all-toggle">
                    <input type="checkbox" id="all-markets" {% if default_all_markets %}checked{% endif %} />
                    <span data-i18n="all_markets_label">Scan extended markets (can use more API credits)</span>
                  </label>
                  <p class="helper" data-i18n="all_markets_helper">Attempts to include extra market types and player props for arbitrage/+EV.</p>
                </div>
              </section>
              <section class="advanced-panel">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="bookmakers_label">Bookmakers</span>
                    <p class="helper" data-i18n="bookmakers_helper">Optional: limit results to the selected bookmakers.</p>
                  </div>
                  <div class="panel-actions">
                    <button type="button" class="chip-btn" data-quick-action="select" data-quick-target="bookmakers" data-i18n="select_all">Select all</button>
                    <button type="button" class="chip-btn" data-quick-action="clear" data-quick-target="bookmakers" data-i18n="clear_all">Clear</button>
                  </div>
                </div>
                <div class="panel-body">
                  <div id="bookmakers-list" class="bookmakers-grid">
                    {% for book in bookmaker_options %}
                    <div class="bookmaker-row">
                      <label class="checkbox">
                        <input type="checkbox" name="bookmakers" value="{{ book.key }}" {% if book.key in default_bookmaker_keys %}checked{% endif %} />
                        <span data-bookmaker-key="{{ book.key }}">{{ book.label }}</span>
                      </label>
                      <input
                        type="url"
                        inputmode="url"
                        class="bookmaker-url"
                        data-bookmaker-key="{{ book.key }}"
                        value="{{ bookmaker_links.get(book.key, '') }}"
                        placeholder="https://..."
                      />
                    </div>
                    {% endfor %}
                  </div>
                </div>
                <div class="panel-foot">
                  <p class="helper" data-i18n="bookmaker_links_helper">Customize base URLs used when opening books.</p>
                  <label class="checkbox all-toggle">
                    <input type="checkbox" id="all-bookmakers" {% if not default_bookmaker_keys %}checked{% endif %} />
                    <span data-i18n="all_bookmakers_label">Use all available bookmakers</span>
                  </label>
                </div>
              </section>
              <section class="advanced-panel advanced-panel-wide">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="commission_label">Exchange Commission (%)</span>
                    <p class="helper" data-i18n="commission_helper">Applied to Betfair, Matchbook, Sportsbet Exchange, etc.</p>
                  </div>
                </div>
                <div class="panel-body">
                  <input type="number" id="commission-input" min="0" max="20" step="0.1" value="{{ default_commission_percent }}" />
                  <p class="helper" data-i18n="commission_note">Net ROI/EV already reflects this commission.</p>
                </div>
              </section>
              <section class="advanced-panel advanced-panel-wide">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="notify_label">Notifications</span>
                    <p class="helper" data-i18n="notify_helper">Browser permission is required for popup notifications.</p>
                  </div>
                </div>
                <div class="panel-body">
                  <label class="checkbox">
                    <input type="checkbox" id="notify-sound-toggle" {% if default_notify_sound_enabled %}checked{% endif %} />
                    <span data-i18n="notify_sound">Sound alert</span>
                  </label>
                  <label class="checkbox">
                    <input type="checkbox" id="notify-popup-toggle" {% if default_notify_popup_enabled %}checked{% endif %} />
                    <span data-i18n="notify_popup">Popup notification</span>
                  </label>
                </div>
              </section>
              <section class="advanced-panel advanced-panel-wide">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="auto_scan_label">Auto Scan</span>
                    <p class="helper" data-i18n="auto_scan_helper">Runs a scan on a timer using your current filters.</p>
                  </div>
                </div>
                <div class="panel-body">
                  <div class="auto-scan-controls">
                    <label class="checkbox">
                      <input type="checkbox" id="auto-scan-toggle" {% if default_auto_scan_enabled %}checked{% endif %} />
                      <span data-i18n="auto_scan_enable">Enable auto scan</span>
                    </label>
                    <div class="auto-scan-interval">
                      <span class="auto-scan-label" data-i18n="auto_scan_interval_label">Interval (min)</span>
                      <input type="number" id="auto-scan-interval" min="1" step="1" value="{{ default_auto_scan_minutes }}" />
                    </div>
                  </div>
                </div>
              </section>
            </div>
            <div class="advanced-actions">
              <button type="button" id="close-advanced" class="secondary-btn" aria-label="Close" data-i18n="close">Close</button>
              <button type="button" id="save-settings" class="secondary-btn" data-i18n="save_settings">Save Settings</button>
            </div>
          </div>
        </div>

        <div class="actions">
          <div class="action-buttons">
            <button type="submit" id="scan-btn" data-i18n="scan_now">Scan Now</button>
          </div>
          <div id="status" class="status"></div>
        </div>
      </form>
    </section>

    <section class="card scan-status" id="scan-status">
      <div class="scan-status-head">
        <h3 data-i18n="scan_status_title">Scan Status</h3>
      </div>
      <div class="scan-status-grid">
        <div class="status-chip" id="scan-status-chip" data-status="idle">
          <span class="status-label" data-i18n="scan_status_label">Status</span>
          <span id="scan-status-text">Idle</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="stat_opportunities">Opportunities</span>
          <span id="scan-opportunities">0</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_last_scan">Last Scan</span>
          <span id="scan-last-time">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_api_calls">API Calls</span>
          <span id="scan-api-calls">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_duration">Duration</span>
          <span id="scan-duration">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_bottleneck">Bottleneck</span>
          <span id="scan-slowest">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_events">Events</span>
          <span id="scan-events">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_sports">Sports</span>
          <span id="scan-sports">-</span>
        </div>
      </div>
      <section id="summary-info" class="summary-info hidden"></section>
      <div id="scan-live" class="scan-live hidden" aria-live="polite">
        <p id="scan-live-elapsed" class="scan-live-line">Elapsed: -</p>
        <p id="scan-live-scope" class="scan-live-line">Scope: -</p>
      </div>
      <div id="scan-errors" class="scan-errors hidden"></div>
    </section>
      </aside>
      <section class="content">
    <nav class="tabs">
      <button type="button" class="tab-btn active" data-tab="arbitrage" data-i18n="tab_arbitrage">Arbitrage</button>
      <button type="button" class="tab-btn" data-tab="middles" data-i18n="tab_middles">Middles</button>
      <button type="button" class="tab-btn" data-tab="plus-ev" data-i18n="tab_plus_ev">+EV</button>
      <button type="button" class="tab-btn" data-tab="history" data-i18n="tab_history">History</button>
    </nav>

    <section class="card arbitrage-config" id="arbitrage-config">
      <div class="arbitrage-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="arb_min_roi">Minimum Net ROI (%)</label>
          <input type="number" id="min-roi-input" min="-100" max="10" step="0.1" value="{{ default_min_roi }}" />
          <p class="helper" data-i18n="arb_min_roi_helper">Hide opportunities below this net ROI.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="arbitrage-sort">
            <option value="roi" data-i18n="sort_roi" {% if default_arbitrage_sort == 'roi' %}selected{% endif %}>Net ROI</option>
            <option value="profit" data-i18n="sort_profit" {% if default_arbitrage_sort == 'profit' %}selected{% endif %}>Profit</option>
            <option value="time" data-i18n="sort_time" {% if default_arbitrage_sort == 'time' %}selected{% endif %}>Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section class="card middle-config hidden" id="middles-config">
      <div class="middle-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="middle_min_gap">Minimum Gap (points)</label>
          <input type="number" id="min-gap-input" min="0" max="10" step="0.5" value="{{ default_min_gap }}" />
          <p class="helper" data-i18n="middle_min_gap_helper">Only show middles with at least this many points between the lines.</p>
        </div>
        <div class="field toggle-field">
          <label class="field-label" data-i18n="filters_label">Filters</label>
          <label class="checkbox">
            <input type="checkbox" id="positive-ev-toggle" {% if default_positive_ev_only %}checked{% endif %} />
            <span data-i18n="positive_ev_only">Show only positive EV middles</span>
          </label>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="middle-sort">
            <option value="ev" data-i18n="sort_ev" {% if default_middle_sort == 'ev' %}selected{% endif %}>Estimated EV</option>
            <option value="probability" data-i18n="sort_probability" {% if default_middle_sort == 'probability' %}selected{% endif %}>Probability</option>
            <option value="gap" data-i18n="sort_gap" {% if default_middle_sort == 'gap' %}selected{% endif %}>Gap size</option>
            <option value="time" data-i18n="sort_time" {% if default_middle_sort == 'time' %}selected{% endif %}>Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section class="card plus-config hidden" id="plus-ev-config">
      <div class="plus-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="sharp_reference_book">Sharp Reference Book</label>
          <select id="sharp-book-select">
            {% for book in sharp_books %}
            <option value="{{ book.key }}" {% if book.key == default_sharp_book %}selected{% endif %}>{{ book.name }}</option>
            {% endfor %}
          </select>
          <p class="helper" data-i18n="sharp_book_helper">Used as the "true" odds source. Pinnacle recommended.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="min_edge_label">Minimum Edge (%)</label>
          <input type="number" id="min-edge-input" min="0" max="20" step="0.5" value="{{ default_min_edge_percent }}" />
          <p class="helper" data-i18n="min_edge_helper">Filter +EV bets below this edge.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="kelly_staking">Kelly Staking</label>
          <div class="kelly-grid">
            <input type="number" id="bankroll-input" min="0" step="50" value="{{ default_bankroll }}" />
            <select id="kelly-select">
              {% for opt in kelly_options %}
              <option value="{{ opt.value }}" data-kelly-value="{{ opt.value }}" {% if opt.value == default_kelly_fraction %}selected{% endif %}>{{ opt.label }}</option>
              {% endfor %}
            </select>
          </div>
          <p class="helper" data-i18n="kelly_helper">Bankroll + Kelly fraction are not persisted between scans.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="plus-ev-sort">
            <option value="edge" data-i18n="sort_edge" {% if default_plus_ev_sort == 'edge' %}selected{% endif %}>Edge %</option>
            <option value="ev" data-i18n="sort_ev_value" {% if default_plus_ev_sort == 'ev' %}selected{% endif %}>EV ($)</option>
            <option value="kelly" data-i18n="sort_kelly" {% if default_plus_ev_sort == 'kelly' %}selected{% endif %}>Kelly stake</option>
            <option value="time" data-i18n="sort_time" {% if default_plus_ev_sort == 'time' %}selected{% endif %}>Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section id="arbitrage-panel">
      <div id="partial-warning" class="alert warning hidden"></div>

      <div class="arbitrage-workspace">
        <section class="card results-card">
          <div class="card-head">
            <h3 data-i18n="opportunities_title">Opportunities</h3>
            <div class="table-meta">
              <span id="table-count">0 results</span>
              <span class="muted" id="arb-sort-label" data-i18n="sorted_by_roi">Sorted by ROI</span>
            </div>
          </div>
          <div class="table-scroll">
            <table id="results-table">
              <thead>
                <tr>
                  <th data-i18n="table_net_roi">Net ROI</th>
                  <th data-i18n="table_gross_roi">Gross ROI</th>
                  <th data-i18n="table_profit">Profit</th>
                  <th data-i18n="table_exchange">Exchange</th>
                  <th data-i18n="table_sport">Sport</th>
                  <th data-i18n="table_event">Event</th>
                  <th data-i18n="table_time">Time</th>
                  <th data-i18n="table_market">Market</th>
                  <th data-i18n="table_outcome_1">Outcome 1</th>
                  <th data-i18n="table_outcome_2">Outcome 2</th>
                  <th data-i18n="table_outcome_3">Outcome 3</th>
                  <th data-i18n="table_open">Open</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div id="table-empty" class="empty" data-i18n="empty_arbitrage">No arbitrage opportunities yet.</div>
        </section>

        <aside class="card arb-calculator-card" id="arb-calculator">
          <div class="card-head">
            <h3 data-i18n="arb_calc_title">Arbitrage Calculator</h3>
          </div>
          <div id="arb-calc-empty" class="empty" data-i18n="arb_calc_empty">Select an opportunity to open the calculator.</div>
          <div id="arb-calc-body" class="arb-calc-body hidden">
            <div class="arb-calc-context">
              <p id="arb-calc-event" class="arb-calc-event"></p>
              <p id="arb-calc-market" class="helper"></p>
            </div>

            <div class="arb-calc-total">
              <label class="field-label" for="arb-calc-total-input" data-i18n="arb_calc_total_stake">Total Stake ($)</label>
              <div class="arb-calc-total-row">
                <input type="number" id="arb-calc-total-input" min="0" step="0.01" />
                <button type="button" class="secondary-btn" id="arb-calc-auto-split" data-i18n="arb_calc_apply_total">Auto Split</button>
              </div>
            </div>

            <div class="arb-calc-legs">
              <section class="arb-calc-leg" id="arb-calc-leg-a">
                <h4 id="arb-calc-leg-a-title"></h4>
                <p class="helper" id="arb-calc-leg-a-book"></p>
                <div class="arb-calc-inputs">
                  <label>
                    <span data-i18n="arb_calc_odds">Odds</span>
                    <input type="number" id="arb-calc-odds-a" min="1.01" step="0.01" />
                  </label>
                  <label>
                    <span data-i18n="arb_calc_stake">Stake ($)</span>
                    <input type="number" id="arb-calc-stake-a" min="0" step="0.01" />
                  </label>
                </div>
                <div class="arb-calc-leg-actions">
                  <button type="button" class="secondary-btn" id="arb-calc-base-a" data-i18n="arb_calc_use_this_stake">Use This Stake</button>
                  <span class="mono" id="arb-calc-payout-a">-</span>
                </div>
              </section>

              <section class="arb-calc-leg" id="arb-calc-leg-b">
                <h4 id="arb-calc-leg-b-title"></h4>
                <p class="helper" id="arb-calc-leg-b-book"></p>
                <div class="arb-calc-inputs">
                  <label>
                    <span data-i18n="arb_calc_odds">Odds</span>
                    <input type="number" id="arb-calc-odds-b" min="1.01" step="0.01" />
                  </label>
                  <label>
                    <span data-i18n="arb_calc_stake">Stake ($)</span>
                    <input type="number" id="arb-calc-stake-b" min="0" step="0.01" />
                  </label>
                </div>
                <div class="arb-calc-leg-actions">
                  <button type="button" class="secondary-btn" id="arb-calc-base-b" data-i18n="arb_calc_use_this_stake">Use This Stake</button>
                  <span class="mono" id="arb-calc-payout-b">-</span>
                </div>
              </section>

              <section class="arb-calc-leg hidden" id="arb-calc-leg-c">
                <h4 id="arb-calc-leg-c-title"></h4>
                <p class="helper" id="arb-calc-leg-c-book"></p>
                <div class="arb-calc-inputs">
                  <label>
                    <span data-i18n="arb_calc_odds">Odds</span>
                    <input type="number" id="arb-calc-odds-c" min="1.01" step="0.01" />
                  </label>
                  <label>
                    <span data-i18n="arb_calc_stake">Stake ($)</span>
                    <input type="number" id="arb-calc-stake-c" min="0" step="0.01" />
                  </label>
                </div>
                <div class="arb-calc-leg-actions">
                  <button type="button" class="secondary-btn" id="arb-calc-base-c" data-i18n="arb_calc_use_this_stake">Use This Stake</button>
                  <span class="mono" id="arb-calc-payout-c">-</span>
                </div>
              </section>
            </div>

            <div class="arb-calc-summary">
              <div class="arb-calc-metric">
                <span class="stat-label" data-i18n="arb_calc_min_payout">Min Payout</span>
                <strong class="mono" id="arb-calc-min-payout">-</strong>
              </div>
              <div class="arb-calc-metric">
                <span class="stat-label" data-i18n="arb_calc_profit">Guaranteed Profit</span>
                <strong class="mono" id="arb-calc-profit">-</strong>
              </div>
              <div class="arb-calc-metric">
                <span class="stat-label" data-i18n="arb_calc_roi">ROI</span>
                <strong class="mono" id="arb-calc-roi">-</strong>
              </div>
            </div>
            <p class="helper arb-calc-warning hidden" id="arb-calc-warning"></p>
          </div>
        </aside>
      </div>
    </section>

    <section id="middles-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_middles_found">Middles Found</span>
          <span class="stat-value" id="middle-stat-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_positive_middles">+EV Middles</span>
          <span class="stat-value" id="middle-stat-positive">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_avg_ev">Avg EV</span>
          <span class="stat-value" id="middle-stat-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_best_ev">Best EV</span>
          <span class="stat-value" id="middle-stat-best">0%</span>
        </div>
      </section>

      <section id="middles-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="middles-sport-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card" id="middles-key-card">
          <div class="card-head">
            <h3 data-i18n="key_numbers_label">Key Numbers</h3>
          </div>
          <div id="middles-key-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="middles_title">Middles</h3>
          <div class="table-meta">
            <span id="middles-table-count">0 results</span>
            <span class="muted" id="middles-sort-label" data-i18n="sorted_by_ev">Sorted by EV</span>
          </div>
        </div>
        <div class="table-scroll">
          <table id="middles-table">
            <thead>
              <tr>
                <th data-i18n="table_ev">EV</th>
                <th data-i18n="table_prob">Prob</th>
                <th data-i18n="table_gap">Gap</th>
                <th data-i18n="table_sport">Sport</th>
                <th data-i18n="table_event">Event</th>
                <th data-i18n="table_time">Time</th>
                <th data-i18n="table_market">Market</th>
                <th data-i18n="table_side_a">Side A</th>
                <th data-i18n="table_side_b">Side B</th>
                <th data-i18n="table_middle">Middle</th>
                <th data-i18n="table_win_both">Win Both</th>
                <th data-i18n="table_miss">Miss</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="middles-empty" class="empty" data-i18n="empty_middles">No middle opportunities meet your filters.</div>
      </section>

      <section class="card middle-caveat">
        <p data-i18n-html="caveat_middles"><strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 &amp; 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.</p>
      </section>
    </section>

    <section id="plus-ev-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_plus_ev_bets">+EV Bets</span>
          <span class="stat-value" id="plus-ev-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_avg_edge">Avg Edge</span>
          <span class="stat-value" id="plus-ev-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_best_edge">Best Edge</span>
          <span class="stat-value" id="plus-ev-best">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_total_ev">Total EV ($100)</span>
          <span class="stat-value" id="plus-ev-total">$0</span>
        </div>
      </section>

      <section id="plus-ev-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="plus-ev-sport-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_edge_band">By Edge Band</h3>
          </div>
          <div id="plus-ev-edge-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="plus_ev_title">+EV Opportunities</h3>
          <div class="table-meta">
            <span id="plus-ev-table-count">0 results</span>
            <span class="muted" id="plus-ev-sort-label" data-i18n="sorted_by_edge">Sorted by Edge</span>
          </div>
        </div>
        <div class="table-scroll">
          <table id="plus-ev-table">
            <thead>
              <tr>
                <th data-i18n="table_edge">Edge</th>
                <th data-i18n="table_ev_100">EV ($100)</th>
                <th data-i18n="table_kelly">Kelly</th>
                <th data-i18n="table_sport">Sport</th>
                <th data-i18n="table_event">Event</th>
                <th data-i18n="table_time">Time</th>
                <th data-i18n="table_market">Market</th>
                <th data-i18n="table_bet">Bet</th>
                <th data-i18n="table_soft_odds">Soft Odds</th>
                <th data-i18n="table_fair_odds">Fair Odds</th>
                <th data-i18n="table_true_prob">True Prob</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="plus-ev-empty" class="empty" data-i18n="empty_plus_ev">No +EV bets at the current thresholds.</div>
      </section>

      <section class="card middle-caveat">
        <p data-i18n-html="caveat_plus_ev"><strong>Understanding +EV Betting:</strong> Sharp books (Pinnacle, Betfair, Matchbook) provide near "true" odds. When a soft book posts a higher price than fair value, the bet has positive expected value. +EV bets still lose roughly half the timeâ€”the edge shows up over many wagers. Kelly staking helps size bets, but variance can still be high. Always confirm odds before betting; edges disappear quickly.</p>
      </section>
    </section>
  
      
    <section id="history-panel" class="hidden">
      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="history_log_open">History Log</h3>
          <div class="table-meta">
            <span id="history-table-count">0 records</span>
            <button type="button" id="refresh-history-btn" class="secondary-btn" data-i18n="refresh_btn">Refresh</button>
          </div>
        </div>
        <div class="table-scroll">
          <table id="history-table">
            <thead>
              <tr>
                <th data-i18n="table_time">Scan Time</th>
                <th data-i18n="table_mode">Mode</th>
                <th data-i18n="table_metric">Metric (ROI/EV/Edge)</th>
                <th data-i18n="table_sport">Sport</th>
                <th data-i18n="table_event">Event</th>
                <th data-i18n="table_market">Market</th>
                <th data-i18n="table_match">Match</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="history-empty" class="empty" data-i18n="empty_history">No history recorded yet. Enable history tracking and run a scan.</div>
      </section>
    </section>
</section>
    </div>
</main>

  <div
    id="edge-scanner-config"
    data-has-env-key="{{ 'true' if has_env_key else 'false' }}"
    data-sharp-books='{{ sharp_books | tojson }}'
    data-default-sharp-book="{{ default_sharp_book }}"
    data-default-min-edge-percent="{{ default_min_edge_percent }}"
    data-default-bankroll="{{ default_bankroll }}"
    data-default-kelly-fraction="{{ default_kelly_fraction }}"
    data-default-odds-format="{{ default_odds_format }}"
    data-default-density="{{ default_density }}"
    data-default-theme="{{ default_theme }}"
    data-default-language="{{ default_language }}"
    data-default-all-markets="{{ 'true' if default_all_markets else 'false' }}"
    data-kelly-options='{{ kelly_options | tojson }}'
    data-bookmaker-links='{{ bookmaker_links | tojson }}'
    data-custom-provider-keys='{{ custom_provider_keys | tojson }}'
    hidden
  ></div>

  <script>
    const configEl = document.getElementById('edge-scanner-config');
    const parseConfigJson = (value, fallback) => {
      if (!value) return fallback;
      try {
        return JSON.parse(value);
      } catch (error) {
        return fallback;
      }
    };
    const appConfig = configEl
      ? {
          hasEnvKey: configEl.dataset.hasEnvKey === 'true',
          sharpBooks: parseConfigJson(configEl.dataset.sharpBooks, []),
          defaultSharpBook: configEl.dataset.defaultSharpBook || '',
          defaultMinEdgePercent: parseFloat(configEl.dataset.defaultMinEdgePercent || '0'),
          defaultBankroll: parseFloat(configEl.dataset.defaultBankroll || '0'),
          defaultKellyFraction: parseFloat(configEl.dataset.defaultKellyFraction || '0'),
          defaultOddsFormat: configEl.dataset.defaultOddsFormat || '',
          defaultDensity: configEl.dataset.defaultDensity || '',
          defaultTheme: configEl.dataset.defaultTheme || '',
          defaultLanguage: configEl.dataset.defaultLanguage || '',
          defaultAllMarkets: configEl.dataset.defaultAllMarkets === 'true',
          kellyOptions: parseConfigJson(configEl.dataset.kellyOptions, []),
          bookmakerLinks: parseConfigJson(configEl.dataset.bookmakerLinks, {}),
          customProviderKeys: parseConfigJson(configEl.dataset.customProviderKeys, []),
        }
      : {};
    let bookmakerLinks = { ...(appConfig.bookmakerLinks || {}) };
    const hasEnvKey = appConfig.hasEnvKey === true || appConfig.hasEnvKey === 'true';
    const form = document.getElementById('scan-form');
    const apiKeyInput = document.getElementById('api-key');
    const stakeInput = document.getElementById('stake-input');
    const scanBtn = document.getElementById('scan-btn');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary-info');
    const resultsBody = document.querySelector('#results-table tbody');
    const emptyState = document.getElementById('table-empty');
    const arbCalculator = document.getElementById('arb-calculator');
    const arbCalcEmpty = document.getElementById('arb-calc-empty');
    const arbCalcBody = document.getElementById('arb-calc-body');
    const arbCalcEvent = document.getElementById('arb-calc-event');
    const arbCalcMarket = document.getElementById('arb-calc-market');
    const arbCalcTotalInput = document.getElementById('arb-calc-total-input');
    const arbCalcAutoSplitBtn = document.getElementById('arb-calc-auto-split');
    const arbCalcLegA = document.getElementById('arb-calc-leg-a');
    const arbCalcLegATitle = document.getElementById('arb-calc-leg-a-title');
    const arbCalcLegAInfo = document.getElementById('arb-calc-leg-a-book');
    const arbCalcOddsAInput = document.getElementById('arb-calc-odds-a');
    const arbCalcStakeAInput = document.getElementById('arb-calc-stake-a');
    const arbCalcBaseABtn = document.getElementById('arb-calc-base-a');
    const arbCalcPayoutA = document.getElementById('arb-calc-payout-a');
    const arbCalcLegB = document.getElementById('arb-calc-leg-b');
    const arbCalcLegBTitle = document.getElementById('arb-calc-leg-b-title');
    const arbCalcLegBInfo = document.getElementById('arb-calc-leg-b-book');
    const arbCalcOddsBInput = document.getElementById('arb-calc-odds-b');
    const arbCalcStakeBInput = document.getElementById('arb-calc-stake-b');
    const arbCalcBaseBBtn = document.getElementById('arb-calc-base-b');
    const arbCalcPayoutB = document.getElementById('arb-calc-payout-b');
    const arbCalcLegC = document.getElementById('arb-calc-leg-c');
    const arbCalcLegCTitle = document.getElementById('arb-calc-leg-c-title');
    const arbCalcLegCInfo = document.getElementById('arb-calc-leg-c-book');
    const arbCalcOddsCInput = document.getElementById('arb-calc-odds-c');
    const arbCalcStakeCInput = document.getElementById('arb-calc-stake-c');
    const arbCalcBaseCBtn = document.getElementById('arb-calc-base-c');
    const arbCalcPayoutC = document.getElementById('arb-calc-payout-c');
    const arbCalcMinPayout = document.getElementById('arb-calc-min-payout');
    const arbCalcProfit = document.getElementById('arb-calc-profit');
    const arbCalcRoi = document.getElementById('arb-calc-roi');
    const arbCalcWarning = document.getElementById('arb-calc-warning');
    const arbCalcLegRefs = [
      {
        section: arbCalcLegA,
        title: arbCalcLegATitle,
        info: arbCalcLegAInfo,
        oddsInput: arbCalcOddsAInput,
        stakeInput: arbCalcStakeAInput,
        baseBtn: arbCalcBaseABtn,
        payoutEl: arbCalcPayoutA,
      },
      {
        section: arbCalcLegB,
        title: arbCalcLegBTitle,
        info: arbCalcLegBInfo,
        oddsInput: arbCalcOddsBInput,
        stakeInput: arbCalcStakeBInput,
        baseBtn: arbCalcBaseBBtn,
        payoutEl: arbCalcPayoutB,
      },
      {
        section: arbCalcLegC,
        title: arbCalcLegCTitle,
        info: arbCalcLegCInfo,
        oddsInput: arbCalcOddsCInput,
        stakeInput: arbCalcStakeCInput,
        baseBtn: arbCalcBaseCBtn,
        payoutEl: arbCalcPayoutC,
      },
    ];
    const allSportsToggle = document.getElementById('all-sports');
    const allMarketsToggle = document.getElementById('all-markets');
    const allBookmakersToggle = document.getElementById('all-bookmakers');
    const bookmakersList = document.getElementById('bookmakers-list');
    const bookmakerLinksList = bookmakersList;
    const saveSettingsBtn = document.getElementById('save-settings');
      const advancedSummary = document.getElementById('advanced-summary');
      const advancedModal = document.getElementById('advanced-modal');
      const openAdvancedBtn = document.getElementById('open-advanced');
      const closeAdvancedBtn = document.getElementById('close-advanced');
      const quickActionButtons = document.querySelectorAll('[data-quick-action][data-quick-target]');
    const tableCount = document.getElementById('table-count');
    const arbSortLabel = document.getElementById('arb-sort-label');
    const scanOpportunities = document.getElementById('scan-opportunities');
    const themeToggle = document.getElementById('theme-toggle');
    const toggleKeyBtn = document.getElementById('toggle-key');
    let currencyFormatter;
    const partialWarning = document.getElementById('partial-warning');
    const commissionInput = document.getElementById('commission-input');
    const tabs = document.querySelectorAll('.tab-btn');
    const arbitragePanel = document.getElementById('arbitrage-panel');
    const middlesPanel = document.getElementById('middles-panel');
    const plusEvPanel = document.getElementById('plus-ev-panel');
    const middlesConfig = document.getElementById('middles-config');
    const plusEvConfig = document.getElementById('plus-ev-config');
    const minGapInput = document.getElementById('min-gap-input');
    const positiveEvToggle = document.getElementById('positive-ev-toggle');
    const middleSortSelect = document.getElementById('middle-sort');
    const middleStatCount = document.getElementById('middle-stat-count');
    const middleStatPositive = document.getElementById('middle-stat-positive');
    const middleStatAvg = document.getElementById('middle-stat-avg');
    const middleStatBest = document.getElementById('middle-stat-best');
    const middleSummaryInfo = document.getElementById('middles-summary-info');
    const middleSportBars = document.getElementById('middles-sport-bars');
    const middleKeyBars = document.getElementById('middles-key-bars');
    const middleKeyCard = document.getElementById('middles-key-card');
    const middlesTableBody = document.querySelector('#middles-table tbody');
    const middlesTableCount = document.getElementById('middles-table-count');
    const middlesSortLabel = document.getElementById('middles-sort-label');
    const middlesEmpty = document.getElementById('middles-empty');
    const sharpSelect = document.getElementById('sharp-book-select');
    const minEdgeInput = document.getElementById('min-edge-input');
    const bankrollInput = document.getElementById('bankroll-input');
    const kellySelect = document.getElementById('kelly-select');
    const plusEvSortSelect = document.getElementById('plus-ev-sort');
    const plusEvCount = document.getElementById('plus-ev-count');
    const plusEvAvg = document.getElementById('plus-ev-avg');
    const plusEvBest = document.getElementById('plus-ev-best');
    const plusEvTotal = document.getElementById('plus-ev-total');
    const plusEvSummaryInfo = document.getElementById('plus-ev-summary-info');
    const plusEvSportBars = document.getElementById('plus-ev-sport-bars');
    const plusEvEdgeBars = document.getElementById('plus-ev-edge-bars');
    const plusEvTableBody = document.querySelector('#plus-ev-table tbody');
    const plusEvTableCount = document.getElementById('plus-ev-table-count');
    const plusEvSortLabel = document.getElementById('plus-ev-sort-label');
    const plusEvEmpty = document.getElementById('plus-ev-empty');
    const oddsToggle = document.getElementById('odds-toggle');
    const languageToggle = document.getElementById('language-toggle');
    const densityToggle = document.getElementById('density-toggle');
    const arbitrageConfig = document.getElementById('arbitrage-config');
    const minRoiInput = document.getElementById('min-roi-input');
    const arbitrageSortSelect = document.getElementById('arbitrage-sort');
    const scanStatusChip = document.getElementById('scan-status-chip');
    const scanStatusText = document.getElementById('scan-status-text');
    const scanLastTime = document.getElementById('scan-last-time');
    const scanApiCalls = document.getElementById('scan-api-calls');
    const scanDuration = document.getElementById('scan-duration');
    const scanSlowest = document.getElementById('scan-slowest');
    const scanEvents = document.getElementById('scan-events');
    const scanSports = document.getElementById('scan-sports');
    const scanLive = document.getElementById('scan-live');
    const scanLiveElapsed = document.getElementById('scan-live-elapsed');
    const scanLiveScope = document.getElementById('scan-live-scope');
    const scanErrors = document.getElementById('scan-errors');
    const autoScanToggle = document.getElementById('auto-scan-toggle');
    const autoScanIntervalInput = document.getElementById('auto-scan-interval');
    const notifySoundToggle = document.getElementById('notify-sound-toggle');
    const notifyPopupToggle = document.getElementById('notify-popup-toggle');
    const defaultCommissionPercent = commissionInput ? parseFloat(commissionInput.value) || 5 : 5;
    let lastCommissionRate = defaultCommissionPercent / 100;
    let lastScanData = null;
    let activeTab = 'arbitrage';
    let oddsFormat = localStorage.getItem('edge-odds-format') || appConfig.defaultOddsFormat || 'decimal';
    let densityMode = localStorage.getItem('edge-density') || appConfig.defaultDensity || 'comfort';
    let isScanning = false;
      let lastStatus = null;
      let lastFocusedElement = null;
      let autoScanTimer = null;
      let scanFeedbackTimer = null;
      let scanStartedAtMs = 0;
      let scanLastStatusKey = '';
      let scanLastElapsedSecond = -1;
      let activeScanContext = null;
      let scanLockedControls = [];
      const scanControlDisabledState = new WeakMap();
      let notificationAudioContext = null;
      let selectedArbKey = null;
      let selectedArbOpp = null;
      let arbCalculatorState = null;

    const TRANSLATIONS = {
      en: {
        tagline: 'Arbitrage / Middles / +EV',
        odds_decimal: 'Decimal',
        odds_american: 'American',
        toggle_theme: 'Toggle theme',
        toggle_language: 'Toggle language',
        toggle_density: 'Toggle density',
        lang_en: 'EN',
        lang_zh: '\u4e2d\u6587',
        api_key_label: 'API Key',
                env_key_notice: 'Using API key from .env',
        api_key_show: 'Show API key',
                api_key_hide: 'Hide API key',
        show_short: 'Show',
        hide_short: 'Hide',
        theme_light: 'Light',
        theme_dark: 'Dark',
        total_stake_label: 'Total Stake ($)',
        stake_helper: 'Used for arbitrage + middles stake splits.',
        sports_label: 'Sports',
        all_sports_label: 'Scan all active sports (uses more API credits)',
        all_markets_label: 'Scan extended markets (can use more API credits)',
        all_markets_helper: 'Attempts to include extra market types and player props for arbitrage/+EV.',
        sports_helper: 'Each selected sport consumes one API request.',
        bookmakers_label: 'Bookmakers',
        all_bookmakers_label: 'Use all available bookmakers',
        bookmakers_helper: 'Optional: limit results to the selected bookmakers.',
        bookmaker_links_label: 'Bookmaker Links',
        bookmaker_links_helper: 'Customize open URLs. Supports placeholders like {event_id}, {home_team}, {away_team}. Leave blank to skip.',
        auto_scan_label: 'Auto Scan',
        auto_scan_enable: 'Enable auto scan',
        auto_scan_interval_label: 'Interval (min)',
        auto_scan_helper: 'Runs a scan on a timer using your current filters.',
          advanced_settings: 'Advanced settings',
          advanced_hint: 'Less frequently adjusted options live here.',
          advanced_summary: 'Sports {sports} | Books {books} | Regions {regions}',
          summary_all: 'All',
          notify_label: 'Notifications',
          notify_sound: 'Sound alert',
          notify_popup: 'Popup notification',
          notify_helper: 'Browser permission is required for popup notifications.',
          notify_body: 'Arb {arb} | Middles {middle} | +EV {plus}',
          select_all: 'Select all',
          clear_all: 'Clear',
          close: 'Close',
        regions_label: 'Regions',
        regions_helper: 'Select at least one region. EU is always included for sharp reference.',
        commission_label: 'Exchange Commission (%)',
        commission_helper: 'Applied to Betfair, Matchbook, Sportsbet Exchange, etc.',
        commission_note: 'Net ROI/EV already reflects this commission.',
        scan_now: 'Scan Now',
        save_settings: 'Save settings',
        scanning: 'Scanning...',
        scanning_wait: 'Scanning, please wait...',
        scanning_wait_elapsed: 'Scanning, please wait... ({elapsed})',
        scan_wait_slow: 'Sources are responding slowly. Still scanning... ({elapsed})',
        scan_wait_very_slow: 'Scan is taking longer than expected ({elapsed}). Try fewer sports or bookmakers if this continues.',
        density_comfort: 'Comfort',
        density_compact: 'Compact',
        tab_arbitrage: 'Arbitrage',
        tab_middles: 'Middles',
        tab_plus_ev: '+EV',

        tab_history: 'åŽ†å²',
        history_log_open: 'æ‰«æåŽ†å²',
        refresh_btn: 'åˆ·æ–°',
        empty_history: 'æš‚æ— åŽ†å²è®°å½•ã€‚è¯·å¼€å¯åŽ†å²è¿½è¸ªå¹¶è¿è¡Œæ‰«æã€‚',
        table_time: 'æ‰«ææ—¶é—´',
        table_mode: 'æ¨¡å¼',
        table_metric: 'æŒ‡æ ‡',
        table_match: 'å¯¹é˜µ',


        tab_history: 'History',
        history_log_open: 'History Log',
        refresh_btn: 'Refresh',
        empty_history: 'No history recorded yet. Enable history tracking and run a scan.',
        table_time: 'Scan Time',
        table_mode: 'Mode',
        table_metric: 'Metric (ROI/EV/Edge)',
        table_match: 'Match',

        arb_min_roi: 'Minimum Net ROI (%)',
        arb_min_roi_helper: 'Hide opportunities below this net ROI.',
        middle_min_gap: 'Minimum Gap (points)',
        middle_min_gap_helper: 'Only show middles with at least this many points between the lines.',
        filters_label: 'Filters',
        positive_ev_only: 'Show only positive EV middles',
        sort_by: 'Sort By',
        sort_roi: 'Net ROI',
        sort_profit: 'Profit',
        sort_ev: 'Estimated EV',
        sort_probability: 'Probability',
        sort_gap: 'Gap size',
        sort_time: 'Event time',
        sharp_reference_book: 'Sharp Reference Book',
        sharp_book_helper: 'Used as the \"true\" odds source. Pinnacle recommended.',
        min_edge_label: 'Minimum Edge (%)',
        min_edge_helper: 'Filter +EV bets below this edge.',
        kelly_staking: 'Kelly Staking',
        kelly_helper: 'Bankroll + Kelly fraction are not persisted between scans.',
        sort_edge: 'Edge %',
        sort_ev_value: 'EV ($)',
        sort_kelly: 'Kelly stake',
        kelly_full: 'Full Kelly',
        kelly_half: 'Half Kelly',
        kelly_quarter: 'Quarter Kelly',
        kelly_tenth: 'Tenth Kelly',
        stat_opportunities: 'Opportunities',
        stat_events_scanned: 'Events Scanned',
        stat_sports: 'Sports',
        stat_api_calls: 'API Calls',
        stat_middles_found: 'Middles Found',
        stat_positive_middles: '+EV Middles',
        stat_avg_ev: 'Avg EV',
        stat_best_ev: 'Best EV',
        stat_plus_ev_bets: '+EV Bets',
        stat_avg_edge: 'Avg Edge',
        stat_best_edge: 'Best Edge',
        stat_total_ev: 'Total EV ($100)',
        scan_status_title: 'Scan Status',
        scan_status_label: 'Status',
        scan_last_scan: 'Last Scan',
        scan_api_calls: 'API Calls',
        scan_duration: 'Duration',
        scan_bottleneck: 'Bottleneck',
        scan_events: 'Events',
        scan_sports: 'Sports',
        scan_live_elapsed: 'Elapsed: {elapsed}',
        scan_live_scope: 'Scope: {details}',
        scan_scope_summary: 'Sports {sports} | Regions {regions} | Books {books} | Providers {providers} | Markets {markets}',
        scan_scope_all: 'All',
        scan_scope_none: 'None',
        scan_markets_core: 'Core',
        scan_markets_extended: 'Extended',
        status_idle: 'Idle',
        status_ready: 'Ready',
        status_scanning: 'Scanning',
        status_error: 'Error',
        status_partial: 'Partial',
        scan_errors: '<strong>Errors:</strong> {details}',
        scan_market_skips: '<strong>Skipped markets:</strong> {details}',
        by_roi_band: 'By ROI Band',
        by_sport: 'By Sport',
        by_edge_band: 'By Edge Band',
        key_numbers_label: 'Key Numbers',
        opportunities_title: 'Opportunities',
        middles_title: 'Middles',
        plus_ev_title: '+EV Opportunities',
        sorted_by_roi: 'Sorted by ROI',
        sorted_by_ev: 'Sorted by EV',
        sorted_by_edge: 'Sorted by Edge',
        sorted_by_profit: 'Sorted by Profit',
        sorted_by_time: 'Sorted by Time',
        sorted_by_probability: 'Sorted by Probability',
        sorted_by_gap: 'Sorted by Gap',
        sorted_by_kelly: 'Sorted by Kelly',
        sorted_by_ev_value: 'Sorted by EV',
        table_net_roi: 'Net ROI',
        table_gross_roi: 'Gross ROI',
        table_profit: 'Profit',
        table_exchange: 'Exchange',
        table_sport: 'Sport',
        table_event: 'Event',
        table_time: 'Time',
        table_market: 'Market',
        table_outcome_1: 'Outcome 1',
        table_outcome_2: 'Outcome 2',
        table_outcome_3: 'Outcome 3',
        table_open: 'Open',
        arb_calc_title: 'Arbitrage Calculator',
        arb_calc_empty: 'Select an opportunity to open the calculator.',
        arb_calc_total_stake: 'Total Stake ($)',
        arb_calc_apply_total: 'Auto Split',
        arb_calc_odds: 'Odds',
        arb_calc_stake: 'Stake ($)',
        arb_calc_use_this_stake: 'Use This Stake',
        arb_calc_payout: 'Payout',
        arb_calc_market_time: 'Market: {market} | Start: {time}',
        arb_calc_min_payout: 'Min Payout',
        arb_calc_profit: 'Guaranteed Profit',
        arb_calc_roi: 'ROI',
        arb_calc_invalid: 'Enter valid decimal odds (>1.00) and stake values.',
        arb_calc_exceeds_max: 'Stake exceeds listed max: {items}',
        table_ev: 'EV',
        table_prob: 'Prob',
        table_gap: 'Gap',
        table_side_a: 'Side A',
        table_side_b: 'Side B',
        table_middle: 'Middle',
        table_win_both: 'Win Both',
        table_miss: 'Miss',
        table_edge: 'Edge',
        table_ev_100: 'EV ($100)',
        table_kelly: 'Kelly',
        table_bet: 'Bet',
        table_soft_odds: 'Soft Odds',
        table_fair_odds: 'Fair Odds',
        table_true_prob: 'True Prob',
        empty_arbitrage: 'No arbitrage opportunities yet.',
        empty_middles: 'No middle opportunities meet your filters.',
        empty_plus_ev: 'No +EV bets at the current thresholds.',
        caveat_middles:
          '<strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 &amp; 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.',
        caveat_plus_ev:
          '<strong>Understanding +EV Betting:</strong> Sharp books (Pinnacle, Betfair, Matchbook) provide near \"true\" odds. When a soft book posts a higher price than fair value, the bet has positive expected value. +EV bets still lose roughly half the time - the edge shows up over many wagers. Kelly staking helps size bets, but variance can still be high. Always confirm odds before betting; edges disappear quickly.',
        summary_title: 'Summary',
        summary_profit: 'Total potential profit: {profit}{staked}',
        summary_profit_staked: ' on {staked} staked',
        summary_commission: 'Exchange commission applied: {commission}.',
        summary_roi_note: 'ROI = return on total stake. 2% ROI means $2 profit on a $100 stake.',
        filters_applied: 'Showing {shown} of {total} opportunities after filters.',
        middle_summary_counts: 'Middles matching filters: {count}, with {positive} positive EV.',
        middle_summary_avg: 'Average EV: {avg}{best}',
        middle_summary_best: ' | Best: {event}',
        middle_spreads_only: 'Spreads only',
        plus_summary: '+EV bets: {count} | Average edge {avg}{best}',
        plus_summary_best: ' | Best: {event}',
        results_count: '{count} results',
        results_profit: '{count} results | {profit} profit',
        partial_results: '<strong>Partial results:</strong> Failed to fetch odds for {details}.',
        market_skips: '<strong>Skipped markets:</strong> {details}.',
        tbd: 'TBD',
        gross: 'Gross',
        net_at: 'Net @ {odds}',
        odds_label: 'Odds: {odds}',
        available_label: 'Available: {amount}',
        stake_label: 'Stake: {stake}',
        exchange: 'Exchange',
        no: 'No',
        no_data: 'No data',
        open_books: 'Open',
        open_books_missing: 'No bookmaker links available for this opportunity.',
        open_books_blocked: 'Pop-up blocked. Allow pop-ups to open bookmakers.',
        gap_points: '{points} pts',
        gap_separator: ' / ',
        kelly_roll: '{percent}% roll',
        net_roi_negative: 'Net ROI is negative after commission.',
        scan_complete: 'Scan complete at {time}',
        scan_failed: 'Scan failed',
        settings_saved: 'Settings saved',
        enter_api_key: 'Please enter your API key.',
        select_region: 'Select at least one region.',
        select_bookmakers: 'Select at least one bookmaker.',
        unknown: 'Unknown',
        unknown_error: 'Unknown error',
      },
      zh: {
        tagline: 'å¥—åˆ© / ä¸­é—´ç›˜ / +EV',
        odds_decimal: 'åè¿›åˆ¶',
        odds_american: 'ç¾Žå¼',
        toggle_theme: 'åˆ‡æ¢ä¸»é¢˜',
        toggle_language: 'åˆ‡æ¢è¯­è¨€',
        toggle_density: 'åˆ‡æ¢å¯†åº¦',
        lang_en: 'EN',
        lang_zh: '\u4e2d\u6587',
        api_key_label: 'API å¯†é’¥',
                        env_key_notice: 'ä½¿ç”¨ .env ä¸­çš„ API å¯†é’¥',
        api_key_show: 'æ˜¾ç¤º API å¯†é’¥',
                        api_key_hide: 'éšè— API å¯†é’¥',
                show_short: 'æ˜¾ç¤º',
                hide_short: 'éšè—',
                theme_light: 'æµ…è‰²',
                theme_dark: 'æ·±è‰²',
        total_stake_label: 'æ€»ä¸‹æ³¨é‡‘é¢ ($)',
        stake_helper: 'ç”¨äºŽå¥—åˆ©å’Œä¸­é—´ç›˜çš„ä¸‹æ³¨æ‹†åˆ†è®¡ç®—ã€‚',
        sports_label: 'ä½“è‚²é¡¹ç›®',
        all_sports_label: 'æ‰«ææ‰€æœ‰æ´»è·ƒé¡¹ç›®ï¼ˆæ¶ˆè€—æ›´å¤š API é¢åº¦ï¼‰',
        all_markets_label: 'æ‰«ææ‰©å±•ç›˜å£ï¼ˆå¯èƒ½æ¶ˆè€—æ›´å¤š API é¢åº¦ï¼‰',
        all_markets_helper: 'å°è¯•çº³å…¥æ›´å¤šç›˜å£ç±»åž‹å’Œçƒå‘˜é“å…·ç›˜ç”¨äºŽå¥—åˆ©/+EVã€‚',
        sports_helper: 'æ¯ä¸ªå·²é€‰é¡¹ç›®ä¼šæ¶ˆè€—ä¸€æ¬¡ API è¯·æ±‚ã€‚',
        bookmakers_label: 'åšå½©å¹³å°',
        all_bookmakers_label: 'ä½¿ç”¨æ‰€æœ‰å¯ç”¨å¹³å°',
        bookmakers_helper: 'å¯é€‰ï¼šä»…æ‰«æé€‰å®šçš„å¹³å°ã€‚',
        bookmaker_links_label: 'å¹³å°é“¾æŽ¥',
        bookmaker_links_helper: 'è‡ªå®šä¹‰è‡ªåŠ¨æ‰“å¼€ç½‘å€ã€‚æ”¯æŒ {event_id}ã€{home_team}ã€{away_team} å ä½ç¬¦ï¼Œç•™ç©ºåˆ™ä¸æ‰“å¼€è¯¥å¹³å°ã€‚',
        auto_scan_label: 'è‡ªåŠ¨æ‰«æ',
        auto_scan_enable: 'å¯ç”¨è‡ªåŠ¨æ‰«æ',
        auto_scan_interval_label: 'æ‰«æé—´éš”ï¼ˆåˆ†é’Ÿï¼‰',
        auto_scan_helper: 'æŒ‰å½“å‰ç­›é€‰æ¡ä»¶å®šæ—¶è‡ªåŠ¨æ‰«æã€‚',
        advanced_settings: 'é«˜çº§è®¾ç½®',
        advanced_hint: 'ä¸å¸¸è°ƒæ•´çš„é€‰é¡¹æ”¾åœ¨è¿™é‡Œã€‚',
                advanced_summary: 'é¡¹ç›® {sports} | å¹³å° {books} | åœ°åŒº {regions}',
          summary_all: 'å…¨éƒ¨',
          notify_label: 'é€šçŸ¥',
          notify_sound: 'é“ƒå£°æç¤º',
          notify_popup: 'å¼¹çª—é€šçŸ¥',
          notify_helper: 'å¼¹çª—é€šçŸ¥éœ€è¦æµè§ˆå™¨æŽˆæƒã€‚',
          notify_body: 'å¥—åˆ© {arb} | ä¸­ç›˜ {middle} | +EV {plus}',
          select_all: 'å…¨é€‰',
          clear_all: 'æ¸…ç©º',
          close: 'å…³é—­',
        regions_label: 'åœ°åŒº',
        regions_helper: 'è‡³å°‘é€‰æ‹©ä¸€ä¸ªåœ°åŒºã€‚ä¸ºé”ç›˜å‚è€ƒå°†å§‹ç»ˆåŒ…å« EUã€‚',
        commission_label: 'äº¤æ˜“æ‰€æ‰‹ç»­è´¹ (%)',
        commission_helper: 'é€‚ç”¨äºŽ Betfairã€Matchbookã€Sportsbet Exchange ç­‰ã€‚',
        commission_note: 'å‡€ ROI/EV å·²è®¡å…¥è¯¥æ‰‹ç»­è´¹ã€‚',
        scan_now: 'å¼€å§‹æ‰«æ',
        save_settings: 'ä¿å­˜è®¾ç½®',
        scanning: 'æ‰«æä¸­...',
        scanning_wait: 'æ­£åœ¨æ‰«æï¼Œè¯·ç¨å€™...',
        scanning_wait_elapsed: 'æ­£åœ¨æ‰«æï¼Œè¯·ç¨å€™...ï¼ˆå·²è€—æ—¶ {elapsed}ï¼‰',
        scan_wait_slow: 'æ•°æ®æºå“åº”è¾ƒæ…¢ï¼Œä»åœ¨æ‰«æ...ï¼ˆ{elapsed}ï¼‰',
        scan_wait_very_slow: 'æœ¬æ¬¡æ‰«æè€—æ—¶è¾ƒé•¿ï¼ˆ{elapsed}ï¼‰ï¼Œè‹¥æŒç»­å¯å°è¯•å‡å°‘é¡¹ç›®æˆ–å¹³å°èŒƒå›´ã€‚',
        density_comfort: 'èˆ’é€‚',
        density_compact: 'ç´§å‡‘',
        tab_arbitrage: 'å¥—åˆ©',
        tab_middles: 'ä¸­é—´ç›˜',
        tab_plus_ev: '+EV',
        arb_min_roi: 'æœ€å°å‡€ ROI (%)',
        arb_min_roi_helper: 'éšè—ä½ŽäºŽè¯¥å‡€ ROI çš„æœºä¼šã€‚',
        middle_min_gap: 'æœ€å°é—´éš”ï¼ˆåˆ†ï¼‰',
        middle_min_gap_helper: 'ä»…æ˜¾ç¤ºç›˜å£å·®è‡³å°‘è¾¾åˆ°è¯¥åˆ†æ•°çš„ä¸­é—´ç›˜ã€‚',
        filters_label: 'ç­›é€‰',
        positive_ev_only: 'ä»…æ˜¾ç¤ºæ­£ EV çš„ä¸­é—´ç›˜',
        sort_by: 'æŽ’åº',
        sort_roi: 'å‡€ ROI',
        sort_profit: 'åˆ©æ¶¦',
        sort_ev: 'é¢„è®¡ EV',
        sort_probability: 'æ¦‚çŽ‡',
        sort_gap: 'é—´éš”å¤§å°',
        sort_time: 'æ¯”èµ›æ—¶é—´',
        sharp_reference_book: 'é”ç›˜å‚è€ƒä¹¦å•†',
        sharp_book_helper: 'ä½œä¸ºâ€œçœŸå®žâ€èµ”çŽ‡å‚è€ƒæ¥æºï¼ŒæŽ¨è Pinnacleã€‚',
        min_edge_label: 'æœ€å° Edge (%)',
        min_edge_helper: 'è¿‡æ»¤ä½ŽäºŽè¯¥è¾¹é™…çš„ +EV æŠ•æ³¨ã€‚',
        kelly_staking: 'å‡¯åˆ©ä¸‹æ³¨',
        kelly_helper: 'èµ„é‡‘å’Œå‡¯åˆ©æ¯”ä¾‹ä¸ä¼šåœ¨æ‰«æä¹‹é—´ä¿å­˜ã€‚',
        sort_edge: 'Edge %',
        sort_ev_value: 'EV ($)',
        sort_kelly: 'å‡¯åˆ©ä¸‹æ³¨',
        kelly_full: 'å…¨å‡¯åˆ©',
        kelly_half: 'åŠå‡¯åˆ©',
        kelly_quarter: 'å››åˆ†ä¹‹ä¸€å‡¯åˆ©',
        kelly_tenth: 'ååˆ†ä¹‹ä¸€å‡¯åˆ©',
        stat_opportunities: 'æœºä¼š',
        stat_events_scanned: 'æ‰«æèµ›äº‹',
        stat_sports: 'é¡¹ç›®æ•°',
        stat_api_calls: 'API è°ƒç”¨',
        stat_middles_found: 'ä¸­é—´ç›˜æ•°é‡',
        stat_positive_middles: '+EV ä¸­é—´ç›˜',
        stat_avg_ev: 'å¹³å‡ EV',
        stat_best_ev: 'æœ€é«˜ EV',
        stat_plus_ev_bets: '+EV æŠ•æ³¨',
        stat_avg_edge: 'å¹³å‡ Edge',
        stat_best_edge: 'æœ€é«˜ Edge',
        stat_total_ev: 'æ€» EVï¼ˆ$100ï¼‰',
        scan_status_title: 'æ‰«æçŠ¶æ€',
        scan_status_label: 'çŠ¶æ€',
        scan_last_scan: 'ä¸Šæ¬¡æ‰«æ',
        scan_api_calls: 'API è°ƒç”¨',
        scan_duration: '\u603b\u8017\u65f6',
        scan_bottleneck: '\u6700\u6162\u9636\u6bb5',
        scan_events: 'èµ›äº‹æ•°',
        scan_sports: 'é¡¹ç›®æ•°',
        scan_live_elapsed: 'å·²è€—æ—¶ï¼š{elapsed}',
        scan_live_scope: 'æœ¬æ¬¡èŒƒå›´ï¼š{details}',
        scan_scope_summary: 'é¡¹ç›® {sports} | åœ°åŒº {regions} | å¹³å° {books} | Provider {providers} | ç›˜å£ {markets}',
        scan_scope_all: 'å…¨éƒ¨',
        scan_scope_none: 'æ— ',
        scan_markets_core: 'åŸºç¡€',
        scan_markets_extended: 'æ‰©å±•',
        status_idle: 'ç©ºé—²',
        status_ready: 'å°±ç»ª',
        status_scanning: 'æ‰«æä¸­',
        status_error: 'é”™è¯¯',
        status_partial: 'éƒ¨åˆ†ç»“æžœ',
        scan_errors: '<strong>é”™è¯¯ï¼š</strong>{details}',
        scan_market_skips: '<strong>å·²è·³è¿‡ç›˜å£ï¼š</strong>{details}',
        by_roi_band: 'æŒ‰ ROI åŒºé—´',
        by_sport: 'æŒ‰é¡¹ç›®',
        by_edge_band: 'æŒ‰ Edge åŒºé—´',
        key_numbers_label: 'å…³é”®åˆ†å·®',
        opportunities_title: 'æœºä¼š',
        middles_title: 'ä¸­é—´ç›˜',
        plus_ev_title: '+EV æœºä¼š',
        sorted_by_roi: 'æŒ‰ ROI æŽ’åº',
        sorted_by_ev: 'æŒ‰ EV æŽ’åº',
        sorted_by_edge: 'æŒ‰ Edge æŽ’åº',
        sorted_by_profit: 'æŒ‰åˆ©æ¶¦æŽ’åº',
        sorted_by_time: 'æŒ‰æ—¶é—´æŽ’åº',
        sorted_by_probability: 'æŒ‰æ¦‚çŽ‡æŽ’åº',
        sorted_by_gap: 'æŒ‰é—´éš”æŽ’åº',
        sorted_by_kelly: 'æŒ‰å‡¯åˆ©æŽ’åº',
        sorted_by_ev_value: 'æŒ‰ EV æŽ’åº',
        table_net_roi: 'å‡€ ROI',
        table_gross_roi: 'æ€» ROI',
        table_profit: 'åˆ©æ¶¦',
        table_exchange: 'äº¤æ˜“æ‰€',
        table_sport: 'é¡¹ç›®',
        table_event: 'èµ›äº‹',
        table_time: 'æ—¶é—´',
        table_market: 'ç›˜å£',
        table_outcome_1: 'é€‰é¡¹ 1',
        table_outcome_2: 'é€‰é¡¹ 2',
        table_outcome_3: 'é€‰é¡¹ 3',
        table_open: 'æ‰“å¼€',
        arb_calc_title: 'å¥—åˆ©è®¡ç®—å™¨',
        arb_calc_empty: 'ç‚¹å‡»ä¸€æ¡å¥—åˆ©æœºä¼šåŽåœ¨è¿™é‡Œè®¡ç®—ã€‚',
        arb_calc_total_stake: 'æ€»ä¸‹æ³¨é‡‘é¢ ($)',
        arb_calc_apply_total: 'æŒ‰æ€»é¢æ‹†åˆ†',
        arb_calc_odds: 'èµ”çŽ‡',
        arb_calc_stake: 'ä¸‹æ³¨é¢ ($)',
        arb_calc_use_this_stake: 'ä»¥æ­¤é‡‘é¢ä¸ºå‡†',
        arb_calc_payout: 'è¿”è¿˜',
        arb_calc_market_time: 'ç›˜å£ï¼š{market} | å¼€èµ›ï¼š{time}',
        arb_calc_min_payout: 'æœ€ä½Žè¿”è¿˜',
        arb_calc_profit: 'ä¿åº•åˆ©æ¶¦',
        arb_calc_roi: 'ROI',
        arb_calc_invalid: 'è¯·è¾“å…¥æœ‰æ•ˆåè¿›åˆ¶èµ”çŽ‡ï¼ˆ>1.00ï¼‰å’Œä¸‹æ³¨é‡‘é¢ã€‚',
        arb_calc_exceeds_max: 'ä¸‹æ³¨è¶…è¿‡å¯ä¸‹ä¸Šé™ï¼š{items}',
        table_ev: 'EV',
        table_prob: 'æ¦‚çŽ‡',
        table_gap: 'é—´éš”',
        table_side_a: 'A è¾¹',
        table_side_b: 'B è¾¹',
        table_middle: 'ä¸­é—´åŒºé—´',
        table_win_both: 'ä¸¤è¾¹å…¨èµ¢',
        table_miss: 'æœªå‘½ä¸­',
        table_edge: 'Edge',
        table_ev_100: 'EV ($100)',
        table_kelly: 'å‡¯åˆ©',
        table_bet: 'æŠ•æ³¨',
        table_soft_odds: 'è½¯ç›˜èµ”çŽ‡',
        table_fair_odds: 'å…¬å¹³èµ”çŽ‡',
        table_true_prob: 'çœŸå®žæ¦‚çŽ‡',
        empty_arbitrage: 'æš‚æ— å¥—åˆ©æœºä¼šã€‚',
        empty_middles: 'æ²¡æœ‰ç¬¦åˆç­›é€‰æ¡ä»¶çš„ä¸­é—´ç›˜ã€‚',
        empty_plus_ev: 'å½“å‰é˜ˆå€¼ä¸‹æš‚æ—  +EV æŠ•æ³¨ã€‚',
        caveat_middles:
          '<strong>ç†è§£ä¸­é—´ç›˜ï¼š</strong>ä¸­é—´ç›˜å±žäºŽé«˜æ³¢åŠ¨çŽ©æ³•ï¼Œå¤§å¤šæ•°æ—¶å€™å°äºï¼Œæ¯”åˆ†è½åœ¨åŒºé—´å†…æ—¶å¤§èµ¢ã€‚æ¦‚çŽ‡ä¸ºåŽ†å²åˆ†å¸ƒä¼°ç®—ï¼ˆNFL å…³é”®åˆ†å·®å¦‚ 3ã€7 ä¼šæ˜¾è‘—æå‡ EVï¼‰ã€‚è¯·å°† EV è§†ä¸ºå‚è€ƒå¹¶è°¨æ…Žä¸‹æ³¨ã€‚',
        caveat_plus_ev:
          '<strong>ç†è§£ +EV æŠ•æ³¨ï¼š</strong>é”ç›˜ï¼ˆPinnacleã€Betfairã€Matchbookï¼‰æä¾›æŽ¥è¿‘â€œçœŸå®žâ€çš„èµ”çŽ‡ã€‚å½“è½¯ç›˜ç»™å‡ºé«˜äºŽå…¬å¹³èµ”çŽ‡çš„ä»·æ ¼æ—¶ï¼Œè¯¥æŠ•æ³¨ä¸ºæ­£æœŸæœ›ã€‚+EV æŠ•æ³¨ä»æœ‰çº¦ä¸€åŠæ—¶é—´ä¼šè¾“ï¼Œä¼˜åŠ¿æ¥è‡ªé•¿æœŸã€‚å‡¯åˆ©æ³•å¯å¸®åŠ©æŽ§åˆ¶ä¸‹æ³¨è§„æ¨¡ï¼Œä½†æ³¢åŠ¨ä»ç„¶å­˜åœ¨ã€‚ä¸‹æ³¨å‰åŠ¡å¿…ç¡®è®¤èµ”çŽ‡ï¼Œä¼˜åŠ¿ä¼šè¿…é€Ÿæ¶ˆå¤±ã€‚',
        summary_title: 'æ¦‚è§ˆ',
        summary_profit: 'æ½œåœ¨æ€»åˆ©æ¶¦ï¼š{profit}{staked}',
        summary_profit_staked: 'ï¼ˆæ€»ä¸‹æ³¨ {staked}ï¼‰',
        summary_commission: 'å·²è®¡å…¥äº¤æ˜“æ‰€æ‰‹ç»­è´¹ï¼š{commission}ã€‚',
        summary_roi_note: 'ROI ä¸ºæ€»ä¸‹æ³¨å›žæŠ¥çŽ‡ã€‚2% ROI æ„å‘³ç€ä¸‹æ³¨ $100 çº¦ç›ˆåˆ© $2ã€‚',
        filters_applied: 'ç­›é€‰åŽæ˜¾ç¤º {shown}/{total} ä¸ªæœºä¼šã€‚',
        middle_summary_counts: 'ç¬¦åˆç­›é€‰çš„ä¸­é—´ç›˜ï¼š{count}ï¼Œå…¶ä¸­ {positive} ä¸ºæ­£ EVã€‚',
        middle_summary_avg: 'å¹³å‡ EVï¼š{avg}{best}',
        middle_summary_best: ' | æœ€ä½³ï¼š{event}',
        middle_spreads_only: 'ä»…è®©åˆ†',
        plus_summary: '+EV æŠ•æ³¨ï¼š{count} | å¹³å‡ Edge {avg}{best}',
        plus_summary_best: ' | æœ€ä½³ï¼š{event}',
        results_count: '{count} æ¡ç»“æžœ',
        results_profit: '{count} æ¡ç»“æžœ | åˆ©æ¶¦ {profit}',
        partial_results: '<strong>éƒ¨åˆ†ç»“æžœï¼š</strong>ä»¥ä¸‹é¡¹ç›®æœªèƒ½èŽ·å–èµ”çŽ‡ï¼š{details}ã€‚',
        market_skips: '<strong>å·²è·³è¿‡ç›˜å£ï¼š</strong>{details}ã€‚',
        tbd: 'å¾…å®š',
        gross: 'æ€»',
        net_at: 'å‡€ @ {odds}',
        odds_label: 'èµ”çŽ‡ï¼š{odds}',
        available_label: 'å¯ä¸‹é¢åº¦ï¼š{amount}',
        stake_label: 'ä¸‹æ³¨ï¼š{stake}',
        exchange: 'äº¤æ˜“æ‰€',
        no: 'å¦',
        no_data: 'æš‚æ— æ•°æ®',
        open_books: 'æ‰“å¼€',
        open_books_missing: 'æš‚æ— å¯æ‰“å¼€çš„å¹³å°é“¾æŽ¥ã€‚',
        open_books_blocked: 'å¼¹çª—è¢«æ‹¦æˆªï¼Œè¯·å…è®¸å¼¹çª—åŽé‡è¯•ã€‚',
        gap_points: '{points} åˆ†',
        gap_separator: ' / ',
        kelly_roll: '{percent}% èµ„é‡‘',
        net_roi_negative: 'è®¡å…¥æ‰‹ç»­è´¹åŽå‡€ ROI ä¸ºè´Ÿã€‚',
        scan_complete: 'æ‰«æå®Œæˆï¼š{time}',
        scan_failed: 'æ‰«æå¤±è´¥',
        settings_saved: 'è®¾ç½®å·²ä¿å­˜',
        enter_api_key: 'è¯·è¾“å…¥ API å¯†é’¥ã€‚',
        select_region: 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåœ°åŒºã€‚',
        select_bookmakers: 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¹³å°ã€‚',
        unknown: 'æœªçŸ¥',
        unknown_error: 'æœªçŸ¥é”™è¯¯',
      },
    };

    const SPORT_KEY_LABELS = {
      zh: {
        americanfootball_nfl: 'NFL',
        basketball_nba: 'NBA',
        baseball_mlb: 'MLB',
        icehockey_nhl: 'NHL',
        soccer_epl: 'è‹±è¶…',
        soccer_spain_la_liga: 'è¥¿ç”²',
        soccer_germany_bundesliga: 'å¾·ç”²',
        soccer_italy_serie_a: 'æ„ç”²',
        soccer_france_ligue_one: 'æ³•ç”²',
        soccer_usa_mls: 'ç¾ŽèŒè”',
      },
    };

    const SPORT_LABELS = {
      zh: {
        NFL: 'NFL',
        NBA: 'NBA',
        MLB: 'MLB',
        NHL: 'NHL',
        'Premier League': 'è‹±è¶…',
        'La Liga': 'è¥¿ç”²',
        Bundesliga: 'å¾·ç”²',
        'Serie A': 'æ„ç”²',
        'Ligue 1': 'æ³•ç”²',
        MLS: 'ç¾ŽèŒè”',
        Other: 'å…¶ä»–',
      },
    };

    const REGION_LABELS = {
      zh: {
        us: 'ç¾Žå›½',
        us2: 'ç¾Žå›½ï¼ˆæ›´å¤šï¼‰',
        uk: 'è‹±å›½',
        eu: 'æ¬§æ´²',
        au: 'æ¾³å¤§åˆ©äºš',
      },
    };

    const MARKET_LABELS = {
      zh: {
        h2h: 'èƒœè´Ÿ',
        spreads: 'è®©åˆ†',
        totals: 'å¤§å°åˆ†',
      },
    };

    let activeLanguage = localStorage.getItem('edge-language') || appConfig.defaultLanguage;
    if (!activeLanguage) {
      activeLanguage = (navigator.language || '').toLowerCase().startsWith('zh') ? 'zh' : 'en';
    }
    let activeLocale = activeLanguage === 'zh' ? 'zh-CN' : 'en-US';
    currencyFormatter = createCurrencyFormatter(activeLocale);
    document.documentElement.dataset.density = densityMode;

    function t(key, params = {}) {
      const table = TRANSLATIONS[activeLanguage] || TRANSLATIONS.en || {};
      const fallback = TRANSLATIONS.en || {};
      let template = table[key] ?? fallback[key] ?? key;
      Object.entries(params).forEach(([name, value]) => {
        template = template.replace(new RegExp(`\\{${name}\\}`, 'g'), () => String(value));
      });
      return template;
    }

    function createCurrencyFormatter(locale) {
      return new Intl.NumberFormat(locale, { style: 'currency', currency: 'USD' });
    }

    function applyTranslations() {
      document.documentElement.lang = activeLocale;
      document.querySelectorAll('[data-i18n]').forEach((el) => {
        const key = el.dataset.i18n;
        el.textContent = t(key);
      });
      document.querySelectorAll('[data-i18n-html]').forEach((el) => {
        const key = el.dataset.i18nHtml;
        el.innerHTML = t(key);
      });
      if (themeToggle) {
        themeToggle.title = t('toggle_theme');
      }
      if (closeAdvancedBtn) {
        closeAdvancedBtn.setAttribute('aria-label', t('close'));
      }
      if (languageToggle) {
        languageToggle.setAttribute('aria-label', t('toggle_language'));
      }
      if (densityToggle) {
        densityToggle.setAttribute('aria-label', t('toggle_density'));
      }
      updateLanguageToggle();
      updateOddsToggle();
      updateDensityToggle();
      updateSportLabels();
      updateRegionLabels();
      updateKellyOptions();
      updateThemeToggleText();
      updateToggleKeyLabel();
      updateAdvancedSummary();
      updateScanButtonText();
      updateArbSortLabel();
      updateMiddlesSortLabel();
      updatePlusEvSortLabel();
      refreshStatus();
      setActiveTab(activeTab);
      applyScanStatus(scanStatusChip ? scanStatusChip.dataset.status : 'idle');
      updateScanMeta(lastScanData);
      refreshScanLivePanel();
      if (isScanning) {
        refreshScanningFeedback(true);
      }
      renderPartialWarning(lastScanData);
      renderArbCalculator();
    }

    function setLanguage(nextLang) {
      const normalized = TRANSLATIONS[nextLang] ? nextLang : 'en';
      if (normalized === activeLanguage) return;
      activeLanguage = normalized;
      activeLocale = activeLanguage === 'zh' ? 'zh-CN' : 'en-US';
      localStorage.setItem('edge-language', activeLanguage);
      currencyFormatter = createCurrencyFormatter(activeLocale);
      applyTranslations();
      renderPartialWarning(lastScanData);
    }

    function updateLanguageToggle() {
      if (!languageToggle) return;
      languageToggle.querySelectorAll('span').forEach((span) => {
        span.classList.toggle('active', span.dataset.lang === activeLanguage);
      });
    }

    function updateDensityToggle() {
      if (!densityToggle) return;
      densityToggle.querySelectorAll('span').forEach((span) => {
        span.classList.toggle('active', span.dataset.density === densityMode);
      });
      document.documentElement.dataset.density = densityMode;
    }

    function updateScanButtonText() {
      if (!scanBtn) return;
      scanBtn.textContent = isScanning ? t('scanning') : t('scan_now');
    }

    function updateThemeToggleText() {
      if (!themeToggle) return;
      const current = document.documentElement.dataset.theme || 'light';
      const key = current === 'dark' ? 'theme_dark' : 'theme_light';
      themeToggle.textContent = t(key);
    }

    function updateToggleKeyLabel() {
      if (!toggleKeyBtn || !apiKeyInput) return;
      const key = apiKeyInput.type === 'password' ? 'api_key_show' : 'api_key_hide';
      toggleKeyBtn.setAttribute('aria-label', t(key));
      const shortKey = apiKeyInput.type === 'password' ? 'show_short' : 'hide_short';
      toggleKeyBtn.textContent = t(shortKey);
    }

    function collectCheckedLabels(name) {
      if (!form) return [];
      return Array.from(form.querySelectorAll(`input[name="${name}"]:checked`))
        .map((input) => {
          const label = input.closest('label');
          const span = label ? label.querySelector('span') : null;
          return (span ? span.textContent : input.value || '').trim();
        })
        .filter(Boolean);
    }

    function updateAdvancedSummary() {
      if (!advancedSummary || !form) return;
      const sportsLabels = collectCheckedLabels('sports');
      const booksLabels = collectCheckedLabels('bookmakers');
      const regionLabels = collectCheckedLabels('regions');
      const sportsSelected = sportsLabels.length;
      const booksSelected = booksLabels.length;
      const regionsSelected = regionLabels.length;
      const sportsText = allSportsToggle && allSportsToggle.checked ? t('summary_all') : sportsSelected;
      const booksText = allBookmakersToggle && allBookmakersToggle.checked ? t('summary_all') : booksSelected;
      const regionsText = regionsSelected;
      advancedSummary.textContent = t('advanced_summary', {
        sports: sportsText,
        books: booksText,
        regions: regionsText,
      });
      const sportsDetail =
        allSportsToggle && allSportsToggle.checked
          ? t('summary_all')
          : sportsLabels.length
            ? sportsLabels.join(', ')
            : '0';
      const booksDetail =
        allBookmakersToggle && allBookmakersToggle.checked
          ? t('summary_all')
          : booksLabels.length
            ? booksLabels.join(', ')
            : '0';
      const regionsDetail = regionLabels.length ? regionLabels.join(', ') : '0';
      advancedSummary.title = `${t('sports_label')}: ${sportsDetail}\n${t('bookmakers_label')}: ${booksDetail}\n${t('regions_label')}: ${regionsDetail}`;
    }

    function getOpportunityCount(section) {
      if (!section) return 0;
      if (typeof section.opportunities_count === 'number') return section.opportunities_count;
      if (Array.isArray(section.opportunities)) return section.opportunities.length;
      return 0;
    }

    function playNotificationSound() {
      if (!notifySoundToggle || !notifySoundToggle.checked) return;
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) return;
      if (!notificationAudioContext) {
        notificationAudioContext = new AudioContextClass();
      }
      const context = notificationAudioContext;
      if (context.state === 'suspended') {
        context.resume().catch(() => {});
      }
      const oscillator = context.createOscillator();
      const gain = context.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gain.gain.setValueAtTime(0.0001, context.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.2, context.currentTime + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + 0.3);
      oscillator.connect(gain);
      gain.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime + 0.35);
    }

    async function requestNotificationPermission() {
      if (!('Notification' in window)) return 'unsupported';
      if (Notification.permission === 'granted') return 'granted';
      if (Notification.permission === 'denied') return 'denied';
      try {
        return await Notification.requestPermission();
      } catch (error) {
        return 'denied';
      }
    }

    function reconcileNotificationToggles() {
      if (!notifyPopupToggle) return;
      if (!('Notification' in window)) {
        notifyPopupToggle.checked = false;
        notifyPopupToggle.disabled = true;
        return;
      }
      if (Notification.permission === 'denied') {
        notifyPopupToggle.checked = false;
      }
    }

    function notifyScanComplete(payload) {
      if (!payload) return;
      playNotificationSound();
      if (!notifyPopupToggle || !notifyPopupToggle.checked) return;
      if (!('Notification' in window) || Notification.permission !== 'granted') return;
      const title = t('scan_complete', { time: formatTime(payload.scan_time) });
      const body = t('notify_body', {
        arb: getOpportunityCount(payload.arbitrage),
        middle: getOpportunityCount(payload.middles),
        plus: getOpportunityCount(payload.plus_ev),
      });
      try {
        new Notification(title, { body });
      } catch (error) {
        return;
      }
    }

    function updateSportLabels() {
      document.querySelectorAll('[data-sport-key]').forEach((el) => {
        if (!el.dataset.defaultLabel) {
          el.dataset.defaultLabel = el.textContent.trim();
        }
        const key = el.dataset.sportKey;
        const fallback = el.dataset.defaultLabel;
        const translated = translateSportKey(key, fallback);
        el.textContent = translated;
      });
    }

    function updateRegionLabels() {
      document.querySelectorAll('[data-region-key]').forEach((el) => {
        if (!el.dataset.defaultLabel) {
          el.dataset.defaultLabel = el.textContent.trim();
        }
        const key = el.dataset.regionKey;
        const fallback = el.dataset.defaultLabel;
        const translated = translateRegionKey(key, fallback);
        el.textContent = translated;
      });
    }

    function updateKellyOptions() {
      if (!kellySelect) return;
      kellySelect.querySelectorAll('option[data-kelly-value]').forEach((option) => {
        const value = parseFloat(option.dataset.kellyValue);
        let key = 'kelly_tenth';
        if (value === 1) key = 'kelly_full';
        else if (value === 0.5) key = 'kelly_half';
        else if (value === 0.25) key = 'kelly_quarter';
        option.textContent = t(key);
      });
    }

    function translateSportKey(key, fallback) {
      if (activeLanguage !== 'zh') return fallback;
      const map = SPORT_KEY_LABELS[activeLanguage] || {};
      return map[key] || fallback;
    }

    function translateSportLabel(label) {
      if (!label || activeLanguage !== 'zh') return label || '';
      const map = SPORT_LABELS[activeLanguage] || {};
      return map[label] || label;
    }

    function translateRegionKey(key, fallback) {
      if (activeLanguage !== 'zh') return fallback;
      const map = REGION_LABELS[activeLanguage] || {};
      return map[key] || fallback;
    }

    function translateMarketLabel(market) {
      if (!market || activeLanguage !== 'zh') return market || '';
      const map = MARKET_LABELS[activeLanguage] || {};
      return map[market] || market;
    }

    function formatDateTime(value) {
      if (!value) return t('tbd');
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return t('tbd');
      return date.toLocaleString(activeLocale);
    }

    function formatTime(value) {
      if (!value) return t('tbd');
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return t('tbd');
      return date.toLocaleTimeString(activeLocale);
    }

    function formatDurationMs(value) {
      const ms = Number(value);
      if (!Number.isFinite(ms) || ms < 0) return '-';
      if (ms >= 1000) {
        return `${(ms / 1000).toFixed(2)}s`;
      }
      return `${Math.round(ms)}ms`;
    }

    function formatSlowestStep(timings) {
      const steps = timings?.slowest_steps;
      if (!Array.isArray(steps) || !steps.length) return '-';
      const top = steps[0] || {};
      const label = top.label || top.name || '-';
      return `${label} (${formatDurationMs(top.ms)})`;
    }

    function buildScanContext(payload) {
      const sports = Array.isArray(payload?.sports) ? payload.sports : [];
      const regions = Array.isArray(payload?.regions) ? payload.regions : [];
      const books = Array.isArray(payload?.bookmakers) ? payload.bookmakers : [];
      const providers = Array.isArray(payload?.includeProviders) ? payload.includeProviders : [];
      return {
        sportsCount: sports.length,
        regionsCount: regions.length,
        booksCount: books.length,
        providersCount: providers.length,
        allSports: Boolean(payload?.allSports),
        allBookmakers: Boolean(payload?.allBookmakers),
        allMarkets: Boolean(payload?.allMarkets),
      };
    }

    function scopeCountLabel(count, allSelected) {
      if (allSelected) return t('scan_scope_all');
      if (!Number.isFinite(count) || count <= 0) return t('scan_scope_none');
      return String(count);
    }

    function formatScanScope(context) {
      if (!context) return '-';
      return t('scan_scope_summary', {
        sports: scopeCountLabel(context.sportsCount, context.allSports),
        regions: scopeCountLabel(context.regionsCount, false),
        books: scopeCountLabel(context.booksCount, context.allBookmakers),
        providers: scopeCountLabel(context.providersCount, false),
        markets: context.allMarkets ? t('scan_markets_extended') : t('scan_markets_core'),
      });
    }

    function refreshScanLivePanel() {
      if (!scanLiveElapsed || !scanLiveScope) return;
      if (!isScanning) {
        scanLiveElapsed.textContent = t('scan_live_elapsed', { elapsed: '-' });
        scanLiveScope.textContent = t('scan_live_scope', { details: '-' });
        return;
      }
      const elapsedMs = Math.max(0, Date.now() - scanStartedAtMs);
      const elapsedText = formatDurationMs(elapsedMs);
      if (scanDuration) scanDuration.textContent = elapsedText;
      scanLiveElapsed.textContent = t('scan_live_elapsed', { elapsed: elapsedText });
      scanLiveScope.textContent = t('scan_live_scope', { details: formatScanScope(activeScanContext) });
    }

    function refreshScanningFeedback(force = false) {
      if (!isScanning) return;
      const elapsedMs = Math.max(0, Date.now() - scanStartedAtMs);
      const elapsedText = formatDurationMs(elapsedMs);
      refreshScanLivePanel();
      let key = 'scanning_wait_elapsed';
      let type = null;
      if (elapsedMs >= 30000) {
        key = 'scan_wait_very_slow';
        type = 'warning';
      } else if (elapsedMs >= 10000) {
        key = 'scan_wait_slow';
        type = 'warning';
      }
      const elapsedSecond = Math.floor(elapsedMs / 1000);
      if (!force && key === scanLastStatusKey && elapsedSecond === scanLastElapsedSecond) {
        return;
      }
      showStatusKey(key, type, { elapsed: elapsedText });
      scanLastStatusKey = key;
      scanLastElapsedSecond = elapsedSecond;
    }

    function setScanInputLock(locked) {
      if (!scanLockedControls.length) {
        const selectors = [
          'input[name="sports"]',
          'input[name="regions"]',
          'input[name="bookmakers"]',
          '[data-quick-action][data-quick-target="regions"]',
          '[data-quick-action][data-quick-target="sports"]',
          '[data-quick-action][data-quick-target="bookmakers"]',
          '#all-sports',
          '#all-markets',
          '#all-bookmakers',
          '#stake-input',
          '#commission-input',
          '#api-key',
          '#auto-scan-toggle',
          '#auto-scan-interval',
          '#sharp-book-select',
          '#min-edge-input',
          '#bankroll-input',
          '#kelly-select',
        ];
        const seen = new Set();
        selectors.forEach((selector) => {
          document.querySelectorAll(selector).forEach((element) => {
            if (!(element instanceof HTMLElement) || element === scanBtn || seen.has(element)) {
              return;
            }
            seen.add(element);
            scanLockedControls.push(element);
          });
        });
      }

      scanLockedControls.forEach((element) => {
        if (!('disabled' in element)) return;
        if (locked) {
          if (!scanControlDisabledState.has(element)) {
            scanControlDisabledState.set(element, Boolean(element.disabled));
          }
          element.disabled = true;
          return;
        }
        if (!scanControlDisabledState.has(element)) return;
        element.disabled = scanControlDisabledState.get(element);
        scanControlDisabledState.delete(element);
      });

      if (!locked) {
        updateBookmakerState();
        updateQuickActionState();
      }
    }

    function refreshStatus() {
      if (!lastStatus) return;
      const { key, params, type, message } = lastStatus;
      if (key) {
        statusEl.textContent = t(key, params);
      } else if (message !== undefined) {
        statusEl.textContent = message;
      }
      statusEl.className = type ? `status ${type}` : 'status';
    }

    function statusKeyForState(state) {
      switch (state) {
        case 'ready':
          return 'status_ready';
        case 'scanning':
          return 'status_scanning';
        case 'error':
          return 'status_error';
        case 'partial':
          return 'status_partial';
        case 'idle':
        default:
          return 'status_idle';
      }
    }

    function applyScanStatus(state) {
      if (!scanStatusChip || !scanStatusText) return;
      const normalized = state || 'idle';
      scanStatusChip.dataset.status = normalized;
      scanStatusText.textContent = t(statusKeyForState(normalized));
    }

    function updateScanMeta(payload) {
      if (!scanLastTime || !scanApiCalls || !scanEvents || !scanSports) return;
      if (!payload || !payload.arbitrage?.summary) {
        scanLastTime.textContent = '-';
        scanApiCalls.textContent = '-';
        if (scanDuration) scanDuration.textContent = '-';
        if (scanSlowest) scanSlowest.textContent = '-';
        scanEvents.textContent = '-';
        scanSports.textContent = '-';
        return;
      }
      const summary = payload.arbitrage.summary;
      scanLastTime.textContent = formatDateTime(payload.scan_time);
      scanApiCalls.textContent = summary.api_calls_used ?? '-';
      if (scanDuration) scanDuration.textContent = formatDurationMs(payload?.timings?.total_ms);
      if (scanSlowest) scanSlowest.textContent = formatSlowestStep(payload?.timings);
      scanEvents.textContent = summary.events_scanned ?? '-';
      scanSports.textContent = summary.sports_scanned ?? '-';
    }

    function updateArbSortLabel() {
      if (!arbSortLabel) return;
      const keyMap = {
        roi: 'sorted_by_roi',
        profit: 'sorted_by_profit',
        time: 'sorted_by_time',
      };
      const sortKey = arbitrageSortSelect ? arbitrageSortSelect.value || 'roi' : 'roi';
      arbSortLabel.textContent = t(keyMap[sortKey] || 'sorted_by_roi');
    }

    function updateMiddlesSortLabel() {
      if (!middlesSortLabel) return;
      const keyMap = {
        ev: 'sorted_by_ev',
        probability: 'sorted_by_probability',
        gap: 'sorted_by_gap',
        time: 'sorted_by_time',
      };
      const sortKey = middleSortSelect.value || 'ev';
      middlesSortLabel.textContent = t(keyMap[sortKey] || 'sorted_by_ev');
    }

    function updatePlusEvSortLabel() {
      if (!plusEvSortLabel) return;
      const keyMap = {
        edge: 'sorted_by_edge',
        ev: 'sorted_by_ev_value',
        kelly: 'sorted_by_kelly',
        time: 'sorted_by_time',
      };
      const sortKey = plusEvSortSelect.value || 'edge';
      plusEvSortLabel.textContent = t(keyMap[sortKey] || 'sorted_by_edge');
    }

    document.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('arb-theme');
      if (savedTheme) {
        document.documentElement.dataset.theme = savedTheme;
      } else if (appConfig.defaultTheme) {
        document.documentElement.dataset.theme = appConfig.defaultTheme;
      }
      applyTranslations();
      loadSettings();
      reconcileNotificationToggles();
      updateBookmakerState();
      syncBookmakerLinksFromInputs();
    });

    if (toggleKeyBtn && apiKeyInput) {
      toggleKeyBtn.addEventListener('click', () => {
        if (apiKeyInput.type === 'password') {
          apiKeyInput.type = 'text';
        } else {
          apiKeyInput.type = 'password';
        }
        updateToggleKeyLabel();
      });
    }

    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.dataset.theme || 'light';
      const next = current === 'light' ? 'dark' : 'light';
      document.documentElement.dataset.theme = next;
      localStorage.setItem('arb-theme', next);
      updateThemeToggleText();
    });

    if (oddsToggle) {
      oddsToggle.addEventListener('click', () => {
        oddsFormat = oddsFormat === 'decimal' ? 'american' : 'decimal';
        localStorage.setItem('edge-odds-format', oddsFormat);
        updateOddsToggle();
        renderArbitrage();
        renderMiddles();
        renderPlusEv();
      });
    }

    if (languageToggle) {
      languageToggle.addEventListener('click', (event) => {
        const target = event.target;
        const selected = target && target.dataset ? target.dataset.lang : null;
        const nextLang = selected || (activeLanguage === 'en' ? 'zh' : 'en');
        setLanguage(nextLang);
      });
    }

    if (densityToggle) {
      densityToggle.addEventListener('click', (event) => {
        const target = event.target;
        const selected = target && target.dataset ? target.dataset.density : null;
        densityMode = selected || (densityMode === 'comfort' ? 'compact' : 'comfort');
        localStorage.setItem('edge-density', densityMode);
        updateDensityToggle();
      });
    }

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        const target = tab.dataset.tab;
        if (target && target !== activeTab) {
          setActiveTab(target);
        }
      });
    });

    function updateQuickActionState() {
      if (!quickActionButtons || !quickActionButtons.length) return;
      quickActionButtons.forEach((button) => {
        const target = button.dataset.quickTarget;
        if (target === 'bookmakers' && allBookmakersToggle) {
          button.disabled = allBookmakersToggle.checked;
          return;
        }
        if (target === 'sports' && allSportsToggle) {
          button.disabled = allSportsToggle.checked;
          return;
        }
        button.disabled = false;
      });
    }

    function applyQuickAction(target, action) {
      if (!form || !target || !action) return;
      const boxes = form.querySelectorAll(`input[name="${target}"]`);
      if (!boxes.length) return;
      if (target === 'sports' && allSportsToggle) {
        allSportsToggle.checked = false;
      }
      if (target === 'bookmakers' && allBookmakersToggle) {
        allBookmakersToggle.checked = false;
        updateBookmakerState();
      }
      const shouldCheck = action === 'select';
      boxes.forEach((box) => {
        if (box.disabled) return;
        box.checked = shouldCheck;
      });
      updateAdvancedSummary();
      updateQuickActionState();
    }

    function updateBookmakerState() {
      if (!allBookmakersToggle) return;
      const useAll = allBookmakersToggle.checked;
      const boxes = form ? form.querySelectorAll('input[name="bookmakers"]') : [];
      boxes.forEach((box) => {
        box.disabled = useAll;
      });
      if (bookmakersList) {
        bookmakersList.classList.toggle('is-disabled', useAll);
      }
      updateQuickActionState();
    }

    if (allBookmakersToggle) {
      allBookmakersToggle.addEventListener('change', updateBookmakerState);
    }

    if (allSportsToggle) {
      allSportsToggle.addEventListener('change', updateQuickActionState);
    }

    if (quickActionButtons && quickActionButtons.length) {
      quickActionButtons.forEach((button) => {
        button.addEventListener('click', () => {
          applyQuickAction(button.dataset.quickTarget, button.dataset.quickAction);
        });
      });
    }

    if (notifyPopupToggle) {
      notifyPopupToggle.addEventListener('change', async () => {
        if (!notifyPopupToggle.checked) return;
        const permission = await requestNotificationPermission();
        if (permission !== 'granted') {
          notifyPopupToggle.checked = false;
        }
      });
    }

    function getFocusableElements(container) {
      if (!container) return [];
      const selector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])';
      return Array.from(container.querySelectorAll(selector)).filter((el) => !el.disabled);
    }

    function handleModalKeydown(event) {
      if (event.key !== 'Tab') return;
      const focusables = getFocusableElements(advancedModal);
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      if (event.shiftKey && document.activeElement === first) {
        event.preventDefault();
        last.focus();
      } else if (!event.shiftKey && document.activeElement === last) {
        event.preventDefault();
        first.focus();
      }
    }

    function openAdvancedModal() {
      if (!advancedModal) return;
      lastFocusedElement = document.activeElement;
      advancedModal.classList.remove('hidden');
      advancedModal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('modal-open');
      if (openAdvancedBtn) {
        openAdvancedBtn.setAttribute('aria-expanded', 'true');
      }
      advancedModal.addEventListener('keydown', handleModalKeydown);
      const focusables = getFocusableElements(advancedModal);
      const focusTarget = (closeAdvancedBtn || focusables[0]);
      if (focusTarget && focusTarget.focus) {
        focusTarget.focus();
      }
    }

    function closeAdvancedModal() {
      if (!advancedModal) return;
      advancedModal.classList.add('hidden');
      advancedModal.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('modal-open');
      advancedModal.removeEventListener('keydown', handleModalKeydown);
      if (openAdvancedBtn) {
        openAdvancedBtn.setAttribute('aria-expanded', 'false');
      }
      if (lastFocusedElement && lastFocusedElement.focus) {
        lastFocusedElement.focus();
      }
    }

    if (openAdvancedBtn) {
      openAdvancedBtn.addEventListener('click', openAdvancedModal);
    }

    if (closeAdvancedBtn) {
      closeAdvancedBtn.addEventListener('click', closeAdvancedModal);
    }

    if (advancedModal) {
      advancedModal.addEventListener('click', (event) => {
        const target = event.target;
        if (target && target.dataset && target.dataset.close === 'modal') {
          closeAdvancedModal();
        }
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && advancedModal && !advancedModal.classList.contains('hidden')) {
        closeAdvancedModal();
      }
    });

    if (form) {
      form.addEventListener('change', (event) => {
        const target = event.target;
        if (!target || !target.matches) return;
        if (
          target.matches('input[name="sports"]') ||
          target.matches('input[name="bookmakers"]') ||
          target.matches('input[name="regions"]') ||
          target.id === 'all-sports' ||
          target.id === 'all-bookmakers'
        ) {
          updateAdvancedSummary();
        }
      });
    }

    if (bookmakerLinksList) {
      bookmakerLinksList.addEventListener('input', () => {
        syncBookmakerLinksFromInputs();
      });
    }

    function setCheckboxGroup(name, values) {
      if (!Array.isArray(values)) return;
      const boxes = form ? form.querySelectorAll(`input[name="${name}"]`) : [];
      const selected = new Set(values);
      boxes.forEach((box) => {
        box.checked = selected.has(box.value);
      });
    }

    function getBookmakerLinkInputs() {
      if (!bookmakerLinksList) return [];
      return Array.from(bookmakerLinksList.querySelectorAll('input[data-bookmaker-key]'));
    }

    function collectBookmakerLinks() {
      const inputs = getBookmakerLinkInputs();
      const links = {};
      inputs.forEach((input) => {
        const key = input.dataset.bookmakerKey;
        if (!key) return;
        links[key] = (input.value || '').trim();
      });
      return links;
    }

    function syncBookmakerLinksFromInputs() {
      const inputs = getBookmakerLinkInputs();
      const next = { ...(appConfig.bookmakerLinks || {}) };
      inputs.forEach((input) => {
        const key = input.dataset.bookmakerKey;
        if (!key) return;
        const value = (input.value || '').trim();
        if (value) {
          next[key] = value;
        } else {
          delete next[key];
        }
      });
      bookmakerLinks = next;
    }

    function readAutoScanMinutes() {
      if (!autoScanIntervalInput) return 10;
      const value = parseFloat(autoScanIntervalInput.value);
      if (!Number.isFinite(value) || value <= 0) return 10;
      return value;
    }

    function selectedRegions() {
      return Array.from(form?.querySelectorAll('input[name="regions"]:checked') || []).map((el) => el.value);
    }

    function selectedBookmakers(useAllBookmakers) {
      if (useAllBookmakers) {
        return Array.from(form?.querySelectorAll('input[name="bookmakers"]') || []).map((el) => el.value);
      }
      return Array.from(form?.querySelectorAll('input[name="bookmakers"]:checked') || []).map((el) => el.value);
    }

    function selectedIncludeProviders(useAllBookmakers, bookmakers) {
      if (useAllBookmakers) return Array.from(appConfig.customProviderKeys || []);
      const providerSet = new Set(appConfig.customProviderKeys || []);
      const picked = [];
      for (const key of bookmakers || []) {
        if (!providerSet.has(key)) continue;
        if (!picked.includes(key)) picked.push(key);
      }
      return picked;
    }

    function triggerAutoScan() {
      if (isScanning) return;
      if (!hasEnvKey && !apiKeyInput?.value.trim()) return;
      const sports = Array.from(form?.querySelectorAll('input[name="sports"]:checked') || []).map((el) => el.value);
      const useAllSports = allSportsToggle ? allSportsToggle.checked : false;
      if (!useAllSports && !sports.length) return;
      const regions = selectedRegions();
      if (!regions.length) return;
      const useAllBookmakers = allBookmakersToggle ? allBookmakersToggle.checked : true;
      const bookmakers = selectedBookmakers(useAllBookmakers);
      const includeProviders = selectedIncludeProviders(useAllBookmakers, bookmakers);
      if (!useAllBookmakers && !bookmakers.length) return;
      const stakeValue = parseFloat(stakeInput?.value) || 100;
      const commissionValue = commissionInput && Number.isFinite(parseFloat(commissionInput.value))
        ? parseFloat(commissionInput.value)
        : defaultCommissionPercent;
      runScan({
        apiKey: apiKeyInput ? apiKeyInput.value.trim() : '',
        sports,
        bookmakers,
        includeProviders,
        regions,
        commission: commissionValue,
        allSports: useAllSports,
        allBookmakers: useAllBookmakers,
        allMarkets: allMarketsToggle ? allMarketsToggle.checked : Boolean(appConfig.defaultAllMarkets),
        stake: stakeValue,
        sharpBook: sharpSelect?.value || appConfig.defaultSharpBook,
        minEdgePercent: parseFloat(minEdgeInput?.value) || appConfig.defaultMinEdgePercent || 1,
        bankroll: parseFloat(bankrollInput?.value) || appConfig.defaultBankroll || 1000,
        kellyFraction: parseFloat(kellySelect?.value) || appConfig.defaultKellyFraction || 0.25,
      });
    }

    function configureAutoScan() {
      if (!autoScanToggle) return;
      if (autoScanTimer) {
        clearInterval(autoScanTimer);
        autoScanTimer = null;
      }
      if (!autoScanToggle.checked) return;
      const minutes = readAutoScanMinutes();
      if (autoScanIntervalInput) {
        autoScanIntervalInput.value = String(minutes);
      }
      autoScanTimer = setInterval(triggerAutoScan, minutes * 60 * 1000);
    }

    function applyBookmakerLinks(values) {
      if (!values) {
        syncBookmakerLinksFromInputs();
        return;
      }
      const inputs = getBookmakerLinkInputs();
      inputs.forEach((input) => {
        const key = input.dataset.bookmakerKey;
        if (!key) return;
        if (Object.prototype.hasOwnProperty.call(values, key)) {
          input.value = values[key] || '';
        }
      });
      syncBookmakerLinksFromInputs();
    }

    function collectSettings() {
      const sports = Array.from(form?.querySelectorAll('input[name="sports"]:checked') || []).map((el) => el.value);
      const regions = selectedRegions();
      const bookmakers = Array.from(form?.querySelectorAll('input[name="bookmakers"]:checked') || []).map((el) => el.value);
      return {
        stake: stakeInput ? stakeInput.value : '',
        commission: commissionInput ? commissionInput.value : '',
        allSports: allSportsToggle ? allSportsToggle.checked : false,
        allMarkets: allMarketsToggle ? allMarketsToggle.checked : Boolean(appConfig.defaultAllMarkets),
        sports,
        regions,
        allBookmakers: allBookmakersToggle ? allBookmakersToggle.checked : true,
        bookmakers,
        minRoi: minRoiInput ? minRoiInput.value : '',
        arbitrageSort: arbitrageSortSelect ? arbitrageSortSelect.value : '',
        minGap: minGapInput ? minGapInput.value : '',
        positiveEvOnly: positiveEvToggle ? positiveEvToggle.checked : false,
        middleSort: middleSortSelect ? middleSortSelect.value : '',
        sharpBook: sharpSelect ? sharpSelect.value : '',
        minEdge: minEdgeInput ? minEdgeInput.value : '',
        bankroll: bankrollInput ? bankrollInput.value : '',
        kellyFraction: kellySelect ? kellySelect.value : '',
        plusEvSort: plusEvSortSelect ? plusEvSortSelect.value : '',
        activeTab,
        bookmakerUrls: collectBookmakerLinks(),
        autoScanEnabled: autoScanToggle ? autoScanToggle.checked : false,
        autoScanMinutes: autoScanIntervalInput ? autoScanIntervalInput.value : '',
        notifySoundEnabled: notifySoundToggle ? notifySoundToggle.checked : false,
        notifyPopupEnabled: notifyPopupToggle ? notifyPopupToggle.checked : false,
      };
    }

    function applySettings(settings) {
      if (!settings) return;
      if (stakeInput && settings.stake !== undefined) stakeInput.value = settings.stake;
      if (commissionInput && settings.commission !== undefined) commissionInput.value = settings.commission;
      if (allSportsToggle && settings.allSports !== undefined) allSportsToggle.checked = Boolean(settings.allSports);
      if (allMarketsToggle && settings.allMarkets !== undefined) allMarketsToggle.checked = Boolean(settings.allMarkets);
      setCheckboxGroup('sports', settings.sports);
      setCheckboxGroup('regions', settings.regions);
      if (allBookmakersToggle && settings.allBookmakers !== undefined) {
        allBookmakersToggle.checked = Boolean(settings.allBookmakers);
      }
      setCheckboxGroup('bookmakers', settings.bookmakers);
      if (minRoiInput && settings.minRoi !== undefined) minRoiInput.value = settings.minRoi;
      if (arbitrageSortSelect && settings.arbitrageSort) arbitrageSortSelect.value = settings.arbitrageSort;
      if (minGapInput && settings.minGap !== undefined) minGapInput.value = settings.minGap;
      if (positiveEvToggle && settings.positiveEvOnly !== undefined) positiveEvToggle.checked = settings.positiveEvOnly;
      if (middleSortSelect && settings.middleSort) middleSortSelect.value = settings.middleSort;
      if (sharpSelect && settings.sharpBook) sharpSelect.value = settings.sharpBook;
      if (minEdgeInput && settings.minEdge !== undefined) minEdgeInput.value = settings.minEdge;
      if (bankrollInput && settings.bankroll !== undefined) bankrollInput.value = settings.bankroll;
      if (kellySelect && settings.kellyFraction !== undefined) kellySelect.value = settings.kellyFraction;
      if (plusEvSortSelect && settings.plusEvSort) plusEvSortSelect.value = settings.plusEvSort;
      if (autoScanToggle && settings.autoScanEnabled !== undefined) {
        autoScanToggle.checked = Boolean(settings.autoScanEnabled);
      }
      if (autoScanIntervalInput && settings.autoScanMinutes !== undefined) {
        autoScanIntervalInput.value = settings.autoScanMinutes;
      }
      if (notifySoundToggle && settings.notifySoundEnabled !== undefined) {
        notifySoundToggle.checked = Boolean(settings.notifySoundEnabled);
      }
      if (notifyPopupToggle && settings.notifyPopupEnabled !== undefined) {
        notifyPopupToggle.checked = Boolean(settings.notifyPopupEnabled);
      }
      if (settings.activeTab) setActiveTab(settings.activeTab);
      if (settings.bookmakerUrls) {
        applyBookmakerLinks(settings.bookmakerUrls);
      } else {
        syncBookmakerLinksFromInputs();
      }
      configureAutoScan();
      updateBookmakerState();
      updateAdvancedSummary();
      updateQuickActionState();
      reconcileNotificationToggles();
    }

    function loadSettings() {
      const raw = localStorage.getItem('edge-scan-settings');
      if (!raw) return;
      try {
        const parsed = JSON.parse(raw);
        applySettings(parsed);
      } catch (err) {
        return;
      }
    }

    function persistSettings() {
      const payload = collectSettings();
      localStorage.setItem('edge-scan-settings', JSON.stringify(payload));
    }

    function saveSettings() {
      persistSettings();
      configureAutoScan();
      showStatusKey('settings_saved', 'success');
      closeAdvancedModal();
    }

    if (saveSettingsBtn) {
      saveSettingsBtn.addEventListener('click', saveSettings);
    }

    if (autoScanToggle) {
      autoScanToggle.addEventListener('change', configureAutoScan);
    }

    if (autoScanIntervalInput) {
      autoScanIntervalInput.addEventListener('change', configureAutoScan);
    }

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      if (!hasEnvKey && !apiKeyInput?.value.trim()) {
        showStatusKey('enter_api_key', 'error');
        return;
      }
      const sports = Array.from(form.querySelectorAll('input[name="sports"]:checked')).map((el) => el.value);
      const regions = selectedRegions();
      if (!regions.length) {
        showStatusKey('select_region', 'error');
        return;
      }
      const useAllBookmakers = allBookmakersToggle ? allBookmakersToggle.checked : true;
      const bookmakers = selectedBookmakers(useAllBookmakers);
      const includeProviders = selectedIncludeProviders(useAllBookmakers, bookmakers);
      if (!useAllBookmakers && !bookmakers.length) {
        showStatusKey('select_bookmakers', 'error');
        return;
      }
      const stakeValue = parseFloat(stakeInput.value) || 100;
      const commissionValue = commissionInput && Number.isFinite(parseFloat(commissionInput.value))
        ? parseFloat(commissionInput.value)
        : defaultCommissionPercent;
      await runScan({
        apiKey: apiKeyInput ? apiKeyInput.value.trim() : '',
        sports,
        regions,
        bookmakers,
        includeProviders,
        commission: commissionValue,
        allSports: allSportsToggle.checked,
        allBookmakers: useAllBookmakers,
        allMarkets: allMarketsToggle ? allMarketsToggle.checked : Boolean(appConfig.defaultAllMarkets),
        stake: stakeValue,
        sharpBook: sharpSelect?.value || appConfig.defaultSharpBook,
        minEdgePercent: parseFloat(minEdgeInput?.value) || appConfig.defaultMinEdgePercent || 1,
        bankroll: parseFloat(bankrollInput?.value) || appConfig.defaultBankroll || 1000,
        kellyFraction: parseFloat(kellySelect?.value) || appConfig.defaultKellyFraction || 0.25,
      });
    });

    stakeInput.addEventListener('input', () => {
      if (lastScanData) {
        renderArbitrage();
        renderMiddles();
      }
    });

    if (arbCalcAutoSplitBtn) {
      arbCalcAutoSplitBtn.addEventListener('click', () => rebalanceArbCalculator('total'));
    }
    if (arbCalcTotalInput) {
      arbCalcTotalInput.addEventListener('change', () => rebalanceArbCalculator('total'));
    }
    arbCalcLegRefs.forEach((leg, idx) => {
      if (leg.baseBtn) {
        leg.baseBtn.addEventListener('click', () => rebalanceArbCalculator(`base_${idx}`));
      }
      if (leg.oddsInput) {
        leg.oddsInput.addEventListener('change', () => {
          const mode = arbCalculatorState?.mode || 'total';
          rebalanceArbCalculator(mode);
        });
      }
      if (leg.stakeInput) {
        leg.stakeInput.addEventListener('change', () => {
          if (!arbCalculatorState) return;
          syncArbCalculatorStateFromInputs();
          const total = (arbCalculatorState.legs || []).reduce((sum, item) => sum + (item?.stake || 0), 0);
          arbCalculatorState.totalStake = roundMoney(total);
          renderArbCalculator();
        });
      }
    });

    if (minRoiInput) {
      minRoiInput.addEventListener('input', () => renderArbitrage());
      minRoiInput.addEventListener('change', () => persistSettings());
    }
    if (arbitrageSortSelect) arbitrageSortSelect.addEventListener('change', () => renderArbitrage());
    minGapInput.addEventListener('input', () => renderMiddles());
    positiveEvToggle.addEventListener('change', () => renderMiddles());
    middleSortSelect.addEventListener('change', () => renderMiddles());
    minEdgeInput.addEventListener('input', () => renderPlusEv());
    bankrollInput.addEventListener('input', () => renderPlusEv());
    kellySelect.addEventListener('change', () => renderPlusEv());
    plusEvSortSelect.addEventListener('change', () => renderPlusEv());

    async function runScan(payload) {
      setScanning(true, payload);
      try {
        const response = await fetch('/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: payload.apiKey,
            sports: payload.sports,
            allSports: payload.allSports,
            allMarkets: payload.allMarkets,
            stake: payload.stake,
            regions: payload.regions,
            bookmakers: payload.bookmakers,
            includeProviders: payload.includeProviders,
            commission: payload.commission,
            sharpBook: payload.sharpBook,
            minEdgePercent: payload.minEdgePercent,
            bankroll: payload.bankroll,
            kellyFraction: payload.kellyFraction,
          }),
        });
        const data = await response.json();
        if (!data.success) {
          throw new Error(data.error || t('scan_failed'));
        }
        if (data?.middles?.defaults) {
          const defaults = data.middles.defaults;
          if (defaults.min_gap !== undefined) minGapInput.value = defaults.min_gap;
          if (defaults.positive_only !== undefined) positiveEvToggle.checked = defaults.positive_only;
          if (defaults.sort) middleSortSelect.value = defaults.sort;
        }
        if (data?.plus_ev?.defaults) {
          const defaults = data.plus_ev.defaults;
          if (defaults.sharp_book) sharpSelect.value = defaults.sharp_book;
          if (defaults.min_edge_percent !== undefined) minEdgeInput.value = defaults.min_edge_percent;
          if (defaults.bankroll !== undefined) bankrollInput.value = defaults.bankroll;
          if (defaults.kelly_fraction !== undefined) kellySelect.value = defaults.kelly_fraction;
        }
        renderScanData(data);
        showStatusKey('scan_complete', 'success', { time: formatTime(data.scan_time) });
        notifyScanComplete(data);
      } catch (err) {
        showStatus(err.message || t('scan_failed'), 'error');
        renderScanData(null);
      } finally {
        setScanning(false);
      }
    }

    function setScanning(nextState, payload = null) {
      isScanning = nextState;
      scanBtn.disabled = nextState;
      updateScanButtonText();
      setScanInputLock(nextState);
      if (nextState) {
        activeScanContext = buildScanContext(payload || {});
        scanStartedAtMs = Date.now();
        scanLastStatusKey = '';
        scanLastElapsedSecond = -1;
        if (scanLive) {
          scanLive.classList.remove('hidden');
        }
        applyScanStatus('scanning');
        refreshScanningFeedback(true);
        if (scanFeedbackTimer) {
          clearInterval(scanFeedbackTimer);
        }
        scanFeedbackTimer = window.setInterval(() => {
          refreshScanningFeedback();
        }, 250);
        return;
      }

      if (scanFeedbackTimer) {
        clearInterval(scanFeedbackTimer);
        scanFeedbackTimer = null;
      }
      scanStartedAtMs = 0;
      scanLastStatusKey = '';
      scanLastElapsedSecond = -1;
      activeScanContext = null;
      if (scanLive) {
        scanLive.classList.add('hidden');
      }
      refreshScanLivePanel();

      const transientKeys = new Set([
        'scanning_wait',
        'scanning_wait_elapsed',
        'scan_wait_slow',
        'scan_wait_very_slow',
      ]);
      if (lastStatus && lastStatus.key && transientKeys.has(lastStatus.key)) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        lastStatus = null;
        return;
      }
      refreshStatus();
    }

    function showStatus(message, type, key = null, params = {}) {
      statusEl.textContent = message;
      statusEl.className = type ? `status ${type}` : 'status';
      lastStatus = { message, type, key, params };
    }

    function showStatusKey(key, type, params = {}) {
      showStatus(t(key, params), type, key, params);
    }

    function renderScanData(payload) {
      lastScanData = payload;
      clearArbCalculatorSelection();
      if (payload && typeof payload.commission_rate === 'number') {
        lastCommissionRate = payload.commission_rate;
      }
      renderArbitrage();
      renderMiddles();
      renderPlusEv();
      renderPartialWarning(payload);
      if (payload) {
        applyScanStatus(payload.partial ? 'partial' : 'ready');
      } else {
        applyScanStatus('error');
      }
      updateScanMeta(payload);
    }

    function renderArbitrage() {
      const arbData = lastScanData?.arbitrage;
      const opportunities = arbData?.opportunities || [];
      const stakeValue = parseFloat(stakeInput.value) || 0;
      const minRoiValue = minRoiInput ? minRoiInput.value : 0;
      const minRoi = Number.isFinite(parseFloat(minRoiValue)) ? parseFloat(minRoiValue) : 0;
      const sortKey = arbitrageSortSelect ? arbitrageSortSelect.value || 'roi' : 'roi';
      updateArbSortLabel();
      const prepared = opportunities.map((opp) => {
        const calcNet = calculateStakes(opp, stakeValue, true);
        const netRoi = calcNet?.roi_percent ?? opp.roi_percent ?? 0;
        const profitValue = calcNet?.guaranteed_profit ?? 0;
        const timeValue = opp.commence_time ? new Date(opp.commence_time).getTime() : 0;
        return {
          opp,
          calcNet,
          netRoi,
          profitValue,
          timeValue,
        };
      });
      const filtered = prepared.filter((item) => {
        if (item.netRoi < minRoi) return false;
        return true;
      });
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'profit':
            return (b.profitValue || 0) - (a.profitValue || 0);
          case 'time':
            return (a.timeValue || 0) - (b.timeValue || 0);
          case 'roi':
          default:
            return (b.netRoi || 0) - (a.netRoi || 0);
        }
      });
      let selectedVisible = false;
      resultsBody.innerHTML = '';
      tableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        emptyState.classList.remove('hidden');
      } else {
        emptyState.classList.add('hidden');
        let runningProfit = 0;
        filtered.forEach((entry) => {
          const opp = entry.opp;
          const row = document.createElement('tr');
          const calcNet = entry.calcNet;
          const netRoi = entry.netRoi;
          const oppKey = buildArbOpportunityKey(opp);
          row.dataset.arbKey = oppKey;
          row.tabIndex = 0;
          row.classList.add(roiBandClass(netRoi));
          const commence = formatDateTime(opp.commence_time);
          const calcGross = opp.has_exchange ? calculateStakes(opp, stakeValue, false) : null;
          const grossRoi = opp.has_exchange ? calcGross?.roi_percent ?? opp.gross_roi_percent : null;
          const netNegative = typeof netRoi === 'number' && netRoi < 0;
          if (netNegative) row.classList.add('roi-negative');
          if (opp.has_exchange) row.classList.add('has-exchange');
          const breakdown = calcNet?.breakdown || [];
          const profitValue = entry.profitValue ?? 0;
          runningProfit += profitValue || 0;
          const profitClass = profitValue > 0 ? 'gain' : profitValue < 0 ? 'loss' : '';
          const grossCell = opp.has_exchange ? formatRoiBadge(grossRoi) : '';
          const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
          const openLabel = t('open_books');
          const hasOpenTargets = collectBookTargets(opp).length > 0;
          if (selectedArbKey && selectedArbKey === oppKey) {
            row.classList.add('arb-selected-row');
            selectedVisible = true;
            selectedArbOpp = opp;
          }
          row.innerHTML = `
            <td><span class="roi-badge">${formatPercent(netRoi)}</span>${netNegative ? `<span class="roi-warning" title="${t('net_roi_negative')}">âš </span>` : ''}</td>
            <td>${grossCell}</td>
            <td class="profit-cell ${profitClass}">${calcNet ? formatProfit(profitValue) : '-'}</td>
            <td>${formatExchangeCell(opp)}</td>
            <td>${sportLabel}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${formatMarket(opp)}</td>
            <td>${formatOutcome(breakdown[0])}</td>
            <td>${formatOutcome(breakdown[1])}</td>
            <td>${formatOutcome(breakdown[2])}</td>
            <td class="open-cell"><button type="button" class="secondary-btn open-books-btn" ${hasOpenTargets ? '' : 'disabled'}>${openLabel}</button></td>`;
          const openBtn = row.querySelector('.open-books-btn');
          if (openBtn) {
            openBtn.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (!hasOpenTargets) {
                showStatusKey('open_books_missing', 'error');
                return;
              }
              openBookmakerTabs(opp);
            });
          }
          row.addEventListener('click', () => {
            const wasSame = selectedArbKey === oppKey;
            selectedArbKey = oppKey;
            selectedArbOpp = opp;
            if (!wasSame || !arbCalculatorState || arbCalculatorState.key !== oppKey) {
              initializeArbCalculatorFromOpportunity(opp, oppKey);
            } else {
              renderArbCalculator();
            }
            renderArbitrage();
          });
          row.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' && event.key !== ' ') return;
            event.preventDefault();
            row.click();
          });
          resultsBody.appendChild(row);
        });
        tableCount.textContent = t('results_profit', {
          count: filtered.length,
          profit: formatCurrency(runningProfit),
        });
      }
      if (selectedArbKey && !selectedVisible) {
        clearArbCalculatorSelection();
      } else if (selectedVisible) {
        renderArbCalculator();
      }
      if (scanOpportunities) scanOpportunities.textContent = String(filtered.length);
      const summary = arbData?.summary;
      if (summary) {
        const totalProfit = filtered.reduce((sum, item) => sum + (item.profitValue || 0), 0);
        const totalStaked = filtered.reduce((sum, item) => sum + (item.calcNet?.total || 0), 0);
        const commissionPercent = formatCommissionPercent(lastCommissionRate);
        const totalCount = arbData.opportunities_count || opportunities.length;
        const filtersActive = minRoi !== 0;
        const profitText = `<strong>${formatCurrency(totalProfit)}</strong>`;
        const stakedText = totalStaked
          ? t('summary_profit_staked', { staked: `<strong>${formatCurrency(totalStaked)}</strong>` })
          : '';
        const filtersNote =
          filtersActive && totalCount !== filtered.length
            ? `<p class="helper">${t('filters_applied', { shown: filtered.length, total: totalCount })}</p>`
            : '';
        summaryEl.classList.remove('hidden');
        summaryEl.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('summary_profit', { profit: profitText, staked: stakedText })}</p>
          <p>${t('summary_commission', { commission: commissionPercent })}</p>
          <p class="helper">${t('summary_roi_note')}</p>
          ${filtersNote}
        `;
      } else {
        summaryEl.classList.add('hidden');
        summaryEl.innerHTML = '';
      }
    }

    function buildArbOpportunityKey(opp) {
      if (!opp || typeof opp !== 'object') return '';
      const odds = Array.isArray(opp.best_odds) ? opp.best_odds.slice(0, 3) : [];
      const legs = odds
        .map((item, idx) => {
          const bookmaker = `${item?.bookmaker_key || item?.bookmaker || ''}`.trim();
          const outcome = `${item?.outcome || ''}`.trim();
          const point = item?.point !== undefined && item?.point !== null ? String(item.point) : '';
          return `${idx}:${bookmaker}:${outcome}:${point}`;
        })
        .join('|');
      return [
        `${opp.event_id || ''}`.trim(),
        `${opp.commence_time || ''}`.trim(),
        `${opp.market || ''}`.trim(),
        `${opp.event || ''}`.trim(),
        legs,
      ].join('::');
    }

    function roundMoney(value) {
      if (!Number.isFinite(value)) return 0;
      return Math.round((value + Number.EPSILON) * 100) / 100;
    }

    function parseStakeValue(value) {
      const num = parseFloat(value);
      if (!Number.isFinite(num) || num < 0) return null;
      return roundMoney(num);
    }

    function parseOddsValue(value) {
      const num = parseFloat(value);
      if (!Number.isFinite(num) || num <= 1) return null;
      return Number(num);
    }

    function splitStakesByTotal(totalStake, oddsList) {
      if (!Number.isFinite(totalStake) || totalStake <= 0) return null;
      if (!Array.isArray(oddsList) || oddsList.length < 2) return null;
      const normalizedOdds = oddsList.map((value) => parseOddsValue(value));
      if (normalizedOdds.some((value) => value === null)) return null;
      const inverses = normalizedOdds.map((odds) => 1 / odds);
      const sumInv = inverses.reduce((sum, value) => sum + value, 0);
      if (sumInv <= 0) return null;
      const totalCents = Math.round(totalStake * 100);
      if (totalCents <= 0) return null;
      const rawCents = inverses.map((inv) => (inv / sumInv) * totalCents);
      const stakeCents = rawCents.map((value) => Math.floor(value));
      let remaining = totalCents - stakeCents.reduce((sum, value) => sum + value, 0);
      const order = rawCents
        .map((value, idx) => ({ idx, frac: value - stakeCents[idx] }))
        .sort((a, b) => b.frac - a.frac);
      for (const item of order) {
        if (remaining <= 0) break;
        stakeCents[item.idx] += 1;
        remaining -= 1;
      }
      return {
        stakes: stakeCents.map((value) => roundMoney(value / 100)),
      };
    }

    function initializeArbCalculatorFromOpportunity(opp, oppKey = null) {
      const odds = Array.isArray(opp?.best_odds) ? opp.best_odds.slice(0, 3) : [];
      const calcLegs = odds
        .map((item) => {
          const legOdds = parseOddsValue(item?.effective_price ?? item?.price);
          if (!legOdds) return null;
          return {
            odds: legOdds,
            stake: 0,
            outcome: `${item?.outcome || ''}`,
            bookmaker: `${item?.bookmaker || ''}`,
            point: item?.point,
            maxStake: item?.max_stake,
          };
        })
        .filter(Boolean);
      if (calcLegs.length < 2) {
        arbCalculatorState = null;
        renderArbCalculator();
        return;
      }
      const defaultTotalRaw = parseFloat(stakeInput?.value);
      const defaultTotal = Number.isFinite(defaultTotalRaw) && defaultTotalRaw > 0
        ? roundMoney(defaultTotalRaw)
        : 100;
      const split = splitStakesByTotal(defaultTotal, calcLegs.map((item) => item.odds));
      if (!split || !Array.isArray(split.stakes) || split.stakes.length !== calcLegs.length) {
        arbCalculatorState = null;
        renderArbCalculator();
        return;
      }
      const legs = calcLegs.map((item, idx) => ({
        ...item,
        stake: split.stakes[idx],
      }));
      arbCalculatorState = {
        key: oppKey || buildArbOpportunityKey(opp),
        mode: 'total',
        totalStake: defaultTotal,
        legs,
      };
      renderArbCalculator();
    }

    function syncArbCalculatorStateFromInputs() {
      if (!arbCalculatorState) return;
      const nextTotal = parseStakeValue(arbCalcTotalInput?.value);
      if (nextTotal !== null) arbCalculatorState.totalStake = nextTotal;
      (arbCalculatorState.legs || []).forEach((leg, idx) => {
        const refs = arbCalcLegRefs[idx];
        if (!refs) return;
        const nextOdds = parseOddsValue(refs.oddsInput?.value);
        const nextStake = parseStakeValue(refs.stakeInput?.value);
        if (nextOdds !== null) leg.odds = nextOdds;
        if (nextStake !== null) leg.stake = nextStake;
      });
    }

    function rebalanceArbCalculator(mode) {
      if (!arbCalculatorState) return;
      syncArbCalculatorStateFromInputs();
      const legs = arbCalculatorState.legs || [];
      if (legs.length < 2) {
        renderArbCalculator();
        return;
      }
      const oddsValues = legs.map((item) => item.odds);
      const oddsValid = oddsValues.every((value) => Number.isFinite(value) && value > 1);
      if (!oddsValid) {
        renderArbCalculator();
        return;
      }

      if (typeof mode === 'string' && mode.startsWith('base_')) {
        const baseIdx = Number(mode.slice(5));
        const baseRefs = arbCalcLegRefs[baseIdx];
        const baseLeg = legs[baseIdx];
        if (!baseLeg || !baseRefs) {
          renderArbCalculator();
          return;
        }
        const baseStake = parseStakeValue(baseRefs.stakeInput?.value ?? baseLeg.stake);
        if (baseStake === null) {
          renderArbCalculator();
          return;
        }
        const payoutTarget = baseStake * baseLeg.odds;
        legs.forEach((item) => {
          item.stake = roundMoney(payoutTarget / item.odds);
        });
        const totalStake = legs.reduce((sum, item) => sum + (item.stake || 0), 0);
        arbCalculatorState.totalStake = roundMoney(totalStake);
        arbCalculatorState.mode = `base_${baseIdx}`;
      } else {
        const totalStake = parseStakeValue(arbCalcTotalInput?.value ?? arbCalculatorState.totalStake);
        if (totalStake === null || totalStake <= 0) {
          renderArbCalculator();
          return;
        }
        const split = splitStakesByTotal(totalStake, oddsValues);
        if (!split || !Array.isArray(split.stakes) || split.stakes.length !== legs.length) {
          renderArbCalculator();
          return;
        }
        legs.forEach((item, idx) => {
          item.stake = split.stakes[idx];
        });
        arbCalculatorState.totalStake = totalStake;
        arbCalculatorState.mode = 'total';
      }
      renderArbCalculator();
    }

    function clearArbCalculatorSelection() {
      selectedArbKey = null;
      selectedArbOpp = null;
      arbCalculatorState = null;
      renderArbCalculator();
    }

    function renderArbCalculator() {
      if (!arbCalculator || !arbCalcEmpty || !arbCalcBody) return;
      const legs = arbCalculatorState?.legs || [];
      if (!arbCalculatorState || !selectedArbOpp || legs.length < 2) {
        arbCalcEmpty.classList.remove('hidden');
        arbCalcBody.classList.add('hidden');
        arbCalcLegRefs.forEach((refs) => refs.section?.classList.add('hidden'));
        return;
      }

      arbCalcEmpty.classList.add('hidden');
      arbCalcBody.classList.remove('hidden');

      const totalStake = roundMoney(
        Number.isFinite(arbCalculatorState.totalStake)
          ? arbCalculatorState.totalStake
          : legs.reduce((sum, item) => sum + (item?.stake || 0), 0)
      );
      const validInputs = legs.every((item) =>
        Number.isFinite(item.odds) &&
        item.odds > 1 &&
        Number.isFinite(item.stake) &&
        item.stake >= 0
      );

      arbCalcEvent.textContent = selectedArbOpp.event || '';
      arbCalcMarket.textContent = t('arb_calc_market_time', {
        market: formatMarket(selectedArbOpp),
        time: formatDateTime(selectedArbOpp.commence_time),
      });

      if (arbCalcTotalInput) arbCalcTotalInput.value = totalStake.toFixed(2);

      arbCalcLegRefs.forEach((refs, idx) => {
        const leg = legs[idx];
        if (!leg) {
          refs.section?.classList.add('hidden');
          if (refs.payoutEl) refs.payoutEl.textContent = `${t('arb_calc_payout')}: -`;
          return;
        }
        refs.section?.classList.remove('hidden');
        const point = leg.point !== undefined && leg.point !== null ? ` (${formatLine(leg.point)})` : '';
        if (refs.title) refs.title.textContent = `${leg.outcome || '-'}${point}`;
        const maxStake = Number(leg.maxStake);
        const maxText = Number.isFinite(maxStake)
          ? t('available_label', { amount: formatCurrency(maxStake) })
          : '';
        if (refs.info) refs.info.textContent = [leg.bookmaker, maxText].filter(Boolean).join(' | ');
        if (refs.oddsInput) refs.oddsInput.value = leg.odds ? leg.odds.toFixed(2) : '';
        if (refs.stakeInput) refs.stakeInput.value = roundMoney(leg.stake || 0).toFixed(2);
      });

      if (!validInputs) {
        arbCalcLegRefs.forEach((refs, idx) => {
          if (idx < legs.length && refs.payoutEl) refs.payoutEl.textContent = `${t('arb_calc_payout')}: -`;
        });
        arbCalcMinPayout.textContent = '-';
        arbCalcProfit.textContent = '-';
        arbCalcProfit.classList.remove('gain', 'loss');
        arbCalcRoi.textContent = '-';
        arbCalcWarning.textContent = t('arb_calc_invalid');
        arbCalcWarning.classList.remove('hidden');
        return;
      }

      const payouts = legs.map((item) => roundMoney(item.stake * item.odds));
      const minPayout = Math.min(...payouts);
      const profit = roundMoney(minPayout - totalStake);
      const roi = totalStake > 0 ? (profit / totalStake) * 100 : 0;

      arbCalcLegRefs.forEach((refs, idx) => {
        if (idx >= legs.length || !refs.payoutEl) return;
        refs.payoutEl.textContent = `${t('arb_calc_payout')}: ${formatCurrency(payouts[idx])}`;
      });
      arbCalcMinPayout.textContent = formatCurrency(minPayout);
      arbCalcProfit.textContent = formatCurrency(profit);
      arbCalcRoi.textContent = formatPercent(roi);
      arbCalcProfit.classList.toggle('gain', profit > 0);
      arbCalcProfit.classList.toggle('loss', profit < 0);

      const exceeded = [];
      legs.forEach((leg) => {
        const maxStake = leg.maxStake === null || leg.maxStake === undefined ? NaN : Number(leg.maxStake);
        const currentStake = Number(leg.stake || 0);
        if (!Number.isFinite(maxStake)) return;
        if (currentStake > maxStake + 1e-9) {
          exceeded.push(`${leg.outcome} (${formatCurrency(maxStake)})`);
        }
      });
      if (exceeded.length) {
        arbCalcWarning.textContent = t('arb_calc_exceeds_max', { items: exceeded.join(', ') });
        arbCalcWarning.classList.remove('hidden');
      } else {
        arbCalcWarning.classList.add('hidden');
        arbCalcWarning.textContent = '';
      }
    }

    function renderMiddles() {
      const data = lastScanData?.middles;
      const opportunities = data?.opportunities || [];
      const minGap = parseFloat(minGapInput.value) || 0;
      const positiveOnly = positiveEvToggle.checked;
      const sortKey = middleSortSelect.value || 'ev';
      updateMiddlesSortLabel();
      const scannedStake = data?.stake_amount || 0;
      const desiredStake = parseFloat(stakeInput.value) || scannedStake || 100;
      const filtered = opportunities.filter((opp) => {
        const gapPoints = opp.gap?.points ?? 0;
        if (gapPoints < minGap) return false;
        if (positiveOnly && opp.ev_percent <= 0) return false;
        return true;
      });
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'probability':
            return (b.middle_probability || 0) - (a.middle_probability || 0);
          case 'gap':
            return (b.gap?.integer_count || 0) - (a.gap?.integer_count || 0);
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'ev':
          default:
            return (b.ev_percent || 0) - (a.ev_percent || 0);
        }
      });
      const stats = buildMiddleStats(filtered);
      middleStatCount.textContent = stats.count;
      middleStatPositive.textContent = stats.positive_count;
      middleStatAvg.textContent = formatPercent(stats.average_ev_percent);
      middleStatBest.textContent = formatPercent(stats.best_ev_percent);
      if (stats.count > 0) {
        middleSummaryInfo.classList.remove('hidden');
        const countText = `<strong>${stats.count}</strong>`;
        const positiveText = `<strong>${stats.positive_count}</strong>`;
        const avgText = `<strong>${formatPercent(stats.average_ev_percent)}</strong>`;
        const bestText = stats.best_event ? t('middle_summary_best', { event: stats.best_event }) : '';
        middleSummaryInfo.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('middle_summary_counts', { count: countText, positive: positiveText })}</p>
          <p>${t('middle_summary_avg', { avg: avgText, best: bestText })}</p>
        `;
        renderBars(middleSportBars, stats.by_sport, 'sport');
        if (Object.keys(stats.key_numbers).length) {
          middleKeyCard.classList.remove('hidden');
          renderBars(middleKeyBars, stats.key_numbers, 'sport');
        } else {
          middleKeyCard.classList.add('hidden');
          middleKeyBars.innerHTML = `<p class="muted">${t('middle_spreads_only')}</p>`;
        }
      } else {
        middleSummaryInfo.classList.add('hidden');
        middleSummaryInfo.innerHTML = '';
        middleSportBars.innerHTML = '';
        middleKeyCard.classList.add('hidden');
        middleKeyBars.innerHTML = `<p class="muted">${t('middle_spreads_only')}</p>`;
      }

      middlesTableBody.innerHTML = '';
      middlesTableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        middlesEmpty.classList.remove('hidden');
      } else {
        middlesEmpty.classList.add('hidden');
        filtered.forEach((opp) => {
          const row = document.createElement('tr');
          const middleCalc = calculateMiddleProjection(opp, desiredStake);
          const displayEvPercent = middleCalc?.ev_percent ?? opp.ev_percent ?? 0;
          const evClass = evBandClass(displayEvPercent);
          if (evClass) row.classList.add(evClass);
          if (opp.has_exchange) row.classList.add('has-exchange');
          const commence = formatDateTime(opp.commence_time);
          const winBoth = middleCalc?.outcomes?.win_both_profit ?? (opp.outcomes?.win_both_profit || 0);
          const miss = middleCalc?.outcomes?.typical_miss_profit ?? (opp.outcomes?.typical_miss_profit || 0);
          const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
          const marketLabel = translateMarketLabel(opp.market || '');
          row.innerHTML = `
            <td>${formatPercent(displayEvPercent)}${opp.has_exchange && typeof opp.gross_ev_percent === 'number' ? `<span class="ev-gross">${t('gross')} ${formatPercent(opp.gross_ev_percent)}</span>` : ''}</td>
            <td>${formatPercent(opp.probability_percent)}</td>
            <td>${formatGapCell(opp)}</td>
            <td>${sportLabel}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${marketLabel}</td>
            <td>${formatMiddleSide(opp.side_a)}</td>
            <td>${formatMiddleSide(opp.side_b)}</td>
            <td>${opp.middle_zone || ''}</td>
            <td class="profit-cell">${formatProfit(winBoth)}</td>
            <td class="profit-cell">${formatProfit(miss)}</td>
          `;
          middlesTableBody.appendChild(row);
        });
      }
    }

    function renderPlusEv() {
      const plusData = lastScanData?.plus_ev;
      const opportunities = plusData?.opportunities || [];
      const minEdge = parseFloat(minEdgeInput.value) || appConfig.defaultMinEdgePercent || 1;
      const bankroll = parseFloat(bankrollInput.value) || appConfig.defaultBankroll || 1000;
      const kellyFraction = parseFloat(kellySelect.value) || appConfig.defaultKellyFraction || 0.25;
      const sortKey = plusEvSortSelect.value || 'edge';
      updatePlusEvSortLabel();
      const filtered = opportunities.filter((opp) => (opp.edge_percent || 0) >= minEdge);
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'ev':
            return (b.ev_per_100 || 0) - (a.ev_per_100 || 0);
          case 'kelly': {
            const bkA = calculateKellyStake(oppTrueProb(a), oppEffectiveOdds(a), bankroll, kellyFraction);
            const bkB = calculateKellyStake(oppTrueProb(b), oppEffectiveOdds(b), bankroll, kellyFraction);
            return bkB.recommended - bkA.recommended;
          }
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'edge':
          default:
            return (b.edge_percent || 0) - (a.edge_percent || 0);
        }
      });
      const stats = buildPlusEvStats(filtered);
      plusEvCount.textContent = stats.count;
      plusEvAvg.textContent = formatPercent(stats.average_edge_percent);
      plusEvBest.textContent = formatPercent(stats.best_edge_percent);
      plusEvTotal.textContent = formatCurrency(stats.total_ev_per_100);
      if (stats.count > 0) {
        plusEvSummaryInfo.classList.remove('hidden');
        const countText = `<strong>${stats.count}</strong>`;
        const avgText = `<strong>${formatPercent(stats.average_edge_percent)}</strong>`;
        const bestText = stats.best_event ? t('plus_summary_best', { event: stats.best_event }) : '';
        plusEvSummaryInfo.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('plus_summary', { count: countText, avg: avgText, best: bestText })}</p>
        `;
        renderBars(plusEvSportBars, stats.by_sport, 'sport');
        renderBars(plusEvEdgeBars, stats.by_edge_band, 'roi');
      } else {
        plusEvSummaryInfo.classList.add('hidden');
        plusEvSummaryInfo.innerHTML = '';
        plusEvSportBars.innerHTML = `<p class="muted">${t('no_data')}</p>`;
        plusEvEdgeBars.innerHTML = `<p class="muted">${t('no_data')}</p>`;
      }

      plusEvTableBody.innerHTML = '';
      plusEvTableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        plusEvEmpty.classList.remove('hidden');
        return;
      }
      plusEvEmpty.classList.add('hidden');
      filtered.forEach((opp) => {
        const row = document.createElement('tr');
        if (opp.has_exchange) row.classList.add('has-exchange');
        const commence = formatDateTime(opp.commence_time);
        const kellyData = calculateKellyStake(oppTrueProb(opp), oppEffectiveOdds(opp), bankroll, kellyFraction);
        const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
        row.innerHTML = `
          <td>${formatEdgeCell(opp)}</td>
          <td class="profit-cell">${formatProfit(opp.ev_per_100 || 0)}</td>
          <td>${formatKellyCell(kellyData)}</td>
          <td>${sportLabel}</td>
          <td>${opp.event || ''}</td>
          <td>${commence}</td>
          <td>${formatPlusMarket(opp)}</td>
          <td>${formatPlusBet(opp)}</td>
          <td>${formatOddsDisplay(opp.bet?.soft_odds)}</td>
          <td>${formatOddsDisplay(opp.sharp?.fair_odds)}</td>
          <td>${formatPercent(opp.sharp?.true_probability_percent)}</td>
        `;
        plusEvTableBody.appendChild(row);
      });
    }

    function oppTrueProb(opp) {
      return opp?.sharp?.true_probability ?? (opp?.sharp?.true_probability_percent || 0) / 100;
    }

    function oppEffectiveOdds(opp) {
      return opp?.bet?.effective_odds || opp?.bet?.soft_odds || 0;
    }

    function calculateKellyStake(prob, odds, bankroll, fraction) {
      if (!prob || !odds || bankroll <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      const p = Math.max(0, Math.min(prob, 1));
      const q = 1 - p;
      const b = odds - 1;
      if (b <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      let full = (b * p - q) / b;
      if (full <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      const frac = Math.max(0, Math.min(fraction, 1));
      const adjusted = full * frac;
      const recommended = Math.max(0, bankroll * adjusted);
      return {
        fullPercent: full * 100,
        fractionPercent: adjusted * 100,
        recommended: Number(recommended.toFixed(2)),
      };
    }

    function formatEdgeCell(opp) {
      const net = formatPercent(opp.edge_percent);
      if (opp.has_exchange && typeof opp.gross_edge_percent === 'number' && opp.gross_edge_percent !== opp.edge_percent) {
        return `${net}<span class="ev-gross">${t('gross')} ${formatPercent(opp.gross_edge_percent)}</span>`;
      }
      return net;
    }

    function formatKellyCell(kellyData) {
      if (!kellyData) return '';
      const stake = kellyData.recommended || 0;
      const frac = kellyData.fractionPercent || 0;
      const rollText = t('kelly_roll', { percent: frac.toFixed(2) });
      return `<div class="kelly-cell">${formatCurrency(stake)}<span class="mono">${rollText}</span></div>`;
    }

    function formatPlusMarket(opp) {
      if (!opp) return '';
      if ((opp.market === 'spreads' || opp.market === 'totals') && opp.market_point !== undefined && opp.market_point !== null) {
        const label = translateMarketLabel(opp.market || '');
        return `${label} (${formatLine(opp.market_point)})`;
      }
      return translateMarketLabel(opp.market || '');
    }

    function formatPlusBet(opp) {
      if (!opp?.bet) return '';
      const exchangeBadge = opp.bet.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const book = opp.bet.soft_book ? ` @ ${opp.bet.soft_book}` : '';
      const point = opp.bet.point !== undefined && opp.bet.point !== null ? ` (${formatLine(opp.bet.point)})` : '';
      return `<span class="outcome">${exchangeBadge}<strong>${opp.bet.outcome || ''}${point}</strong><span>${book}</span></span>`;
    }

    function updateOddsToggle() {
      if (!oddsToggle) return;
      oddsToggle.querySelectorAll('span').forEach((span) => {
        const format = span.dataset.format;
        span.classList.toggle('active', format === oddsFormat);
      });
    }

    function formatOddsDisplay(value) {
      if (!value && value !== 0) return '-';
      if (oddsFormat === 'american') {
        const american = decimalToAmerican(value);
        return american > 0 ? `+${american}` : `${american}`;
      }
      return Number(value).toFixed(2);
    }

    function decimalToAmerican(decimal) {
      if (!decimal || decimal <= 1) return 0;
      if (decimal >= 2) {
        return Math.round((decimal - 1) * 100);
      }
      return Math.round(-100 / (decimal - 1));
    }

    function formatOutcome(item) {
      if (!item) return '-';
      const point = item.point !== undefined && item.point !== null ? ` (${item.point})` : '';
      const availableValue =
        item.max_stake !== undefined &&
        item.max_stake !== null &&
        !Number.isNaN(Number(item.max_stake))
          ? formatCurrency(Number(item.max_stake))
          : '-';
      const available = t('available_label', { amount: availableValue });
      const book = item.bookmaker ? ` @ ${item.bookmaker}` : '';
      const exchangeBadge = item.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const effectiveNote =
        item.is_exchange && item.effective_price && item.effective_price !== item.price
          ? `<span class="mono net-note">${t('net_at', { odds: formatOddsDisplay(item.effective_price) })}</span>`
          : '';
      return `<span class="outcome">${exchangeBadge}<strong>${item.outcome || ''}${point}</strong><span>${available}${book}</span><span class="mono">@ ${formatOddsDisplay(item.price)}</span>${effectiveNote}</span>`;
    }

    function collectBookTargets(opp) {
      const odds = Array.isArray(opp?.best_odds) ? opp.best_odds : [];
      const seen = new Set();
      const entries = [];
      odds.forEach((item) => {
        const key = (item.bookmaker_key || '').trim();
        const name = (item.bookmaker || '').trim();
        const id = key || name;
        if (!id || seen.has(id)) return;
        seen.add(id);
        const eventId = `${item.book_event_id ?? opp?.event_id ?? ''}`.trim();
        const eventUrl = `${item.book_event_url ?? ''}`.trim();
        entries.push({ key, name, eventId, eventUrl });
      });
      return entries;
    }

    function normalizeUrl(value) {
      const trimmed = (value || '').trim();
      if (!trimmed) return '';
      if (/^https?:\/\//i.test(trimmed)) return trimmed;
      return `https://${trimmed}`;
    }

    function openExternalTab(url) {
      const target = normalizeUrl(url);
      if (!target) return 0;
      const opened = window.open(target, '_blank', 'noopener,noreferrer');
      return opened ? 1 : 0;
    }

    function resolveBookmakerLink(book) {
      const key = (book?.key || '').trim();
      const name = (book?.name || '').trim();
      const candidates = [key, key.toLowerCase(), name, name.toLowerCase()].filter(Boolean);
      for (const candidate of candidates) {
        const baseUrl = bookmakerLinks[candidate];
        if (normalizeUrl(baseUrl)) return baseUrl;
      }
      return '';
    }

    function withTemplatePlaceholders(url, book, opp) {
      const normalized = normalizeUrl(url);
      if (!normalized) return '';
      const eventId = `${book?.eventId ?? opp?.event_id ?? ''}`.trim();
      const values = {
        event_id: eventId,
        book_event_id: `${book?.eventId ?? ''}`.trim(),
        home_team: `${opp?.home_team ?? ''}`.trim(),
        away_team: `${opp?.away_team ?? ''}`.trim(),
        event: `${opp?.event ?? ''}`.trim(),
      };
      return normalized.replace(/\{(event_id|book_event_id|home_team|away_team|event)\}/gi, (_, token) => {
        const value = values[(token || '').toLowerCase()] ?? '';
        return encodeURIComponent(value);
      });
    }

    function isPurebetBook(book) {
      const key = (book?.key || '').trim().toLowerCase();
      const name = (book?.name || '').trim().toLowerCase();
      return key === 'purebet' || name === 'purebet';
    }

    function isPurebetHost(url) {
      try {
        const host = new URL(url).hostname.toLowerCase();
        return host === 'purebet.io' || host.endsWith('.purebet.io');
      } catch (err) {
        return false;
      }
    }

    function resolveBookmakerOpenUrl(book, opp) {
      const eventId = `${book?.eventId ?? opp?.event_id ?? ''}`.trim();
      const isPurebet = isPurebetBook(book);
      const purebetEventPage = isPurebet && eventId
        ? `https://purebet.io/event/${encodeURIComponent(eventId)}`
        : '';
      if (purebetEventPage) return purebetEventPage;
      const directEventUrl = normalizeUrl(book?.eventUrl);
      if (directEventUrl) return directEventUrl;
      const baseUrl = resolveBookmakerLink(book);
      const templated = withTemplatePlaceholders(baseUrl, book, opp);
      if (!templated) {
        return '';
      }
      if (!isPurebet || !isPurebetHost(templated)) {
        return templated;
      }
      try {
        const parsed = new URL(templated);
        const path = (parsed.pathname || '/').replace(/\/+$/, '');
        if (!path || path === '/' || path === '/event') {
          return templated;
        }
      } catch (err) {
        return templated;
      }
      return templated;
    }

    function openBookmakerTabs(opp) {
      const books = collectBookTargets(opp);
      if (!books.length) {
        showStatusKey('open_books_missing', 'error');
        return;
      }
      let openedCount = 0;
      let availableLinks = 0;
      books.forEach((book) => {
        const targetUrl = resolveBookmakerOpenUrl(book, opp);
        if (!normalizeUrl(targetUrl)) return;
        availableLinks += 1;
        openedCount += openExternalTab(targetUrl);
      });
      if (!availableLinks) {
        showStatusKey('open_books_missing', 'error');
        return;
      }
      if (!openedCount) {
        showStatusKey('open_books_blocked', 'error');
      }
    }

    function formatMarket(opp) {
      const marketLabel = translateMarketLabel(opp.market || '');
      const point = opp.best_odds?.[0]?.point ?? opp.point;
      if (point !== undefined && point !== null) {
        return `${marketLabel} (${point})`;
      }
      return marketLabel;
    }

    function formatPrice(value) {
      if (!value && value !== 0) return '';
      return Number(value).toFixed(2);
    }

    function calculateStakes(opp, totalStake, useEffectivePrices = true) {
      const odds = (opp.best_odds || []).slice(0, 3);
      if (!totalStake || totalStake <= 0 || odds.length < 2) return null;
      const requestedTotal = Number(Number(totalStake).toFixed(2));
      const inverses = odds.map((o) => {
        if (!o) return 0;
        const price = useEffectivePrices
          ? Number(o.effective_price ?? o.price)
          : Number(o.price);
        return price > 0 ? 1 / price : 0;
      });
      const sumInv = inverses.reduce((a, b) => a + b, 0);
      if (sumInv <= 0) return null;
      const fractions = inverses.map((inv) => inv / sumInv);
      let capTotal = null;
      odds.forEach((o, idx) => {
        if (!o) return;
        const fraction = fractions[idx];
        if (!fraction || fraction <= 0) return;
        const capRaw =
          o.max_stake !== undefined && o.max_stake !== null
            ? Number(o.max_stake)
            : null;
        if (capRaw === null || Number.isNaN(capRaw)) return;
        const cap = Math.max(0, capRaw);
        const limit = cap / fraction;
        capTotal = capTotal === null ? limit : Math.min(capTotal, limit);
      });
      let executableTotal = requestedTotal;
      if (capTotal !== null) executableTotal = Math.min(executableTotal, capTotal);
      executableTotal = Math.max(0, Math.floor(executableTotal * 100) / 100);
      if (executableTotal <= 0) {
        return {
          requested_total: requestedTotal,
          total: 0,
          max_executable_total: capTotal !== null ? Number(capTotal.toFixed(2)) : requestedTotal,
          limited_by_max_stake: capTotal !== null,
          breakdown: [],
          guaranteed_profit: 0,
          roi_percent: 0,
        };
      }

      const totalCents = Math.round(executableTotal * 100);
      const rawCents = fractions.map((fraction) => fraction * totalCents);
      const stakeCents = rawCents.map((value) => Math.floor(value));
      let remaining = totalCents - stakeCents.reduce((a, b) => a + b, 0);
      const order = rawCents
        .map((value, idx) => ({ idx, frac: value - stakeCents[idx] }))
        .sort((a, b) => b.frac - a.frac);
      for (const item of order) {
        if (remaining <= 0) break;
        const o = odds[item.idx];
        const capRaw =
          o && o.max_stake !== undefined && o.max_stake !== null
            ? Number(o.max_stake)
            : null;
        if (capRaw !== null && !Number.isNaN(capRaw)) {
          const capCents = Math.floor(Math.max(0, capRaw) * 100);
          if (stakeCents[item.idx] + 1 > capCents) continue;
        }
        stakeCents[item.idx] += 1;
        remaining -= 1;
      }

      const actualTotal = Number((stakeCents.reduce((a, b) => a + b, 0) / 100).toFixed(2));
      const breakdown = odds.map((o, idx) => {
        if (!o || !o.price) return null;
        const fraction = fractions[idx];
        const stake = Number((stakeCents[idx] / 100).toFixed(2));
        const displayPrice = Number(o.price);
        const effectivePrice = Number(o.effective_price ?? o.price);
        const priceUsed = useEffectivePrices ? effectivePrice : displayPrice;
        if (!priceUsed || priceUsed <= 0) return null;
        const payout = Number((stake * priceUsed).toFixed(2));
        return {
          outcome: o.outcome,
          bookmaker: o.bookmaker,
          price: displayPrice,
          effective_price: effectivePrice,
          point: o.point,
          stake,
          max_stake: o.max_stake,
          payout,
          fraction,
          is_exchange: Boolean(o.is_exchange),
        };
      });
      if (breakdown.includes(null)) return null;
      const minPayout = Math.min(...breakdown.map((b) => b.payout));
      const guaranteed_profit = Number((minPayout - actualTotal).toFixed(2));
      const roi_percent = actualTotal ? (guaranteed_profit / actualTotal) * 100 : 0;
      return {
        requested_total: requestedTotal,
        total: actualTotal,
        max_executable_total: capTotal !== null ? Number(capTotal.toFixed(2)) : requestedTotal,
        limited_by_max_stake: capTotal !== null && actualTotal + 1e-9 < requestedTotal,
        breakdown,
        guaranteed_profit,
        roi_percent,
      };
    }

    function calculateMiddleProjection(opp, totalStake) {
      if (!opp || !opp.side_a || !opp.side_b) return null;
      const sideA = opp.side_a;
      const sideB = opp.side_b;
      const pseudoOpp = {
        best_odds: [
          {
            outcome: sideA.team,
            bookmaker: sideA.bookmaker,
            bookmaker_key: sideA.bookmaker_key,
            price: sideA.price,
            effective_price: sideA.effective_price,
            max_stake: sideA.max_stake,
            point: sideA.line,
            is_exchange: sideA.is_exchange,
          },
          {
            outcome: sideB.team,
            bookmaker: sideB.bookmaker,
            bookmaker_key: sideB.bookmaker_key,
            price: sideB.price,
            effective_price: sideB.effective_price,
            max_stake: sideB.max_stake,
            point: sideB.line,
            is_exchange: sideB.is_exchange,
          },
        ],
      };
      const split = calculateStakes(pseudoOpp, totalStake, true);
      if (!split || !Array.isArray(split.breakdown) || split.breakdown.length < 2 || split.total <= 0) return null;
      const stakeA = Number(split.breakdown[0]?.stake || 0);
      const stakeB = Number(split.breakdown[1]?.stake || 0);
      const oddsA = Number(sideA.effective_price ?? sideA.price ?? 0);
      const oddsB = Number(sideB.effective_price ?? sideB.price ?? 0);
      if (!stakeA || !stakeB || oddsA <= 1 || oddsB <= 1) return null;
      const total = Number((stakeA + stakeB).toFixed(2));
      const payoutA = Number((stakeA * oddsA).toFixed(2));
      const payoutB = Number((stakeB * oddsB).toFixed(2));
      const winBoth = Number(((payoutA + payoutB) - total).toFixed(2));
      const sideAOnly = Number((payoutA - total).toFixed(2));
      const sideBOnly = Number((payoutB - total).toFixed(2));
      const typicalMiss = Number(((sideAOnly + sideBOnly) / 2).toFixed(2));
      const probability = Math.max(0, Math.min(Number(opp.middle_probability || 0), 1));
      const missProbability = 1 - probability;
      const missEv = 0.5 * sideAOnly + 0.5 * sideBOnly;
      const evDollars = Number(((probability * winBoth) + (missProbability * missEv)).toFixed(2));
      const evPercent = total ? Number(((evDollars / total) * 100).toFixed(2)) : 0;
      return {
        stakes: split,
        outcomes: {
          win_both_profit: winBoth,
          side_a_wins_profit: sideAOnly,
          side_b_wins_profit: sideBOnly,
          typical_miss_profit: typicalMiss,
        },
        ev_dollars: evDollars,
        ev_percent: evPercent,
      };
    }

    function formatCurrency(value) {
      return currencyFormatter.format(value || 0);
    }

    function formatProfit(value) {
      const formatted = formatCurrency(Math.abs(value || 0));
      return `${value >= 0 ? '+' : '-'}${formatted}`;
    }

    function renderPartialWarning(data) {
      const errorDetails = data && data.partial && Array.isArray(data.sport_errors)
        ? data.sport_errors
            .map((err) => `${err.sport || err.sport_key || t('unknown')} (${err.error || t('unknown_error')})`)
            .join(', ')
        : '';
      const skipDetails = data && Array.isArray(data.api_market_skips)
        ? data.api_market_skips
            .filter((entry) => entry && Array.isArray(entry.markets) && entry.markets.length)
            .map((entry) => {
              const sportLabel = translateSportKey(entry.sport_key, entry.sport_key || t('unknown'));
              return `${sportLabel}: ${entry.markets.join('/')}`;
            })
            .join(', ')
        : '';

      const warningBlocks = [];
      if (errorDetails) {
        warningBlocks.push(t('partial_results', { details: errorDetails }));
      }
      if (skipDetails) {
        warningBlocks.push(t('market_skips', { details: skipDetails }));
      }

      if (warningBlocks.length) {
        partialWarning.innerHTML = warningBlocks.join('<br/>');
        partialWarning.classList.remove('hidden');
        if (scanErrors) {
          const scanBlocks = [];
          if (errorDetails) scanBlocks.push(t('scan_errors', { details: errorDetails }));
          if (skipDetails) scanBlocks.push(t('scan_market_skips', { details: skipDetails }));
          scanErrors.innerHTML = scanBlocks.join('<br/>');
          scanErrors.classList.remove('hidden');
        }
      } else {
        partialWarning.classList.add('hidden');
        partialWarning.textContent = '';
        if (scanErrors) {
          scanErrors.classList.add('hidden');
          scanErrors.textContent = '';
        }
      }
    }

    function formatCommissionPercent(rate) {
      if (typeof rate !== 'number') return `${defaultCommissionPercent.toFixed(1)}%`;
      const percent = (rate * 100).toFixed(2);
      return `${percent.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1')}%`;
    }

    function formatExchangeCell(opp) {
      if (!opp || !opp.has_exchange) return `<span class="exchange-flag none">${t('no')}</span>`;
      const names = Array.isArray(opp.exchange_books) && opp.exchange_books.length
        ? opp.exchange_books.join(', ')
        : t('exchange');
      const commissionText = formatCommissionPercent(lastCommissionRate);
      return `<span class="exchange-flag">${names}<span class="exchange-note">${commissionText}</span></span>`;
    }

    function setActiveTab(tab) {
      activeTab = tab;
      tabs.forEach((btn) => btn.classList.toggle('active', btn.dataset.tab === tab));
      arbitragePanel.classList.toggle('hidden', tab !== 'arbitrage');
      middlesPanel.classList.toggle('hidden', tab !== 'middles');
      plusEvPanel.classList.toggle('hidden', tab !== 'plus-ev');
      if (arbitrageConfig) {
        arbitrageConfig.classList.toggle('hidden', tab !== 'arbitrage');
      }
      middlesConfig.classList.toggle('hidden', tab !== 'middles');
      plusEvConfig.classList.toggle('hidden', tab !== 'plus-ev');
      if (tab === 'arbitrage') {
        renderArbitrage();
      } else if (tab === 'middles') {
        renderMiddles();
      } else {
        renderPlusEv();
      }
    }

    function formatGapCell(opp) {
      const integers = opp.gap?.middle_integers || [];
      const keyFlag = opp.gap?.includes_key_number ? ' ðŸˆ' : '';
      const points =
        typeof opp.gap?.points === 'number' ? t('gap_points', { points: opp.gap.points.toFixed(1) }) : '';
      let range = '';
      if (integers.length) {
        range = integers.length === 1 ? `${integers[0]}` : `${integers[0]}-${integers[integers.length - 1]}`;
      }
      const pieces = [range, points].filter(Boolean);
      return `${pieces.join(t('gap_separator'))}${keyFlag}`;
    }

    function formatMiddleSide(side) {
      if (!side) return '';
      const line = side.line !== undefined && side.line !== null ? formatLine(side.line) : '';
      const book = side.bookmaker ? ` @ ${side.bookmaker}` : '';
      const odds = side.effective_price ? formatOddsDisplay(side.effective_price) : formatOddsDisplay(side.price);
      const availableValue =
        side.max_stake !== undefined &&
        side.max_stake !== null &&
        !Number.isNaN(Number(side.max_stake))
          ? formatCurrency(Number(side.max_stake))
          : '-';
      const available = t('available_label', { amount: availableValue });
      const exchangeBadge = side.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const oddsText = t('odds_label', { odds });
      return `<span class="outcome">${exchangeBadge}<strong>${side.team || ''} ${line}</strong><span>${oddsText}${book}</span><span>${available}</span></span>`;
    }

    function formatLine(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      const num = Number(value);
      const sign = num > 0 ? '+' : '';
      return `${sign}${num.toFixed(1)}`;
    }

    function roiBandClass(roi) {
      if (roi >= 2) return 'band-hot';
      if (roi >= 1) return 'band-warm';
      return 'band-cool';
    }

    function renderBars(container, data, type) {
      if (!container) return;
      if (!data || Object.keys(data).length === 0) {
        container.innerHTML = `<p class="muted">${t('no_data')}</p>`;
        return;
      }
      const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
      const max = entries[0][1] || 1;
      container.innerHTML = entries
        .map(([label, value]) => {
          const width = Math.max((value / max) * 100, 8);
          const bandClass = type === 'roi' ? roiBandLabelClass(label) : '';
          const displayLabel = type === 'sport' ? translateSportLabel(label) : label;
          return `
            <div class="bar-row">
              <span>${displayLabel}</span>
              <div class="bar-track">
                <div class="bar-fill ${bandClass}" style="width: ${width}%"></div>
              </div>
              <span class="bar-value">${value}</span>
            </div>`;
        })
        .join('');
    }

    function roiBandLabelClass(label) {
      if (label.includes('10')) return 'band-hot';
      if (label.includes('5')) return 'band-warm';
      return 'band-cool';
    }

    function formatPercent(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '-';
      return `${Number(value).toFixed(2)}%`;
    }

    function formatRoiBadge(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      return `<span class="roi-badge secondary">${formatPercent(value)}</span>`;
    }

    function evBandClass(evPercent) {
      if (evPercent >= 10) return 'ev-hot';
      if (evPercent >= 5) return 'ev-warm';
      if (evPercent >= 1) return 'ev-cool';
      if (evPercent < 0) return 'ev-negative';
      return '';
    }

    function buildMiddleStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          positive_count: 0,
          average_ev_percent: 0,
          best_ev_percent: 0,
          best_event: '',
          by_sport: {},
          key_numbers: {},
        };
      }
      let positive = 0;
      let evSum = 0;
      let best = list[0];
      const bySport = {};
      const keyNumbers = {};
      list.forEach((opp) => {
        const ev = Number(opp.ev_percent) || 0;
        if (ev > 0) positive += 1;
        evSum += ev;
        if (!best || ev > (best.ev_percent || 0)) {
          best = opp;
        }
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        (opp.gap?.key_numbers_crossed || []).forEach((num) => {
          const key = String(num);
          keyNumbers[key] = (keyNumbers[key] || 0) + 1;
        });
      });
      return {
        count,
        positive_count: positive,
        average_ev_percent: evSum / count,
        best_ev_percent: best?.ev_percent || 0,
        best_event: best?.event || '',
        by_sport: bySport,
        key_numbers: keyNumbers,
      };
    }

    function buildPlusEvStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          average_edge_percent: 0,
          best_edge_percent: 0,
          best_event: '',
          total_ev_per_100: 0,
          by_sport: {},
          by_edge_band: {},
        };
      }
      let edgeSum = 0;
      let best = list[0];
      let totalEv = 0;
      const bySport = {};
      const byEdge = {};
      list.forEach((opp) => {
        const edge = Number(opp.edge_percent) || 0;
        edgeSum += edge;
        totalEv += Number(opp.ev_per_100) || 0;
        if (!best || edge > (best.edge_percent || 0)) best = opp;
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        const bandLabel = edge >= 10 ? '10%+' : edge >= 5 ? '5-10%' : edge >= 3 ? '3-5%' : '1-3%';
        byEdge[bandLabel] = (byEdge[bandLabel] || 0) + 1;
      });
      return {
        count,
        average_edge_percent: edgeSum / count,
        best_edge_percent: best?.edge_percent || 0,
        best_event: best?.event || '',
        total_ev_per_100: totalEv,
        by_sport: bySport,
        by_edge_band: byEdge,
      };
    }
  </script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const historyPanel = document.getElementById('history-panel');
    const refreshHistoryBtn = document.getElementById('refresh-history-btn');
    const historyTableBody = document.querySelector('#history-table tbody');
    const historyEmpty = document.getElementById('history-empty');
    const historyTableCount = document.getElementById('history-table-count');

    // Override the display logic for tabs to include History
    const allTabs = document.querySelectorAll('.tab-btn');
    const arbPanel = document.getElementById('arbitrage-panel');
    const arbConfig = document.getElementById('arbitrage-config');
    const midPanel = document.getElementById('middles-panel');
    const midConfig = document.getElementById('middles-config');
    const evPanel = document.getElementById('plus-ev-panel');
    const evConfig = document.getElementById('plus-ev-config');

    allTabs.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const tabId = e.target.dataset.tab;
            allTabs.forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');

            arbPanel?.classList.add('hidden');
            arbConfig?.classList.add('hidden');
            midPanel?.classList.add('hidden');
            midConfig?.classList.add('hidden');
            evPanel?.classList.add('hidden');
            evConfig?.classList.add('hidden');
            historyPanel?.classList.add('hidden');

            if (tabId === 'arbitrage') {
                arbPanel?.classList.remove('hidden');
                arbConfig?.classList.remove('hidden');
            } else if (tabId === 'middles') {
                midPanel?.classList.remove('hidden');
                midConfig?.classList.remove('hidden');
            } else if (tabId === 'plus-ev') {
                evPanel?.classList.remove('hidden');
                evConfig?.classList.remove('hidden');
            } else if (tabId === 'history') {
                historyPanel?.classList.remove('hidden');
                if (window.loadHistory) window.loadHistory();
            }
        });
    });

    window.loadHistory = function loadHistory() {
      if (!refreshHistoryBtn) return;
      refreshHistoryBtn.disabled = true;
      refreshHistoryBtn.textContent = 'Loading...';
      
      fetch('/history?limit=200')
        .then(res => res.json())
        .then(data => {
          refreshHistoryBtn.disabled = false;
          refreshHistoryBtn.textContent = 'Refresh'; // Or use i18n
          
          if (!historyTableBody) return;
          historyTableBody.innerHTML = '';
          
          if (!data.success || !data.records || data.records.length === 0) {
            historyEmpty?.classList.remove('hidden');
            document.querySelector('#history-table')?.parentElement.classList.add('hidden');
            if(historyTableCount) historyTableCount.textContent = '0 records';
            return;
          }
          
          historyEmpty?.classList.add('hidden');
          document.querySelector('#history-table')?.parentElement.classList.remove('hidden');
          if(historyTableCount) historyTableCount.textContent = data.records.length + ' records';
          
          data.records.forEach(rec => {
            const tr = document.createElement('tr');
            
            let metricText = '';
            let modeTitle = rec.mode;
            let displayBooks = '';
            
            if (rec.mode === 'arbitrage') {
              metricText = `<span class="gross-roi positive-roi">${(rec.roi_percent || 0).toFixed(2)}% ROI</span>`;
              modeTitle = 'Arb';
              if (rec.books) displayBooks = rec.books.map(b => `${b.bookmaker} (${b.price})`).join(' vs ');
            } else if (rec.mode === 'ev') {
              metricText = `<span class="gross-roi positive-roi">${(rec.edge_percent || 0).toFixed(2)}% Edge</span>`;
              modeTitle = '+EV';
              displayBooks = `${rec.soft_book || ''} (${rec.soft_odds || ''}) vs Sharp (${rec.sharp_fair || ''})`;
            } else if (rec.mode === 'middles') {
              metricText = `<span class="gross-roi positive-roi">$${(rec.ev_dollars || 0).toFixed(2)} EV</span>`;
              modeTitle = 'Middle';
              if (rec.books) displayBooks = rec.books.map(b => `${b.bookmaker} (${b.price})`).join(' vs ');
            }
            
            const scanTime = rec.scan_time ? rec.scan_time.replace('T', ' ').slice(0, 19) : '';
            const sport = rec.sport_display || rec.sport || '';
            
            tr.innerHTML = `
              <td class="mono">${scanTime}</td>
              <td><span class="badge uppercase">${modeTitle}</span></td>
              <td>${metricText}</td>
              <td>${sport}</td>
              <td class="event-cell">${rec.event || ''}</td>
              <td>${rec.market || ''}</td>
              <td class="event-cell muted">${displayBooks}</td>
            `;
            historyTableBody.appendChild(tr);
          });
        })
        .catch(err => {
          console.error(err);
          if (refreshHistoryBtn) {
              refreshHistoryBtn.disabled = false;
              refreshHistoryBtn.textContent = 'Error';
          }
        });
    }

    if (refreshHistoryBtn) {
        refreshHistoryBtn.addEventListener('click', loadHistory);
    }
});
</script>
</body>

</html>
