<!doctype html>
<html lang="en" data-theme="{{ default_theme }}">
<head>
  <meta charset="utf-8" />
  <title>Edge Scanner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&family=Space+Grotesk:wght@500;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet" />
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <header class="app-header">
    <div class="brand-block">
      <span class="brand-kicker">EDGE SCANNER</span>
      <h1>Live Market Intelligence</h1>
      <p data-i18n="tagline">Arbitrage / Middles / +EV</p>
    </div>
    <div class="header-controls">
      <div class="odds-format" id="odds-toggle" role="button" tabindex="0">
        <span data-format="decimal" class="active" data-i18n="odds_decimal">Decimal</span>
        <span data-format="american" data-i18n="odds_american">American</span>
      </div>
      <div class="odds-format" id="language-toggle" role="button" tabindex="0" aria-label="Toggle language">
        <span data-lang="en" class="active" data-i18n="lang_en">EN</span>
        <span data-lang="zh" data-i18n="lang_zh">ZH</span>
      </div>
      <div class="odds-format" id="density-toggle" role="button" tabindex="0" aria-label="Toggle density">
        <span data-density="comfort" class="active" data-i18n="density_comfort">Comfort</span>
        <span data-density="compact" data-i18n="density_compact">Compact</span>
      </div>
      <button class="icon-btn" id="theme-toggle" title="Toggle theme">Theme</button>
    </div>
  </header>

  <main>
    <div class="layout">
      <aside class="sidebar">
    <section class="card config-card">
      <form id="scan-form">
        <div class="config-grid">
          {% if not has_env_key %}
          <div class="field">
            <label class="field-label" data-i18n="api_key_label">API Key</label>
            <div class="input-wrap">
              <input type="password" id="api-key" placeholder="sk_xxx" required />
              <button type="button" id="toggle-key" class="icon-btn" aria-label="Show API key">Show</button>
            </div>
          </div>
          {% endif %}
          <div class="field">
            <label class="field-label" data-i18n="total_stake_label">Total Stake ($)</label>
            <input type="number" id="stake-input" min="1" step="1" value="{{ default_stake_amount }}" />
            <p class="helper" data-i18n="stake_helper">Used for arbitrage + middles stake splits.</p>
          </div>
          <div class="field">
            <label class="field-label" data-i18n="regions_label">Regions</label>
            <div class="regions-grid">
              {% for region in region_options %}
              <label class="checkbox">
                <input type="checkbox" name="regions" value="{{ region.key }}" {% if region.default %}checked{% endif %} />
                <span data-region-key="{{ region.key }}">{{ region.label }}</span>
              </label>
              {% endfor %}
            </div>
            <p class="helper" data-i18n="regions_helper">Select at least one region. EU is always included for sharp reference.</p>
          </div>
        </div>
        <div class="advanced-trigger">
          <button type="button" id="open-advanced" class="secondary-btn" data-i18n="advanced_settings" aria-haspopup="dialog" aria-expanded="false" aria-controls="advanced-modal">Advanced settings</button>
          <span id="advanced-summary" class="summary-chip"></span>
        </div>
        <div class="modal hidden" id="advanced-modal" role="dialog" aria-modal="true" aria-labelledby="advanced-title" aria-hidden="true">
          <div class="modal-backdrop" data-close="modal"></div>
          <div class="modal-panel">
            <div class="modal-head">
              <h3 id="advanced-title" data-i18n="advanced_settings">Advanced settings</h3>
              <button type="button" id="close-advanced" class="icon-btn" aria-label="Close" data-i18n="close">Close</button>
            </div>
            <p class="helper" data-i18n="advanced_hint">Less frequently adjusted options live here.</p>
            <div class="advanced-layout">
              <section class="advanced-panel">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="sports_label">Sports</span>
                    <p class="helper" data-i18n="sports_helper">Each selected sport consumes one API request.</p>
                  </div>
                  <div class="panel-actions">
                    <button type="button" class="chip-btn" data-quick-action="select" data-quick-target="sports" data-i18n="select_all">Select all</button>
                    <button type="button" class="chip-btn" data-quick-action="clear" data-quick-target="sports" data-i18n="clear_all">Clear</button>
                  </div>
                </div>
                <div class="panel-body">
                  <div id="sports-list" class="sports-grid">
                    {% for sport in default_sports %}
                    <label class="checkbox">
                      <input type="checkbox" name="sports" value="{{ sport.key }}" checked />
                      <span data-sport-key="{{ sport.key }}">{{ sport.label }}</span>
                    </label>
                    {% endfor %}
                  </div>
                </div>
                <div class="panel-foot">
                  <label class="checkbox all-toggle">
                    <input type="checkbox" id="all-sports" {% if default_all_sports %}checked{% endif %} />
                    <span data-i18n="all_sports_label">Scan all active sports (uses more API credits)</span>
                  </label>
                </div>
              </section>
              <section class="advanced-panel">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="bookmakers_label">Bookmakers</span>
                    <p class="helper" data-i18n="bookmakers_helper">Optional: limit results to the selected bookmakers.</p>
                  </div>
                  <div class="panel-actions">
                    <button type="button" class="chip-btn" data-quick-action="select" data-quick-target="bookmakers" data-i18n="select_all">Select all</button>
                    <button type="button" class="chip-btn" data-quick-action="clear" data-quick-target="bookmakers" data-i18n="clear_all">Clear</button>
                  </div>
                </div>
                <div class="panel-body">
                  <div id="bookmakers-list" class="bookmakers-grid">
                    {% for book in bookmaker_options %}
                    <div class="bookmaker-row">
                      <label class="checkbox">
                        <input type="checkbox" name="bookmakers" value="{{ book.key }}" {% if book.key in default_bookmaker_keys %}checked{% endif %} />
                        <span data-bookmaker-key="{{ book.key }}">{{ book.label }}</span>
                      </label>
                      <input
                        type="url"
                        inputmode="url"
                        class="bookmaker-url"
                        data-bookmaker-key="{{ book.key }}"
                        value="{{ bookmaker_links.get(book.key, '') }}"
                        placeholder="https://..."
                      />
                    </div>
                    {% endfor %}
                  </div>
                </div>
                <div class="panel-foot">
                  <p class="helper" data-i18n="bookmaker_links_helper">Customize base URLs used when opening books.</p>
                  <label class="checkbox all-toggle">
                    <input type="checkbox" id="all-bookmakers" {% if not default_bookmaker_keys %}checked{% endif %} />
                    <span data-i18n="all_bookmakers_label">Use all available bookmakers</span>
                  </label>
                </div>
              </section>
              <section class="advanced-panel advanced-panel-wide">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="commission_label">Exchange Commission (%)</span>
                    <p class="helper" data-i18n="commission_helper">Applied to Betfair, Matchbook, Sportsbet Exchange, etc.</p>
                  </div>
                </div>
                <div class="panel-body">
                  <input type="number" id="commission-input" min="0" max="20" step="0.1" value="{{ default_commission_percent }}" />
                  <p class="helper" data-i18n="commission_note">Net ROI/EV already reflects this commission.</p>
                </div>
              </section>
              <section class="advanced-panel advanced-panel-wide">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="notify_label">Notifications</span>
                    <p class="helper" data-i18n="notify_helper">Browser permission is required for popup notifications.</p>
                  </div>
                </div>
                <div class="panel-body">
                  <label class="checkbox">
                    <input type="checkbox" id="notify-sound-toggle" {% if default_notify_sound_enabled %}checked{% endif %} />
                    <span data-i18n="notify_sound">Sound alert</span>
                  </label>
                  <label class="checkbox">
                    <input type="checkbox" id="notify-popup-toggle" {% if default_notify_popup_enabled %}checked{% endif %} />
                    <span data-i18n="notify_popup">Popup notification</span>
                  </label>
                </div>
              </section>
              <section class="advanced-panel advanced-panel-wide">
                <div class="panel-head">
                  <div class="panel-title">
                    <span class="field-label" data-i18n="auto_scan_label">Auto Scan</span>
                    <p class="helper" data-i18n="auto_scan_helper">Runs a scan on a timer using your current filters.</p>
                  </div>
                </div>
                <div class="panel-body">
                  <div class="auto-scan-controls">
                    <label class="checkbox">
                      <input type="checkbox" id="auto-scan-toggle" {% if default_auto_scan_enabled %}checked{% endif %} />
                      <span data-i18n="auto_scan_enable">Enable auto scan</span>
                    </label>
                    <div class="auto-scan-interval">
                      <span class="auto-scan-label" data-i18n="auto_scan_interval_label">Interval (min)</span>
                      <input type="number" id="auto-scan-interval" min="1" step="1" value="{{ default_auto_scan_minutes }}" />
                    </div>
                  </div>
                </div>
              </section>
            </div>
            <div class="advanced-actions">
              <button type="button" id="save-settings" class="secondary-btn" data-i18n="save_settings">Save Settings</button>
            </div>
          </div>
        </div>

        <div class="actions">
          <div class="action-buttons">
            <button type="submit" id="scan-btn" data-i18n="scan_now">Scan Now</button>
          </div>
          <div id="status" class="status"></div>
        </div>
      </form>
    </section>

    <section class="card scan-status" id="scan-status">
      <div class="scan-status-head">
        <h3 data-i18n="scan_status_title">Scan Status</h3>
      </div>
      <div class="scan-status-grid">
        <div class="status-chip" id="scan-status-chip" data-status="idle">
          <span class="status-label" data-i18n="scan_status_label">Status</span>
          <span id="scan-status-text">Idle</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_last_scan">Last Scan</span>
          <span id="scan-last-time">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_api_calls">API Calls</span>
          <span id="scan-api-calls">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_events">Events</span>
          <span id="scan-events">-</span>
        </div>
        <div class="status-chip">
          <span class="status-label" data-i18n="scan_sports">Sports</span>
          <span id="scan-sports">-</span>
        </div>
      </div>
      <div id="scan-errors" class="scan-errors hidden"></div>
    </section>
      </aside>
      <section class="content">
    <nav class="tabs">
      <button type="button" class="tab-btn active" data-tab="arbitrage" data-i18n="tab_arbitrage">Arbitrage</button>
      <button type="button" class="tab-btn" data-tab="middles" data-i18n="tab_middles">Middles</button>
      <button type="button" class="tab-btn" data-tab="plus-ev" data-i18n="tab_plus_ev">+EV</button>
    </nav>

    <section class="card arbitrage-config" id="arbitrage-config">
      <div class="arbitrage-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="arb_min_roi">Minimum Net ROI (%)</label>
          <input type="number" id="min-roi-input" min="-100" max="10" step="0.1" value="{{ default_min_roi }}" />
          <p class="helper" data-i18n="arb_min_roi_helper">Hide opportunities below this net ROI.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="arbitrage-sort">
            <option value="roi" data-i18n="sort_roi" {% if default_arbitrage_sort == 'roi' %}selected{% endif %}>Net ROI</option>
            <option value="profit" data-i18n="sort_profit" {% if default_arbitrage_sort == 'profit' %}selected{% endif %}>Profit</option>
            <option value="time" data-i18n="sort_time" {% if default_arbitrage_sort == 'time' %}selected{% endif %}>Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section class="card middle-config hidden" id="middles-config">
      <div class="middle-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="middle_min_gap">Minimum Gap (points)</label>
          <input type="number" id="min-gap-input" min="0" max="10" step="0.5" value="{{ default_min_gap }}" />
          <p class="helper" data-i18n="middle_min_gap_helper">Only show middles with at least this many points between the lines.</p>
        </div>
        <div class="field toggle-field">
          <label class="field-label" data-i18n="filters_label">Filters</label>
          <label class="checkbox">
            <input type="checkbox" id="positive-ev-toggle" {% if default_positive_ev_only %}checked{% endif %} />
            <span data-i18n="positive_ev_only">Show only positive EV middles</span>
          </label>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="middle-sort">
            <option value="ev" data-i18n="sort_ev" {% if default_middle_sort == 'ev' %}selected{% endif %}>Estimated EV</option>
            <option value="probability" data-i18n="sort_probability" {% if default_middle_sort == 'probability' %}selected{% endif %}>Probability</option>
            <option value="gap" data-i18n="sort_gap" {% if default_middle_sort == 'gap' %}selected{% endif %}>Gap size</option>
            <option value="time" data-i18n="sort_time" {% if default_middle_sort == 'time' %}selected{% endif %}>Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section class="card plus-config hidden" id="plus-ev-config">
      <div class="plus-config-grid">
        <div class="field">
          <label class="field-label" data-i18n="sharp_reference_book">Sharp Reference Book</label>
          <select id="sharp-book-select">
            {% for book in sharp_books %}
            <option value="{{ book.key }}" {% if book.key == default_sharp_book %}selected{% endif %}>{{ book.name }}</option>
            {% endfor %}
          </select>
          <p class="helper" data-i18n="sharp_book_helper">Used as the "true" odds source. Pinnacle recommended.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="min_edge_label">Minimum Edge (%)</label>
          <input type="number" id="min-edge-input" min="0" max="20" step="0.5" value="{{ default_min_edge_percent }}" />
          <p class="helper" data-i18n="min_edge_helper">Filter +EV bets below this edge.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="kelly_staking">Kelly Staking</label>
          <div class="kelly-grid">
            <input type="number" id="bankroll-input" min="0" step="50" value="{{ default_bankroll }}" />
            <select id="kelly-select">
              {% for opt in kelly_options %}
              <option value="{{ opt.value }}" data-kelly-value="{{ opt.value }}" {% if opt.value == default_kelly_fraction %}selected{% endif %}>{{ opt.label }}</option>
              {% endfor %}
            </select>
          </div>
          <p class="helper" data-i18n="kelly_helper">Bankroll + Kelly fraction are not persisted between scans.</p>
        </div>
        <div class="field">
          <label class="field-label" data-i18n="sort_by">Sort By</label>
          <select id="plus-ev-sort">
            <option value="edge" data-i18n="sort_edge" {% if default_plus_ev_sort == 'edge' %}selected{% endif %}>Edge %</option>
            <option value="ev" data-i18n="sort_ev_value" {% if default_plus_ev_sort == 'ev' %}selected{% endif %}>EV ($)</option>
            <option value="kelly" data-i18n="sort_kelly" {% if default_plus_ev_sort == 'kelly' %}selected{% endif %}>Kelly stake</option>
            <option value="time" data-i18n="sort_time" {% if default_plus_ev_sort == 'time' %}selected{% endif %}>Event time</option>
          </select>
        </div>
      </div>
    </section>

    <section id="arbitrage-panel">
      <section class="stats-row">
        <div class="stat-card" id="stat-opps">
          <span class="stat-label" data-i18n="stat_opportunities">Opportunities</span>
          <span class="stat-value">0</span>
        </div>
        <div class="stat-card" id="stat-events">
          <span class="stat-label" data-i18n="stat_events_scanned">Events Scanned</span>
          <span class="stat-value">0</span>
        </div>
        <div class="stat-card" id="stat-sports">
          <span class="stat-label" data-i18n="stat_sports">Sports</span>
          <span class="stat-value">0</span>
        </div>
        <div class="stat-card" id="stat-calls">
          <span class="stat-label" data-i18n="stat_api_calls">API Calls</span>
          <span class="stat-value">0</span>
        </div>
      </section>

      <section id="summary-info" class="card summary-info hidden"></section>
      <div id="partial-warning" class="alert warning hidden"></div>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="opportunities_title">Opportunities</h3>
          <div class="table-meta">
            <span id="table-count">0 results</span>
            <span class="muted" id="arb-sort-label" data-i18n="sorted_by_roi">Sorted by ROI</span>
          </div>
        </div>
        <div class="table-scroll">
          <table id="results-table">
            <thead>
              <tr>
                <th data-i18n="table_net_roi">Net ROI</th>
                <th data-i18n="table_gross_roi">Gross ROI</th>
                <th data-i18n="table_profit">Profit</th>
                <th data-i18n="table_exchange">Exchange</th>
                <th data-i18n="table_sport">Sport</th>
                <th data-i18n="table_event">Event</th>
                <th data-i18n="table_time">Time</th>
                <th data-i18n="table_market">Market</th>
                <th data-i18n="table_outcome_1">Outcome 1</th>
                <th data-i18n="table_outcome_2">Outcome 2</th>
                <th data-i18n="table_open">Open</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="table-empty" class="empty" data-i18n="empty_arbitrage">No arbitrage opportunities yet.</div>
      </section>
    </section>

    <section id="middles-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_middles_found">Middles Found</span>
          <span class="stat-value" id="middle-stat-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_positive_middles">+EV Middles</span>
          <span class="stat-value" id="middle-stat-positive">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_avg_ev">Avg EV</span>
          <span class="stat-value" id="middle-stat-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_best_ev">Best EV</span>
          <span class="stat-value" id="middle-stat-best">0%</span>
        </div>
      </section>

      <section id="middles-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="middles-sport-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card" id="middles-key-card">
          <div class="card-head">
            <h3 data-i18n="key_numbers_label">Key Numbers</h3>
          </div>
          <div id="middles-key-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="middles_title">Middles</h3>
          <div class="table-meta">
            <span id="middles-table-count">0 results</span>
            <span class="muted" id="middles-sort-label" data-i18n="sorted_by_ev">Sorted by EV</span>
          </div>
        </div>
        <div class="table-scroll">
          <table id="middles-table">
            <thead>
              <tr>
                <th data-i18n="table_ev">EV</th>
                <th data-i18n="table_prob">Prob</th>
                <th data-i18n="table_gap">Gap</th>
                <th data-i18n="table_sport">Sport</th>
                <th data-i18n="table_event">Event</th>
                <th data-i18n="table_time">Time</th>
                <th data-i18n="table_market">Market</th>
                <th data-i18n="table_side_a">Side A</th>
                <th data-i18n="table_side_b">Side B</th>
                <th data-i18n="table_middle">Middle</th>
                <th data-i18n="table_win_both">Win Both</th>
                <th data-i18n="table_miss">Miss</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="middles-empty" class="empty" data-i18n="empty_middles">No middle opportunities meet your filters.</div>
      </section>

      <section class="card middle-caveat">
        <p data-i18n-html="caveat_middles"><strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 &amp; 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.</p>
      </section>
    </section>

    <section id="plus-ev-panel" class="hidden">
      <section class="stats-row">
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_plus_ev_bets">+EV Bets</span>
          <span class="stat-value" id="plus-ev-count">0</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_avg_edge">Avg Edge</span>
          <span class="stat-value" id="plus-ev-avg">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_best_edge">Best Edge</span>
          <span class="stat-value" id="plus-ev-best">0%</span>
        </div>
        <div class="stat-card">
          <span class="stat-label" data-i18n="stat_total_ev">Total EV ($100)</span>
          <span class="stat-value" id="plus-ev-total">$0</span>
        </div>
      </section>

      <section id="plus-ev-summary-info" class="card summary-info hidden"></section>

      <section class="summary-grid">
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_sport">By Sport</h3>
          </div>
          <div id="plus-ev-sport-bars" class="bar-list"></div>
        </div>
        <div class="card summary-card">
          <div class="card-head">
            <h3 data-i18n="by_edge_band">By Edge Band</h3>
          </div>
          <div id="plus-ev-edge-bars" class="bar-list"></div>
        </div>
      </section>

      <section class="card results-card">
        <div class="card-head">
          <h3 data-i18n="plus_ev_title">+EV Opportunities</h3>
          <div class="table-meta">
            <span id="plus-ev-table-count">0 results</span>
            <span class="muted" id="plus-ev-sort-label" data-i18n="sorted_by_edge">Sorted by Edge</span>
          </div>
        </div>
        <div class="table-scroll">
          <table id="plus-ev-table">
            <thead>
              <tr>
                <th data-i18n="table_edge">Edge</th>
                <th data-i18n="table_ev_100">EV ($100)</th>
                <th data-i18n="table_kelly">Kelly</th>
                <th data-i18n="table_sport">Sport</th>
                <th data-i18n="table_event">Event</th>
                <th data-i18n="table_time">Time</th>
                <th data-i18n="table_market">Market</th>
                <th data-i18n="table_bet">Bet</th>
                <th data-i18n="table_soft_odds">Soft Odds</th>
                <th data-i18n="table_fair_odds">Fair Odds</th>
                <th data-i18n="table_true_prob">True Prob</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="plus-ev-empty" class="empty" data-i18n="empty_plus_ev">No +EV bets at the current thresholds.</div>
      </section>

      <section class="card middle-caveat">
        <p data-i18n-html="caveat_plus_ev"><strong>Understanding +EV Betting:</strong> Sharp books (Pinnacle, Betfair, Matchbook) provide near "true" odds. When a soft book posts a higher price than fair value, the bet has positive expected value. +EV bets still lose roughly half the time—the edge shows up over many wagers. Kelly staking helps size bets, but variance can still be high. Always confirm odds before betting; edges disappear quickly.</p>
      </section>
    </section>
  
      </section>
    </div>
</main>

  <div
    id="edge-scanner-config"
    data-has-env-key="{{ 'true' if has_env_key else 'false' }}"
    data-sharp-books='{{ sharp_books | tojson }}'
    data-default-sharp-book="{{ default_sharp_book }}"
    data-default-min-edge-percent="{{ default_min_edge_percent }}"
    data-default-bankroll="{{ default_bankroll }}"
    data-default-kelly-fraction="{{ default_kelly_fraction }}"
    data-default-odds-format="{{ default_odds_format }}"
    data-default-density="{{ default_density }}"
    data-default-theme="{{ default_theme }}"
    data-default-language="{{ default_language }}"
    data-kelly-options='{{ kelly_options | tojson }}'
    data-bookmaker-links='{{ bookmaker_links | tojson }}'
    hidden
  ></div>

  <script>
    const configEl = document.getElementById('edge-scanner-config');
    const parseConfigJson = (value, fallback) => {
      if (!value) return fallback;
      try {
        return JSON.parse(value);
      } catch (error) {
        return fallback;
      }
    };
    const appConfig = configEl
      ? {
          hasEnvKey: configEl.dataset.hasEnvKey === 'true',
          sharpBooks: parseConfigJson(configEl.dataset.sharpBooks, []),
          defaultSharpBook: configEl.dataset.defaultSharpBook || '',
          defaultMinEdgePercent: parseFloat(configEl.dataset.defaultMinEdgePercent || '0'),
          defaultBankroll: parseFloat(configEl.dataset.defaultBankroll || '0'),
          defaultKellyFraction: parseFloat(configEl.dataset.defaultKellyFraction || '0'),
          defaultOddsFormat: configEl.dataset.defaultOddsFormat || '',
          defaultDensity: configEl.dataset.defaultDensity || '',
          defaultTheme: configEl.dataset.defaultTheme || '',
          defaultLanguage: configEl.dataset.defaultLanguage || '',
          kellyOptions: parseConfigJson(configEl.dataset.kellyOptions, []),
          bookmakerLinks: parseConfigJson(configEl.dataset.bookmakerLinks, {})
        }
      : {};
    let bookmakerLinks = { ...(appConfig.bookmakerLinks || {}) };
    const hasEnvKey = appConfig.hasEnvKey === true || appConfig.hasEnvKey === 'true';
    const form = document.getElementById('scan-form');
    const apiKeyInput = document.getElementById('api-key');
    const stakeInput = document.getElementById('stake-input');
    const scanBtn = document.getElementById('scan-btn');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary-info');
    const resultsBody = document.querySelector('#results-table tbody');
    const emptyState = document.getElementById('table-empty');
    const allSportsToggle = document.getElementById('all-sports');
    const allBookmakersToggle = document.getElementById('all-bookmakers');
    const bookmakersList = document.getElementById('bookmakers-list');
    const bookmakerLinksList = bookmakersList;
    const saveSettingsBtn = document.getElementById('save-settings');
      const advancedSummary = document.getElementById('advanced-summary');
      const advancedModal = document.getElementById('advanced-modal');
      const openAdvancedBtn = document.getElementById('open-advanced');
      const closeAdvancedBtn = document.getElementById('close-advanced');
      const quickActionButtons = document.querySelectorAll('[data-quick-action][data-quick-target]');
    const tableCount = document.getElementById('table-count');
    const arbSortLabel = document.getElementById('arb-sort-label');
    const statOpps = document.querySelector('#stat-opps .stat-value');
    const statEvents = document.querySelector('#stat-events .stat-value');
    const statSports = document.querySelector('#stat-sports .stat-value');
    const statCalls = document.querySelector('#stat-calls .stat-value');
    const themeToggle = document.getElementById('theme-toggle');
    const toggleKeyBtn = document.getElementById('toggle-key');
    let currencyFormatter;
    const partialWarning = document.getElementById('partial-warning');
    const commissionInput = document.getElementById('commission-input');
    const tabs = document.querySelectorAll('.tab-btn');
    const arbitragePanel = document.getElementById('arbitrage-panel');
    const middlesPanel = document.getElementById('middles-panel');
    const plusEvPanel = document.getElementById('plus-ev-panel');
    const middlesConfig = document.getElementById('middles-config');
    const plusEvConfig = document.getElementById('plus-ev-config');
    const minGapInput = document.getElementById('min-gap-input');
    const positiveEvToggle = document.getElementById('positive-ev-toggle');
    const middleSortSelect = document.getElementById('middle-sort');
    const middleStatCount = document.getElementById('middle-stat-count');
    const middleStatPositive = document.getElementById('middle-stat-positive');
    const middleStatAvg = document.getElementById('middle-stat-avg');
    const middleStatBest = document.getElementById('middle-stat-best');
    const middleSummaryInfo = document.getElementById('middles-summary-info');
    const middleSportBars = document.getElementById('middles-sport-bars');
    const middleKeyBars = document.getElementById('middles-key-bars');
    const middleKeyCard = document.getElementById('middles-key-card');
    const middlesTableBody = document.querySelector('#middles-table tbody');
    const middlesTableCount = document.getElementById('middles-table-count');
    const middlesSortLabel = document.getElementById('middles-sort-label');
    const middlesEmpty = document.getElementById('middles-empty');
    const sharpSelect = document.getElementById('sharp-book-select');
    const minEdgeInput = document.getElementById('min-edge-input');
    const bankrollInput = document.getElementById('bankroll-input');
    const kellySelect = document.getElementById('kelly-select');
    const plusEvSortSelect = document.getElementById('plus-ev-sort');
    const plusEvCount = document.getElementById('plus-ev-count');
    const plusEvAvg = document.getElementById('plus-ev-avg');
    const plusEvBest = document.getElementById('plus-ev-best');
    const plusEvTotal = document.getElementById('plus-ev-total');
    const plusEvSummaryInfo = document.getElementById('plus-ev-summary-info');
    const plusEvSportBars = document.getElementById('plus-ev-sport-bars');
    const plusEvEdgeBars = document.getElementById('plus-ev-edge-bars');
    const plusEvTableBody = document.querySelector('#plus-ev-table tbody');
    const plusEvTableCount = document.getElementById('plus-ev-table-count');
    const plusEvSortLabel = document.getElementById('plus-ev-sort-label');
    const plusEvEmpty = document.getElementById('plus-ev-empty');
    const oddsToggle = document.getElementById('odds-toggle');
    const languageToggle = document.getElementById('language-toggle');
    const densityToggle = document.getElementById('density-toggle');
    const arbitrageConfig = document.getElementById('arbitrage-config');
    const minRoiInput = document.getElementById('min-roi-input');
    const arbitrageSortSelect = document.getElementById('arbitrage-sort');
    const scanStatusChip = document.getElementById('scan-status-chip');
    const scanStatusText = document.getElementById('scan-status-text');
    const scanLastTime = document.getElementById('scan-last-time');
    const scanApiCalls = document.getElementById('scan-api-calls');
      const scanEvents = document.getElementById('scan-events');
      const scanSports = document.getElementById('scan-sports');
      const scanErrors = document.getElementById('scan-errors');
      const autoScanToggle = document.getElementById('auto-scan-toggle');
      const autoScanIntervalInput = document.getElementById('auto-scan-interval');
      const notifySoundToggle = document.getElementById('notify-sound-toggle');
      const notifyPopupToggle = document.getElementById('notify-popup-toggle');
    const defaultCommissionPercent = commissionInput ? parseFloat(commissionInput.value) || 5 : 5;
    let lastCommissionRate = defaultCommissionPercent / 100;
    let lastScanData = null;
    let activeTab = 'arbitrage';
    let oddsFormat = localStorage.getItem('edge-odds-format') || appConfig.defaultOddsFormat || 'decimal';
    let densityMode = localStorage.getItem('edge-density') || appConfig.defaultDensity || 'comfort';
    let isScanning = false;
      let lastStatus = null;
      let lastFocusedElement = null;
      let autoScanTimer = null;
      let notificationAudioContext = null;

    const TRANSLATIONS = {
      en: {
        tagline: 'Arbitrage / Middles / +EV',
        odds_decimal: 'Decimal',
        odds_american: 'American',
        toggle_theme: 'Toggle theme',
        toggle_language: 'Toggle language',
        toggle_density: 'Toggle density',
        lang_en: 'EN',
        lang_zh: '\u4e2d\u6587',
        api_key_label: 'API Key',
                env_key_notice: 'Using API key from .env',
        api_key_show: 'Show API key',
                api_key_hide: 'Hide API key',
        show_short: 'Show',
        hide_short: 'Hide',
        theme_light: 'Light',
        theme_dark: 'Dark',
        total_stake_label: 'Total Stake ($)',
        stake_helper: 'Used for arbitrage + middles stake splits.',
        sports_label: 'Sports',
        all_sports_label: 'Scan all active sports (uses more API credits)',
        sports_helper: 'Each selected sport consumes one API request.',
        bookmakers_label: 'Bookmakers',
        all_bookmakers_label: 'Use all available bookmakers',
        bookmakers_helper: 'Optional: limit results to the selected bookmakers.',
        bookmaker_links_label: 'Bookmaker Links',
        bookmaker_links_helper: 'Customize open URLs. Supports placeholders like {event_id}, {home_team}, {away_team}. Leave blank to skip.',
        auto_scan_label: 'Auto Scan',
        auto_scan_enable: 'Enable auto scan',
        auto_scan_interval_label: 'Interval (min)',
        auto_scan_helper: 'Runs a scan on a timer using your current filters.',
          advanced_settings: 'Advanced settings',
          advanced_hint: 'Less frequently adjusted options live here.',
          advanced_summary: 'Sports {sports} | Books {books}',
          summary_all: 'All',
          notify_label: 'Notifications',
          notify_sound: 'Sound alert',
          notify_popup: 'Popup notification',
          notify_helper: 'Browser permission is required for popup notifications.',
          notify_body: 'Arb {arb} | Middles {middle} | +EV {plus}',
          select_all: 'Select all',
          clear_all: 'Clear',
          close: 'Close',
        regions_label: 'Regions',
        regions_helper: 'Select at least one region. EU is always included for sharp reference.',
        commission_label: 'Exchange Commission (%)',
        commission_helper: 'Applied to Betfair, Matchbook, Sportsbet Exchange, etc.',
        commission_note: 'Net ROI/EV already reflects this commission.',
        scan_now: 'Scan Now',
        save_settings: 'Save settings',
        scanning: 'Scanning...',
        scanning_wait: 'Scanning, please wait...',
        density_comfort: 'Comfort',
        density_compact: 'Compact',
        tab_arbitrage: 'Arbitrage',
        tab_middles: 'Middles',
        tab_plus_ev: '+EV',
        arb_min_roi: 'Minimum Net ROI (%)',
        arb_min_roi_helper: 'Hide opportunities below this net ROI.',
        middle_min_gap: 'Minimum Gap (points)',
        middle_min_gap_helper: 'Only show middles with at least this many points between the lines.',
        filters_label: 'Filters',
        positive_ev_only: 'Show only positive EV middles',
        sort_by: 'Sort By',
        sort_roi: 'Net ROI',
        sort_profit: 'Profit',
        sort_ev: 'Estimated EV',
        sort_probability: 'Probability',
        sort_gap: 'Gap size',
        sort_time: 'Event time',
        sharp_reference_book: 'Sharp Reference Book',
        sharp_book_helper: 'Used as the \"true\" odds source. Pinnacle recommended.',
        min_edge_label: 'Minimum Edge (%)',
        min_edge_helper: 'Filter +EV bets below this edge.',
        kelly_staking: 'Kelly Staking',
        kelly_helper: 'Bankroll + Kelly fraction are not persisted between scans.',
        sort_edge: 'Edge %',
        sort_ev_value: 'EV ($)',
        sort_kelly: 'Kelly stake',
        kelly_full: 'Full Kelly',
        kelly_half: 'Half Kelly',
        kelly_quarter: 'Quarter Kelly',
        kelly_tenth: 'Tenth Kelly',
        stat_opportunities: 'Opportunities',
        stat_events_scanned: 'Events Scanned',
        stat_sports: 'Sports',
        stat_api_calls: 'API Calls',
        stat_middles_found: 'Middles Found',
        stat_positive_middles: '+EV Middles',
        stat_avg_ev: 'Avg EV',
        stat_best_ev: 'Best EV',
        stat_plus_ev_bets: '+EV Bets',
        stat_avg_edge: 'Avg Edge',
        stat_best_edge: 'Best Edge',
        stat_total_ev: 'Total EV ($100)',
        scan_status_title: 'Scan Status',
        scan_status_label: 'Status',
        scan_last_scan: 'Last Scan',
        scan_api_calls: 'API Calls',
        scan_events: 'Events',
        scan_sports: 'Sports',
        status_idle: 'Idle',
        status_ready: 'Ready',
        status_scanning: 'Scanning',
        status_error: 'Error',
        status_partial: 'Partial',
        scan_errors: '<strong>Errors:</strong> {details}',
        by_roi_band: 'By ROI Band',
        by_sport: 'By Sport',
        by_edge_band: 'By Edge Band',
        key_numbers_label: 'Key Numbers',
        opportunities_title: 'Opportunities',
        middles_title: 'Middles',
        plus_ev_title: '+EV Opportunities',
        sorted_by_roi: 'Sorted by ROI',
        sorted_by_ev: 'Sorted by EV',
        sorted_by_edge: 'Sorted by Edge',
        sorted_by_profit: 'Sorted by Profit',
        sorted_by_time: 'Sorted by Time',
        sorted_by_probability: 'Sorted by Probability',
        sorted_by_gap: 'Sorted by Gap',
        sorted_by_kelly: 'Sorted by Kelly',
        sorted_by_ev_value: 'Sorted by EV',
        table_net_roi: 'Net ROI',
        table_gross_roi: 'Gross ROI',
        table_profit: 'Profit',
        table_exchange: 'Exchange',
        table_sport: 'Sport',
        table_event: 'Event',
        table_time: 'Time',
        table_market: 'Market',
        table_outcome_1: 'Outcome 1',
        table_outcome_2: 'Outcome 2',
        table_open: 'Open',
        table_ev: 'EV',
        table_prob: 'Prob',
        table_gap: 'Gap',
        table_side_a: 'Side A',
        table_side_b: 'Side B',
        table_middle: 'Middle',
        table_win_both: 'Win Both',
        table_miss: 'Miss',
        table_edge: 'Edge',
        table_ev_100: 'EV ($100)',
        table_kelly: 'Kelly',
        table_bet: 'Bet',
        table_soft_odds: 'Soft Odds',
        table_fair_odds: 'Fair Odds',
        table_true_prob: 'True Prob',
        empty_arbitrage: 'No arbitrage opportunities yet.',
        empty_middles: 'No middle opportunities meet your filters.',
        empty_plus_ev: 'No +EV bets at the current thresholds.',
        caveat_middles:
          '<strong>Understanding Middles:</strong> Middles are high-variance plays. They typically lose small amounts and win big when the final score lands inside the gap. Probabilities are estimates based on historical scoring distributions (NFL key numbers like 3 &amp; 7 dramatically boost EV). Treat the EV as guidance, not a guarantee, and stake responsibly.',
        caveat_plus_ev:
          '<strong>Understanding +EV Betting:</strong> Sharp books (Pinnacle, Betfair, Matchbook) provide near \"true\" odds. When a soft book posts a higher price than fair value, the bet has positive expected value. +EV bets still lose roughly half the time - the edge shows up over many wagers. Kelly staking helps size bets, but variance can still be high. Always confirm odds before betting; edges disappear quickly.',
        summary_title: 'Summary',
        summary_found: 'Found {count} opportunities across {events} events in {sports} sports.',
        summary_profit: 'Total potential profit: {profit}{staked}',
        summary_profit_staked: ' on {staked} staked',
        summary_calls: 'API calls used: {calls}{regions}',
        summary_regions_suffix: ' | Regions: {regions}',
        summary_commission: 'Exchange commission applied: {commission}.',
        summary_roi_note: 'ROI = return on total stake. 2% ROI means $2 profit on a $100 stake.',
        filters_applied: 'Showing {shown} of {total} opportunities after filters.',
        middle_summary_counts: 'Middles matching filters: {count}, with {positive} positive EV.',
        middle_summary_avg: 'Average EV: {avg}{best}',
        middle_summary_best: ' | Best: {event}',
        middle_spreads_only: 'Spreads only',
        plus_summary: '+EV bets: {count} | Average edge {avg}{best}',
        plus_summary_best: ' | Best: {event}',
        results_count: '{count} results',
        results_profit: '{count} results | {profit} profit',
        partial_results: '<strong>Partial results:</strong> Failed to fetch odds for {details}.',
        tbd: 'TBD',
        gross: 'Gross',
        net_at: 'Net @ {odds}',
        odds_label: 'Odds: {odds}',
        stake_label: 'Stake: {stake}',
        exchange: 'Exchange',
        no: 'No',
        no_data: 'No data',
        open_books: 'Open',
        open_books_missing: 'No bookmaker links available for this opportunity.',
        open_books_blocked: 'Pop-up blocked. Allow pop-ups to open bookmakers.',
        gap_points: '{points} pts',
        gap_separator: ' / ',
        kelly_roll: '{percent}% roll',
        net_roi_negative: 'Net ROI is negative after commission.',
        scan_complete: 'Scan complete at {time}',
        scan_failed: 'Scan failed',
        settings_saved: 'Settings saved',
        enter_api_key: 'Please enter your API key.',
        select_region: 'Select at least one region.',
        select_bookmakers: 'Select at least one bookmaker.',
        unknown: 'Unknown',
        unknown_error: 'Unknown error',
      },
      zh: {
        tagline: '套利 / 中间盘 / +EV',
        odds_decimal: '十进制',
        odds_american: '美式',
        toggle_theme: '切换主题',
        toggle_language: '切换语言',
        toggle_density: '切换密度',
        lang_en: 'EN',
        lang_zh: '\u4e2d\u6587',
        api_key_label: 'API 密钥',
                        env_key_notice: '使用 .env 中的 API 密钥',
        api_key_show: '显示 API 密钥',
                        api_key_hide: '隐藏 API 密钥',
                show_short: '显示',
                hide_short: '隐藏',
                theme_light: '浅色',
                theme_dark: '深色',
        total_stake_label: '总下注金额 ($)',
        stake_helper: '用于套利和中间盘的下注拆分计算。',
        sports_label: '体育项目',
        all_sports_label: '扫描所有活跃项目（消耗更多 API 额度）',
        sports_helper: '每个已选项目会消耗一次 API 请求。',
        bookmakers_label: '博彩平台',
        all_bookmakers_label: '使用所有可用平台',
        bookmakers_helper: '可选：仅扫描选定的平台。',
        bookmaker_links_label: '平台链接',
        bookmaker_links_helper: '自定义自动打开网址。支持 {event_id}、{home_team}、{away_team} 占位符，留空则不打开该平台。',
        auto_scan_label: '自动扫描',
        auto_scan_enable: '启用自动扫描',
        auto_scan_interval_label: '扫描间隔（分钟）',
        auto_scan_helper: '按当前筛选条件定时自动扫描。',
        advanced_settings: '高级设置',
        advanced_hint: '不常调整的选项放在这里。',
                advanced_summary: '项目 {sports} | 平台 {books}',
          summary_all: '全部',
          notify_label: '通知',
          notify_sound: '铃声提示',
          notify_popup: '弹窗通知',
          notify_helper: '弹窗通知需要浏览器授权。',
          notify_body: '套利 {arb} | 中盘 {middle} | +EV {plus}',
          select_all: '全选',
          clear_all: '清空',
          close: '关闭',
        regions_label: '地区',
        regions_helper: '至少选择一个地区。为锐盘参考将始终包含 EU。',
        commission_label: '交易所手续费 (%)',
        commission_helper: '适用于 Betfair、Matchbook、Sportsbet Exchange 等。',
        commission_note: '净 ROI/EV 已计入该手续费。',
        scan_now: '开始扫描',
        save_settings: '保存设置',
        scanning: '扫描中...',
        scanning_wait: '正在扫描，请稍候...',
        density_comfort: '舒适',
        density_compact: '紧凑',
        tab_arbitrage: '套利',
        tab_middles: '中间盘',
        tab_plus_ev: '+EV',
        arb_min_roi: '最小净 ROI (%)',
        arb_min_roi_helper: '隐藏低于该净 ROI 的机会。',
        middle_min_gap: '最小间隔（分）',
        middle_min_gap_helper: '仅显示盘口差至少达到该分数的中间盘。',
        filters_label: '筛选',
        positive_ev_only: '仅显示正 EV 的中间盘',
        sort_by: '排序',
        sort_roi: '净 ROI',
        sort_profit: '利润',
        sort_ev: '预计 EV',
        sort_probability: '概率',
        sort_gap: '间隔大小',
        sort_time: '比赛时间',
        sharp_reference_book: '锐盘参考书商',
        sharp_book_helper: '作为“真实”赔率参考来源，推荐 Pinnacle。',
        min_edge_label: '最小 Edge (%)',
        min_edge_helper: '过滤低于该边际的 +EV 投注。',
        kelly_staking: '凯利下注',
        kelly_helper: '资金和凯利比例不会在扫描之间保存。',
        sort_edge: 'Edge %',
        sort_ev_value: 'EV ($)',
        sort_kelly: '凯利下注',
        kelly_full: '全凯利',
        kelly_half: '半凯利',
        kelly_quarter: '四分之一凯利',
        kelly_tenth: '十分之一凯利',
        stat_opportunities: '机会',
        stat_events_scanned: '扫描赛事',
        stat_sports: '项目数',
        stat_api_calls: 'API 调用',
        stat_middles_found: '中间盘数量',
        stat_positive_middles: '+EV 中间盘',
        stat_avg_ev: '平均 EV',
        stat_best_ev: '最高 EV',
        stat_plus_ev_bets: '+EV 投注',
        stat_avg_edge: '平均 Edge',
        stat_best_edge: '最高 Edge',
        stat_total_ev: '总 EV（$100）',
        scan_status_title: '扫描状态',
        scan_status_label: '状态',
        scan_last_scan: '上次扫描',
        scan_api_calls: 'API 调用',
        scan_events: '赛事数',
        scan_sports: '项目数',
        status_idle: '空闲',
        status_ready: '就绪',
        status_scanning: '扫描中',
        status_error: '错误',
        status_partial: '部分结果',
        scan_errors: '<strong>错误：</strong>{details}',
        by_roi_band: '按 ROI 区间',
        by_sport: '按项目',
        by_edge_band: '按 Edge 区间',
        key_numbers_label: '关键分差',
        opportunities_title: '机会',
        middles_title: '中间盘',
        plus_ev_title: '+EV 机会',
        sorted_by_roi: '按 ROI 排序',
        sorted_by_ev: '按 EV 排序',
        sorted_by_edge: '按 Edge 排序',
        sorted_by_profit: '按利润排序',
        sorted_by_time: '按时间排序',
        sorted_by_probability: '按概率排序',
        sorted_by_gap: '按间隔排序',
        sorted_by_kelly: '按凯利排序',
        sorted_by_ev_value: '按 EV 排序',
        table_net_roi: '净 ROI',
        table_gross_roi: '总 ROI',
        table_profit: '利润',
        table_exchange: '交易所',
        table_sport: '项目',
        table_event: '赛事',
        table_time: '时间',
        table_market: '盘口',
        table_outcome_1: '选项 1',
        table_outcome_2: '选项 2',
        table_open: '打开',
        table_ev: 'EV',
        table_prob: '概率',
        table_gap: '间隔',
        table_side_a: 'A 边',
        table_side_b: 'B 边',
        table_middle: '中间区间',
        table_win_both: '两边全赢',
        table_miss: '未命中',
        table_edge: 'Edge',
        table_ev_100: 'EV ($100)',
        table_kelly: '凯利',
        table_bet: '投注',
        table_soft_odds: '软盘赔率',
        table_fair_odds: '公平赔率',
        table_true_prob: '真实概率',
        empty_arbitrage: '暂无套利机会。',
        empty_middles: '没有符合筛选条件的中间盘。',
        empty_plus_ev: '当前阈值下暂无 +EV 投注。',
        caveat_middles:
          '<strong>理解中间盘：</strong>中间盘属于高波动玩法，大多数时候小亏，比分落在区间内时大赢。概率为历史分布估算（NFL 关键分差如 3、7 会显著提升 EV）。请将 EV 视为参考并谨慎下注。',
        caveat_plus_ev:
          '<strong>理解 +EV 投注：</strong>锐盘（Pinnacle、Betfair、Matchbook）提供接近“真实”的赔率。当软盘给出高于公平赔率的价格时，该投注为正期望。+EV 投注仍有约一半时间会输，优势来自长期。凯利法可帮助控制下注规模，但波动仍然存在。下注前务必确认赔率，优势会迅速消失。',
        summary_title: '概览',
        summary_found: '共发现 {count} 个机会，覆盖 {events} 场赛事、{sports} 个项目。',
        summary_profit: '潜在总利润：{profit}{staked}',
        summary_profit_staked: '（总下注 {staked}）',
        summary_calls: 'API 调用次数：{calls}{regions}',
        summary_regions_suffix: ' | 地区：{regions}',
        summary_commission: '已计入交易所手续费：{commission}。',
        summary_roi_note: 'ROI 为总下注回报率。2% ROI 意味着下注 $100 约盈利 $2。',
        filters_applied: '筛选后显示 {shown}/{total} 个机会。',
        middle_summary_counts: '符合筛选的中间盘：{count}，其中 {positive} 为正 EV。',
        middle_summary_avg: '平均 EV：{avg}{best}',
        middle_summary_best: ' | 最佳：{event}',
        middle_spreads_only: '仅让分',
        plus_summary: '+EV 投注：{count} | 平均 Edge {avg}{best}',
        plus_summary_best: ' | 最佳：{event}',
        results_count: '{count} 条结果',
        results_profit: '{count} 条结果 | 利润 {profit}',
        partial_results: '<strong>部分结果：</strong>以下项目未能获取赔率：{details}。',
        tbd: '待定',
        gross: '总',
        net_at: '净 @ {odds}',
        odds_label: '赔率：{odds}',
        stake_label: '下注：{stake}',
        exchange: '交易所',
        no: '否',
        no_data: '暂无数据',
        open_books: '打开',
        open_books_missing: '暂无可打开的平台链接。',
        open_books_blocked: '弹窗被拦截，请允许弹窗后重试。',
        gap_points: '{points} 分',
        gap_separator: ' / ',
        kelly_roll: '{percent}% 资金',
        net_roi_negative: '计入手续费后净 ROI 为负。',
        scan_complete: '扫描完成：{time}',
        scan_failed: '扫描失败',
        settings_saved: '设置已保存',
        enter_api_key: '请输入 API 密钥。',
        select_region: '请至少选择一个地区。',
        select_bookmakers: '请至少选择一个平台。',
        unknown: '未知',
        unknown_error: '未知错误',
      },
    };

    const SPORT_KEY_LABELS = {
      zh: {
        americanfootball_nfl: 'NFL',
        basketball_nba: 'NBA',
        baseball_mlb: 'MLB',
        icehockey_nhl: 'NHL',
        soccer_epl: '英超',
        soccer_spain_la_liga: '西甲',
        soccer_germany_bundesliga: '德甲',
        soccer_italy_serie_a: '意甲',
        soccer_france_ligue_one: '法甲',
        soccer_usa_mls: '美职联',
      },
    };

    const SPORT_LABELS = {
      zh: {
        NFL: 'NFL',
        NBA: 'NBA',
        MLB: 'MLB',
        NHL: 'NHL',
        'Premier League': '英超',
        'La Liga': '西甲',
        Bundesliga: '德甲',
        'Serie A': '意甲',
        'Ligue 1': '法甲',
        MLS: '美职联',
        Other: '其他',
      },
    };

    const REGION_LABELS = {
      zh: {
        us: '美国',
        us2: '美国（更多）',
        uk: '英国',
        eu: '欧洲',
        au: '澳大利亚',
      },
    };

    const MARKET_LABELS = {
      zh: {
        h2h: '胜负',
        spreads: '让分',
        totals: '大小分',
      },
    };

    let activeLanguage = localStorage.getItem('edge-language') || appConfig.defaultLanguage;
    if (!activeLanguage) {
      activeLanguage = (navigator.language || '').toLowerCase().startsWith('zh') ? 'zh' : 'en';
    }
    let activeLocale = activeLanguage === 'zh' ? 'zh-CN' : 'en-US';
    currencyFormatter = createCurrencyFormatter(activeLocale);
    document.documentElement.dataset.density = densityMode;

    function t(key, params = {}) {
      const table = TRANSLATIONS[activeLanguage] || TRANSLATIONS.en || {};
      const fallback = TRANSLATIONS.en || {};
      let template = table[key] ?? fallback[key] ?? key;
      Object.entries(params).forEach(([name, value]) => {
        template = template.replace(new RegExp(`\\{${name}\\}`, 'g'), () => String(value));
      });
      return template;
    }

    function createCurrencyFormatter(locale) {
      return new Intl.NumberFormat(locale, { style: 'currency', currency: 'USD' });
    }

    function applyTranslations() {
      document.documentElement.lang = activeLocale;
      document.querySelectorAll('[data-i18n]').forEach((el) => {
        const key = el.dataset.i18n;
        el.textContent = t(key);
      });
      document.querySelectorAll('[data-i18n-html]').forEach((el) => {
        const key = el.dataset.i18nHtml;
        el.innerHTML = t(key);
      });
      if (themeToggle) {
        themeToggle.title = t('toggle_theme');
      }
      if (closeAdvancedBtn) {
        closeAdvancedBtn.setAttribute('aria-label', t('close'));
      }
      if (languageToggle) {
        languageToggle.setAttribute('aria-label', t('toggle_language'));
      }
      if (densityToggle) {
        densityToggle.setAttribute('aria-label', t('toggle_density'));
      }
      updateLanguageToggle();
      updateOddsToggle();
      updateDensityToggle();
      updateSportLabels();
      updateRegionLabels();
      updateKellyOptions();
      updateThemeToggleText();
      updateToggleKeyLabel();
      updateAdvancedSummary();
      updateScanButtonText();
      updateArbSortLabel();
      updateMiddlesSortLabel();
      updatePlusEvSortLabel();
      refreshStatus();
      setActiveTab(activeTab);
      applyScanStatus(scanStatusChip ? scanStatusChip.dataset.status : 'idle');
      updateScanMeta(lastScanData);
      renderPartialWarning(lastScanData);
    }

    function setLanguage(nextLang) {
      const normalized = TRANSLATIONS[nextLang] ? nextLang : 'en';
      if (normalized === activeLanguage) return;
      activeLanguage = normalized;
      activeLocale = activeLanguage === 'zh' ? 'zh-CN' : 'en-US';
      localStorage.setItem('edge-language', activeLanguage);
      currencyFormatter = createCurrencyFormatter(activeLocale);
      applyTranslations();
      renderPartialWarning(lastScanData);
    }

    function updateLanguageToggle() {
      if (!languageToggle) return;
      languageToggle.querySelectorAll('span').forEach((span) => {
        span.classList.toggle('active', span.dataset.lang === activeLanguage);
      });
    }

    function updateDensityToggle() {
      if (!densityToggle) return;
      densityToggle.querySelectorAll('span').forEach((span) => {
        span.classList.toggle('active', span.dataset.density === densityMode);
      });
      document.documentElement.dataset.density = densityMode;
    }

    function updateScanButtonText() {
      if (!scanBtn) return;
      scanBtn.textContent = isScanning ? t('scanning') : t('scan_now');
    }

    function updateThemeToggleText() {
      if (!themeToggle) return;
      const current = document.documentElement.dataset.theme || 'light';
      const key = current === 'dark' ? 'theme_dark' : 'theme_light';
      themeToggle.textContent = t(key);
    }

    function updateToggleKeyLabel() {
      if (!toggleKeyBtn || !apiKeyInput) return;
      const key = apiKeyInput.type === 'password' ? 'api_key_show' : 'api_key_hide';
      toggleKeyBtn.setAttribute('aria-label', t(key));
      const shortKey = apiKeyInput.type === 'password' ? 'show_short' : 'hide_short';
      toggleKeyBtn.textContent = t(shortKey);
    }

    function collectCheckedLabels(name) {
      if (!form) return [];
      return Array.from(form.querySelectorAll(`input[name="${name}"]:checked`))
        .map((input) => {
          const label = input.closest('label');
          const span = label ? label.querySelector('span') : null;
          return (span ? span.textContent : input.value || '').trim();
        })
        .filter(Boolean);
    }

    function updateAdvancedSummary() {
      if (!advancedSummary || !form) return;
      const sportsLabels = collectCheckedLabels('sports');
      const booksLabels = collectCheckedLabels('bookmakers');
      const sportsSelected = sportsLabels.length;
      const booksSelected = booksLabels.length;
      const sportsText = allSportsToggle && allSportsToggle.checked ? t('summary_all') : sportsSelected;
      const booksText = allBookmakersToggle && allBookmakersToggle.checked ? t('summary_all') : booksSelected;
      advancedSummary.textContent = t('advanced_summary', {
        sports: sportsText,
        books: booksText,
      });
      const sportsDetail =
        allSportsToggle && allSportsToggle.checked
          ? t('summary_all')
          : sportsLabels.length
            ? sportsLabels.join(', ')
            : '0';
      const booksDetail =
        allBookmakersToggle && allBookmakersToggle.checked
          ? t('summary_all')
          : booksLabels.length
            ? booksLabels.join(', ')
            : '0';
      advancedSummary.title = `${t('sports_label')}: ${sportsDetail}\n${t('bookmakers_label')}: ${booksDetail}`;
    }

    function getOpportunityCount(section) {
      if (!section) return 0;
      if (typeof section.opportunities_count === 'number') return section.opportunities_count;
      if (Array.isArray(section.opportunities)) return section.opportunities.length;
      return 0;
    }

    function playNotificationSound() {
      if (!notifySoundToggle || !notifySoundToggle.checked) return;
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) return;
      if (!notificationAudioContext) {
        notificationAudioContext = new AudioContextClass();
      }
      const context = notificationAudioContext;
      if (context.state === 'suspended') {
        context.resume().catch(() => {});
      }
      const oscillator = context.createOscillator();
      const gain = context.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gain.gain.setValueAtTime(0.0001, context.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.2, context.currentTime + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + 0.3);
      oscillator.connect(gain);
      gain.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime + 0.35);
    }

    async function requestNotificationPermission() {
      if (!('Notification' in window)) return 'unsupported';
      if (Notification.permission === 'granted') return 'granted';
      if (Notification.permission === 'denied') return 'denied';
      try {
        return await Notification.requestPermission();
      } catch (error) {
        return 'denied';
      }
    }

    function reconcileNotificationToggles() {
      if (!notifyPopupToggle) return;
      if (!('Notification' in window)) {
        notifyPopupToggle.checked = false;
        notifyPopupToggle.disabled = true;
        return;
      }
      if (Notification.permission === 'denied') {
        notifyPopupToggle.checked = false;
      }
    }

    function notifyScanComplete(payload) {
      if (!payload) return;
      playNotificationSound();
      if (!notifyPopupToggle || !notifyPopupToggle.checked) return;
      if (!('Notification' in window) || Notification.permission !== 'granted') return;
      const title = t('scan_complete', { time: formatTime(payload.scan_time) });
      const body = t('notify_body', {
        arb: getOpportunityCount(payload.arbitrage),
        middle: getOpportunityCount(payload.middles),
        plus: getOpportunityCount(payload.plus_ev),
      });
      try {
        new Notification(title, { body });
      } catch (error) {
        return;
      }
    }

    function updateSportLabels() {
      document.querySelectorAll('[data-sport-key]').forEach((el) => {
        if (!el.dataset.defaultLabel) {
          el.dataset.defaultLabel = el.textContent.trim();
        }
        const key = el.dataset.sportKey;
        const fallback = el.dataset.defaultLabel;
        const translated = translateSportKey(key, fallback);
        el.textContent = translated;
      });
    }

    function updateRegionLabels() {
      document.querySelectorAll('[data-region-key]').forEach((el) => {
        if (!el.dataset.defaultLabel) {
          el.dataset.defaultLabel = el.textContent.trim();
        }
        const key = el.dataset.regionKey;
        const fallback = el.dataset.defaultLabel;
        const translated = translateRegionKey(key, fallback);
        el.textContent = translated;
      });
    }

    function updateKellyOptions() {
      if (!kellySelect) return;
      kellySelect.querySelectorAll('option[data-kelly-value]').forEach((option) => {
        const value = parseFloat(option.dataset.kellyValue);
        let key = 'kelly_tenth';
        if (value === 1) key = 'kelly_full';
        else if (value === 0.5) key = 'kelly_half';
        else if (value === 0.25) key = 'kelly_quarter';
        option.textContent = t(key);
      });
    }

    function translateSportKey(key, fallback) {
      if (activeLanguage !== 'zh') return fallback;
      const map = SPORT_KEY_LABELS[activeLanguage] || {};
      return map[key] || fallback;
    }

    function translateSportLabel(label) {
      if (!label || activeLanguage !== 'zh') return label || '';
      const map = SPORT_LABELS[activeLanguage] || {};
      return map[label] || label;
    }

    function translateRegionKey(key, fallback) {
      if (activeLanguage !== 'zh') return fallback;
      const map = REGION_LABELS[activeLanguage] || {};
      return map[key] || fallback;
    }

    function formatRegionList(regions) {
      if (!Array.isArray(regions) || !regions.length) return '';
      if (activeLanguage === 'zh') {
        return regions.map((region) => translateRegionKey(region, region)).join(', ');
      }
      return regions.map((region) => String(region).toUpperCase()).join(', ');
    }

    function translateMarketLabel(market) {
      if (!market || activeLanguage !== 'zh') return market || '';
      const map = MARKET_LABELS[activeLanguage] || {};
      return map[market] || market;
    }

    function formatDateTime(value) {
      if (!value) return t('tbd');
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return t('tbd');
      return date.toLocaleString(activeLocale);
    }

    function formatTime(value) {
      if (!value) return t('tbd');
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return t('tbd');
      return date.toLocaleTimeString(activeLocale);
    }

    function refreshStatus() {
      if (!lastStatus) return;
      const { key, params, type, message } = lastStatus;
      if (key) {
        statusEl.textContent = t(key, params);
      } else if (message !== undefined) {
        statusEl.textContent = message;
      }
      statusEl.className = type ? `status ${type}` : 'status';
    }

    function statusKeyForState(state) {
      switch (state) {
        case 'ready':
          return 'status_ready';
        case 'scanning':
          return 'status_scanning';
        case 'error':
          return 'status_error';
        case 'partial':
          return 'status_partial';
        case 'idle':
        default:
          return 'status_idle';
      }
    }

    function applyScanStatus(state) {
      if (!scanStatusChip || !scanStatusText) return;
      const normalized = state || 'idle';
      scanStatusChip.dataset.status = normalized;
      scanStatusText.textContent = t(statusKeyForState(normalized));
    }

    function updateScanMeta(payload) {
      if (!scanLastTime || !scanApiCalls || !scanEvents || !scanSports) return;
      if (!payload || !payload.arbitrage?.summary) {
        scanLastTime.textContent = '-';
        scanApiCalls.textContent = '-';
        scanEvents.textContent = '-';
        scanSports.textContent = '-';
        return;
      }
      const summary = payload.arbitrage.summary;
      scanLastTime.textContent = formatDateTime(payload.scan_time);
      scanApiCalls.textContent = summary.api_calls_used ?? '-';
      scanEvents.textContent = summary.events_scanned ?? '-';
      scanSports.textContent = summary.sports_scanned ?? '-';
    }

    function updateArbSortLabel() {
      if (!arbSortLabel) return;
      const keyMap = {
        roi: 'sorted_by_roi',
        profit: 'sorted_by_profit',
        time: 'sorted_by_time',
      };
      const sortKey = arbitrageSortSelect ? arbitrageSortSelect.value || 'roi' : 'roi';
      arbSortLabel.textContent = t(keyMap[sortKey] || 'sorted_by_roi');
    }

    function updateMiddlesSortLabel() {
      if (!middlesSortLabel) return;
      const keyMap = {
        ev: 'sorted_by_ev',
        probability: 'sorted_by_probability',
        gap: 'sorted_by_gap',
        time: 'sorted_by_time',
      };
      const sortKey = middleSortSelect.value || 'ev';
      middlesSortLabel.textContent = t(keyMap[sortKey] || 'sorted_by_ev');
    }

    function updatePlusEvSortLabel() {
      if (!plusEvSortLabel) return;
      const keyMap = {
        edge: 'sorted_by_edge',
        ev: 'sorted_by_ev_value',
        kelly: 'sorted_by_kelly',
        time: 'sorted_by_time',
      };
      const sortKey = plusEvSortSelect.value || 'edge';
      plusEvSortLabel.textContent = t(keyMap[sortKey] || 'sorted_by_edge');
    }

    document.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('arb-theme');
      if (savedTheme) {
        document.documentElement.dataset.theme = savedTheme;
      } else if (appConfig.defaultTheme) {
        document.documentElement.dataset.theme = appConfig.defaultTheme;
      }
      applyTranslations();
      loadSettings();
      reconcileNotificationToggles();
      updateBookmakerState();
      syncBookmakerLinksFromInputs();
    });

    if (toggleKeyBtn && apiKeyInput) {
      toggleKeyBtn.addEventListener('click', () => {
        if (apiKeyInput.type === 'password') {
          apiKeyInput.type = 'text';
        } else {
          apiKeyInput.type = 'password';
        }
        updateToggleKeyLabel();
      });
    }

    themeToggle.addEventListener('click', () => {
      const current = document.documentElement.dataset.theme || 'light';
      const next = current === 'light' ? 'dark' : 'light';
      document.documentElement.dataset.theme = next;
      localStorage.setItem('arb-theme', next);
      updateThemeToggleText();
    });

    if (oddsToggle) {
      oddsToggle.addEventListener('click', () => {
        oddsFormat = oddsFormat === 'decimal' ? 'american' : 'decimal';
        localStorage.setItem('edge-odds-format', oddsFormat);
        updateOddsToggle();
        renderArbitrage();
        renderMiddles();
        renderPlusEv();
      });
    }

    if (languageToggle) {
      languageToggle.addEventListener('click', (event) => {
        const target = event.target;
        const selected = target && target.dataset ? target.dataset.lang : null;
        const nextLang = selected || (activeLanguage === 'en' ? 'zh' : 'en');
        setLanguage(nextLang);
      });
    }

    if (densityToggle) {
      densityToggle.addEventListener('click', (event) => {
        const target = event.target;
        const selected = target && target.dataset ? target.dataset.density : null;
        densityMode = selected || (densityMode === 'comfort' ? 'compact' : 'comfort');
        localStorage.setItem('edge-density', densityMode);
        updateDensityToggle();
      });
    }

    tabs.forEach((tab) => {
      tab.addEventListener('click', () => {
        const target = tab.dataset.tab;
        if (target && target !== activeTab) {
          setActiveTab(target);
        }
      });
    });

    function updateQuickActionState() {
      if (!quickActionButtons || !quickActionButtons.length) return;
      quickActionButtons.forEach((button) => {
        const target = button.dataset.quickTarget;
        if (target === 'bookmakers' && allBookmakersToggle) {
          button.disabled = allBookmakersToggle.checked;
          return;
        }
        if (target === 'sports' && allSportsToggle) {
          button.disabled = allSportsToggle.checked;
          return;
        }
        button.disabled = false;
      });
    }

    function applyQuickAction(target, action) {
      if (!form || !target || !action) return;
      const boxes = form.querySelectorAll(`input[name="${target}"]`);
      if (!boxes.length) return;
      if (target === 'sports' && allSportsToggle) {
        allSportsToggle.checked = false;
      }
      if (target === 'bookmakers' && allBookmakersToggle) {
        allBookmakersToggle.checked = false;
        updateBookmakerState();
      }
      const shouldCheck = action === 'select';
      boxes.forEach((box) => {
        if (box.disabled) return;
        box.checked = shouldCheck;
      });
      updateAdvancedSummary();
      updateQuickActionState();
    }

    function updateBookmakerState() {
      if (!allBookmakersToggle) return;
      const useAll = allBookmakersToggle.checked;
      const boxes = form ? form.querySelectorAll('input[name="bookmakers"]') : [];
      boxes.forEach((box) => {
        box.disabled = useAll;
      });
      if (bookmakersList) {
        bookmakersList.classList.toggle('is-disabled', useAll);
      }
      updateQuickActionState();
    }

    if (allBookmakersToggle) {
      allBookmakersToggle.addEventListener('change', updateBookmakerState);
    }

    if (allSportsToggle) {
      allSportsToggle.addEventListener('change', updateQuickActionState);
    }

    if (quickActionButtons && quickActionButtons.length) {
      quickActionButtons.forEach((button) => {
        button.addEventListener('click', () => {
          applyQuickAction(button.dataset.quickTarget, button.dataset.quickAction);
        });
      });
    }

    if (notifyPopupToggle) {
      notifyPopupToggle.addEventListener('change', async () => {
        if (!notifyPopupToggle.checked) return;
        const permission = await requestNotificationPermission();
        if (permission !== 'granted') {
          notifyPopupToggle.checked = false;
        }
      });
    }

    function getFocusableElements(container) {
      if (!container) return [];
      const selector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])';
      return Array.from(container.querySelectorAll(selector)).filter((el) => !el.disabled);
    }

    function handleModalKeydown(event) {
      if (event.key !== 'Tab') return;
      const focusables = getFocusableElements(advancedModal);
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      if (event.shiftKey && document.activeElement === first) {
        event.preventDefault();
        last.focus();
      } else if (!event.shiftKey && document.activeElement === last) {
        event.preventDefault();
        first.focus();
      }
    }

    function openAdvancedModal() {
      if (!advancedModal) return;
      lastFocusedElement = document.activeElement;
      advancedModal.classList.remove('hidden');
      advancedModal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('modal-open');
      if (openAdvancedBtn) {
        openAdvancedBtn.setAttribute('aria-expanded', 'true');
      }
      advancedModal.addEventListener('keydown', handleModalKeydown);
      const focusables = getFocusableElements(advancedModal);
      const focusTarget = (closeAdvancedBtn || focusables[0]);
      if (focusTarget && focusTarget.focus) {
        focusTarget.focus();
      }
    }

    function closeAdvancedModal() {
      if (!advancedModal) return;
      advancedModal.classList.add('hidden');
      advancedModal.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('modal-open');
      advancedModal.removeEventListener('keydown', handleModalKeydown);
      if (openAdvancedBtn) {
        openAdvancedBtn.setAttribute('aria-expanded', 'false');
      }
      if (lastFocusedElement && lastFocusedElement.focus) {
        lastFocusedElement.focus();
      }
    }

    if (openAdvancedBtn) {
      openAdvancedBtn.addEventListener('click', openAdvancedModal);
    }

    if (closeAdvancedBtn) {
      closeAdvancedBtn.addEventListener('click', closeAdvancedModal);
    }

    if (advancedModal) {
      advancedModal.addEventListener('click', (event) => {
        const target = event.target;
        if (target && target.dataset && target.dataset.close === 'modal') {
          closeAdvancedModal();
        }
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && advancedModal && !advancedModal.classList.contains('hidden')) {
        closeAdvancedModal();
      }
    });

    if (form) {
      form.addEventListener('change', (event) => {
        const target = event.target;
        if (!target || !target.matches) return;
        if (
          target.matches('input[name="sports"]') ||
          target.matches('input[name="bookmakers"]') ||
          target.id === 'all-sports' ||
          target.id === 'all-bookmakers'
        ) {
          updateAdvancedSummary();
        }
      });
    }

    if (bookmakerLinksList) {
      bookmakerLinksList.addEventListener('input', () => {
        syncBookmakerLinksFromInputs();
      });
    }

    function setCheckboxGroup(name, values) {
      if (!Array.isArray(values)) return;
      const boxes = form ? form.querySelectorAll(`input[name="${name}"]`) : [];
      const selected = new Set(values);
      boxes.forEach((box) => {
        box.checked = selected.has(box.value);
      });
    }

    function getBookmakerLinkInputs() {
      if (!bookmakerLinksList) return [];
      return Array.from(bookmakerLinksList.querySelectorAll('input[data-bookmaker-key]'));
    }

    function collectBookmakerLinks() {
      const inputs = getBookmakerLinkInputs();
      const links = {};
      inputs.forEach((input) => {
        const key = input.dataset.bookmakerKey;
        if (!key) return;
        links[key] = (input.value || '').trim();
      });
      return links;
    }

    function syncBookmakerLinksFromInputs() {
      const inputs = getBookmakerLinkInputs();
      const next = { ...(appConfig.bookmakerLinks || {}) };
      inputs.forEach((input) => {
        const key = input.dataset.bookmakerKey;
        if (!key) return;
        const value = (input.value || '').trim();
        if (value) {
          next[key] = value;
        } else {
          delete next[key];
        }
      });
      bookmakerLinks = next;
    }

    function readAutoScanMinutes() {
      if (!autoScanIntervalInput) return 10;
      const value = parseFloat(autoScanIntervalInput.value);
      if (!Number.isFinite(value) || value <= 0) return 10;
      return value;
    }

    function selectedRegions() {
      return Array.from(form?.querySelectorAll('input[name="regions"]:checked') || []).map((el) => el.value);
    }

    function triggerAutoScan() {
      if (isScanning) return;
      if (!hasEnvKey && !apiKeyInput?.value.trim()) return;
      const sports = Array.from(form?.querySelectorAll('input[name="sports"]:checked') || []).map((el) => el.value);
      const useAllSports = allSportsToggle ? allSportsToggle.checked : false;
      if (!useAllSports && !sports.length) return;
      const regions = selectedRegions();
      if (!regions.length) return;
      const useAllBookmakers = allBookmakersToggle ? allBookmakersToggle.checked : true;
      const bookmakers = useAllBookmakers
        ? []
        : Array.from(form?.querySelectorAll('input[name="bookmakers"]:checked') || []).map((el) => el.value);
      if (!useAllBookmakers && !bookmakers.length) return;
      const stakeValue = parseFloat(stakeInput?.value) || 100;
      const commissionValue = commissionInput && Number.isFinite(parseFloat(commissionInput.value))
        ? parseFloat(commissionInput.value)
        : defaultCommissionPercent;
      runScan({
        apiKey: apiKeyInput ? apiKeyInput.value.trim() : '',
        sports,
        bookmakers,
        regions,
        commission: commissionValue,
        allSports: useAllSports,
        stake: stakeValue,
        sharpBook: sharpSelect?.value || appConfig.defaultSharpBook,
        minEdgePercent: parseFloat(minEdgeInput?.value) || appConfig.defaultMinEdgePercent || 1,
        bankroll: parseFloat(bankrollInput?.value) || appConfig.defaultBankroll || 1000,
        kellyFraction: parseFloat(kellySelect?.value) || appConfig.defaultKellyFraction || 0.25,
      });
    }

    function configureAutoScan() {
      if (!autoScanToggle) return;
      if (autoScanTimer) {
        clearInterval(autoScanTimer);
        autoScanTimer = null;
      }
      if (!autoScanToggle.checked) return;
      const minutes = readAutoScanMinutes();
      if (autoScanIntervalInput) {
        autoScanIntervalInput.value = String(minutes);
      }
      autoScanTimer = setInterval(triggerAutoScan, minutes * 60 * 1000);
    }

    function applyBookmakerLinks(values) {
      if (!values) {
        syncBookmakerLinksFromInputs();
        return;
      }
      const inputs = getBookmakerLinkInputs();
      inputs.forEach((input) => {
        const key = input.dataset.bookmakerKey;
        if (!key) return;
        if (Object.prototype.hasOwnProperty.call(values, key)) {
          input.value = values[key] || '';
        }
      });
      syncBookmakerLinksFromInputs();
    }

    function collectSettings() {
      const sports = Array.from(form?.querySelectorAll('input[name="sports"]:checked') || []).map((el) => el.value);
      const regions = selectedRegions();
      const bookmakers = Array.from(form?.querySelectorAll('input[name="bookmakers"]:checked') || []).map((el) => el.value);
      return {
        stake: stakeInput ? stakeInput.value : '',
        commission: commissionInput ? commissionInput.value : '',
        allSports: allSportsToggle ? allSportsToggle.checked : false,
        sports,
        regions,
        allBookmakers: allBookmakersToggle ? allBookmakersToggle.checked : true,
        bookmakers,
        minRoi: minRoiInput ? minRoiInput.value : '',
        arbitrageSort: arbitrageSortSelect ? arbitrageSortSelect.value : '',
        minGap: minGapInput ? minGapInput.value : '',
        positiveEvOnly: positiveEvToggle ? positiveEvToggle.checked : false,
        middleSort: middleSortSelect ? middleSortSelect.value : '',
        sharpBook: sharpSelect ? sharpSelect.value : '',
        minEdge: minEdgeInput ? minEdgeInput.value : '',
        bankroll: bankrollInput ? bankrollInput.value : '',
        kellyFraction: kellySelect ? kellySelect.value : '',
        plusEvSort: plusEvSortSelect ? plusEvSortSelect.value : '',
        activeTab,
        bookmakerUrls: collectBookmakerLinks(),
        autoScanEnabled: autoScanToggle ? autoScanToggle.checked : false,
        autoScanMinutes: autoScanIntervalInput ? autoScanIntervalInput.value : '',
        notifySoundEnabled: notifySoundToggle ? notifySoundToggle.checked : false,
        notifyPopupEnabled: notifyPopupToggle ? notifyPopupToggle.checked : false,
      };
    }

    function applySettings(settings) {
      if (!settings) return;
      if (stakeInput && settings.stake !== undefined) stakeInput.value = settings.stake;
      if (commissionInput && settings.commission !== undefined) commissionInput.value = settings.commission;
      if (allSportsToggle && settings.allSports !== undefined) allSportsToggle.checked = Boolean(settings.allSports);
      setCheckboxGroup('sports', settings.sports);
      setCheckboxGroup('regions', settings.regions);
      if (allBookmakersToggle && settings.allBookmakers !== undefined) {
        allBookmakersToggle.checked = Boolean(settings.allBookmakers);
      }
      setCheckboxGroup('bookmakers', settings.bookmakers);
      if (minRoiInput && settings.minRoi !== undefined) minRoiInput.value = settings.minRoi;
      if (arbitrageSortSelect && settings.arbitrageSort) arbitrageSortSelect.value = settings.arbitrageSort;
      if (minGapInput && settings.minGap !== undefined) minGapInput.value = settings.minGap;
      if (positiveEvToggle && settings.positiveEvOnly !== undefined) positiveEvToggle.checked = settings.positiveEvOnly;
      if (middleSortSelect && settings.middleSort) middleSortSelect.value = settings.middleSort;
      if (sharpSelect && settings.sharpBook) sharpSelect.value = settings.sharpBook;
      if (minEdgeInput && settings.minEdge !== undefined) minEdgeInput.value = settings.minEdge;
      if (bankrollInput && settings.bankroll !== undefined) bankrollInput.value = settings.bankroll;
      if (kellySelect && settings.kellyFraction !== undefined) kellySelect.value = settings.kellyFraction;
      if (plusEvSortSelect && settings.plusEvSort) plusEvSortSelect.value = settings.plusEvSort;
      if (autoScanToggle && settings.autoScanEnabled !== undefined) {
        autoScanToggle.checked = Boolean(settings.autoScanEnabled);
      }
      if (autoScanIntervalInput && settings.autoScanMinutes !== undefined) {
        autoScanIntervalInput.value = settings.autoScanMinutes;
      }
      if (notifySoundToggle && settings.notifySoundEnabled !== undefined) {
        notifySoundToggle.checked = Boolean(settings.notifySoundEnabled);
      }
      if (notifyPopupToggle && settings.notifyPopupEnabled !== undefined) {
        notifyPopupToggle.checked = Boolean(settings.notifyPopupEnabled);
      }
      if (settings.activeTab) setActiveTab(settings.activeTab);
      if (settings.bookmakerUrls) {
        applyBookmakerLinks(settings.bookmakerUrls);
      } else {
        syncBookmakerLinksFromInputs();
      }
      configureAutoScan();
      updateBookmakerState();
      updateAdvancedSummary();
      updateQuickActionState();
      reconcileNotificationToggles();
    }

    function loadSettings() {
      const raw = localStorage.getItem('edge-scan-settings');
      if (!raw) return;
      try {
        const parsed = JSON.parse(raw);
        applySettings(parsed);
      } catch (err) {
        return;
      }
    }

    function persistSettings() {
      const payload = collectSettings();
      localStorage.setItem('edge-scan-settings', JSON.stringify(payload));
    }

    function saveSettings() {
      persistSettings();
      configureAutoScan();
      showStatusKey('settings_saved', 'success');
      closeAdvancedModal();
    }

    if (saveSettingsBtn) {
      saveSettingsBtn.addEventListener('click', saveSettings);
    }

    if (autoScanToggle) {
      autoScanToggle.addEventListener('change', configureAutoScan);
    }

    if (autoScanIntervalInput) {
      autoScanIntervalInput.addEventListener('change', configureAutoScan);
    }

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      if (!hasEnvKey && !apiKeyInput?.value.trim()) {
        showStatusKey('enter_api_key', 'error');
        return;
      }
      const sports = Array.from(form.querySelectorAll('input[name="sports"]:checked')).map((el) => el.value);
      const regions = selectedRegions();
      if (!regions.length) {
        showStatusKey('select_region', 'error');
        return;
      }
      const useAllBookmakers = allBookmakersToggle ? allBookmakersToggle.checked : true;
      const bookmakers = useAllBookmakers
        ? []
        : Array.from(form.querySelectorAll('input[name="bookmakers"]:checked')).map((el) => el.value);
      if (!useAllBookmakers && !bookmakers.length) {
        showStatusKey('select_bookmakers', 'error');
        return;
      }
      const stakeValue = parseFloat(stakeInput.value) || 100;
      const commissionValue = commissionInput && Number.isFinite(parseFloat(commissionInput.value))
        ? parseFloat(commissionInput.value)
        : defaultCommissionPercent;
      await runScan({
        apiKey: apiKeyInput ? apiKeyInput.value.trim() : '',
        sports,
        regions,
        bookmakers,
        commission: commissionValue,
        allSports: allSportsToggle.checked,
        stake: stakeValue,
        sharpBook: sharpSelect?.value || appConfig.defaultSharpBook,
        minEdgePercent: parseFloat(minEdgeInput?.value) || appConfig.defaultMinEdgePercent || 1,
        bankroll: parseFloat(bankrollInput?.value) || appConfig.defaultBankroll || 1000,
        kellyFraction: parseFloat(kellySelect?.value) || appConfig.defaultKellyFraction || 0.25,
      });
    });

    stakeInput.addEventListener('input', () => {
      if (lastScanData) {
        renderArbitrage();
        renderMiddles();
      }
    });

    if (minRoiInput) {
      minRoiInput.addEventListener('input', () => renderArbitrage());
      minRoiInput.addEventListener('change', () => persistSettings());
    }
    if (arbitrageSortSelect) arbitrageSortSelect.addEventListener('change', () => renderArbitrage());
    minGapInput.addEventListener('input', () => renderMiddles());
    positiveEvToggle.addEventListener('change', () => renderMiddles());
    middleSortSelect.addEventListener('change', () => renderMiddles());
    minEdgeInput.addEventListener('input', () => renderPlusEv());
    bankrollInput.addEventListener('input', () => renderPlusEv());
    kellySelect.addEventListener('change', () => renderPlusEv());
    plusEvSortSelect.addEventListener('change', () => renderPlusEv());

    async function runScan(payload) {
      setScanning(true);
      try {
        const response = await fetch('/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: payload.apiKey,
            sports: payload.sports,
            allSports: payload.allSports,
            stake: payload.stake,
            regions: payload.regions,
            bookmakers: payload.bookmakers,
            commission: payload.commission,
            sharpBook: payload.sharpBook,
            minEdgePercent: payload.minEdgePercent,
            bankroll: payload.bankroll,
            kellyFraction: payload.kellyFraction,
          }),
        });
        const data = await response.json();
        if (!data.success) {
          throw new Error(data.error || t('scan_failed'));
        }
        if (data?.middles?.defaults) {
          const defaults = data.middles.defaults;
          if (defaults.min_gap !== undefined) minGapInput.value = defaults.min_gap;
          if (defaults.positive_only !== undefined) positiveEvToggle.checked = defaults.positive_only;
          if (defaults.sort) middleSortSelect.value = defaults.sort;
        }
        if (data?.plus_ev?.defaults) {
          const defaults = data.plus_ev.defaults;
          if (defaults.sharp_book) sharpSelect.value = defaults.sharp_book;
          if (defaults.min_edge_percent !== undefined) minEdgeInput.value = defaults.min_edge_percent;
          if (defaults.bankroll !== undefined) bankrollInput.value = defaults.bankroll;
          if (defaults.kelly_fraction !== undefined) kellySelect.value = defaults.kelly_fraction;
        }
        renderScanData(data);
        showStatusKey('scan_complete', 'success', { time: formatTime(data.scan_time) });
        notifyScanComplete(data);
      } catch (err) {
        showStatus(err.message || t('scan_failed'), 'error');
        renderScanData(null);
      } finally {
        setScanning(false);
      }
    }

    function setScanning(nextState) {
      isScanning = nextState;
      scanBtn.disabled = nextState;
      updateScanButtonText();
      statusEl.textContent = nextState ? t('scanning_wait') : '';
      statusEl.className = 'status';
      lastStatus = nextState ? { key: 'scanning_wait', params: {}, type: null } : null;
      if (nextState) {
        applyScanStatus('scanning');
      }
    }

    function showStatus(message, type, key = null, params = {}) {
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
      lastStatus = { message, type, key, params };
    }

    function showStatusKey(key, type, params = {}) {
      showStatus(t(key, params), type, key, params);
    }

    function renderScanData(payload) {
      lastScanData = payload;
      if (payload && typeof payload.commission_rate === 'number') {
        lastCommissionRate = payload.commission_rate;
      }
      renderArbitrage();
      renderMiddles();
      renderPlusEv();
      renderPartialWarning(payload);
      if (payload) {
        applyScanStatus(payload.partial ? 'partial' : 'ready');
      } else {
        applyScanStatus('error');
      }
      updateScanMeta(payload);
    }

    function renderArbitrage() {
      const arbData = lastScanData?.arbitrage;
      const opportunities = arbData?.opportunities || [];
      const stakeValue = parseFloat(stakeInput.value) || 0;
      const minRoiValue = minRoiInput ? minRoiInput.value : 0;
      const minRoi = Number.isFinite(parseFloat(minRoiValue)) ? parseFloat(minRoiValue) : 0;
      const sortKey = arbitrageSortSelect ? arbitrageSortSelect.value || 'roi' : 'roi';
      updateArbSortLabel();
      const prepared = opportunities.map((opp) => {
        const calcNet = calculateStakes(opp, stakeValue, true);
        const netRoi = calcNet?.roi_percent ?? opp.roi_percent ?? 0;
        const profitValue = calcNet?.guaranteed_profit ?? 0;
        const timeValue = opp.commence_time ? new Date(opp.commence_time).getTime() : 0;
        return {
          opp,
          calcNet,
          netRoi,
          profitValue,
          timeValue,
        };
      });
      const filtered = prepared.filter((item) => {
        if (item.netRoi < minRoi) return false;
        return true;
      });
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'profit':
            return (b.profitValue || 0) - (a.profitValue || 0);
          case 'time':
            return (a.timeValue || 0) - (b.timeValue || 0);
          case 'roi':
          default:
            return (b.netRoi || 0) - (a.netRoi || 0);
        }
      });
      resultsBody.innerHTML = '';
      tableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        emptyState.classList.remove('hidden');
      } else {
        emptyState.classList.add('hidden');
        let runningProfit = 0;
        filtered.forEach((entry) => {
          const opp = entry.opp;
          const row = document.createElement('tr');
          const calcNet = entry.calcNet;
          const netRoi = entry.netRoi;
          row.classList.add(roiBandClass(netRoi));
          const commence = formatDateTime(opp.commence_time);
          const calcGross = opp.has_exchange ? calculateStakes(opp, stakeValue, false) : null;
          const grossRoi = opp.has_exchange ? calcGross?.roi_percent ?? opp.gross_roi_percent : null;
          const netNegative = typeof netRoi === 'number' && netRoi < 0;
          if (netNegative) row.classList.add('roi-negative');
          if (opp.has_exchange) row.classList.add('has-exchange');
          const breakdown = calcNet?.breakdown || [];
          const profitValue = entry.profitValue ?? 0;
          runningProfit += profitValue || 0;
          const profitClass = profitValue > 0 ? 'gain' : profitValue < 0 ? 'loss' : '';
          const grossCell = opp.has_exchange ? formatRoiBadge(grossRoi) : '';
          const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
          const openLabel = t('open_books');
          const hasOpenTargets = collectBookTargets(opp).length > 0;
          row.innerHTML = `
            <td><span class="roi-badge">${formatPercent(netRoi)}</span>${netNegative ? `<span class="roi-warning" title="${t('net_roi_negative')}">⚠</span>` : ''}</td>
            <td>${grossCell}</td>
            <td class="profit-cell ${profitClass}">${calcNet ? formatProfit(profitValue) : '-'}</td>
            <td>${formatExchangeCell(opp)}</td>
            <td>${sportLabel}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${formatMarket(opp)}</td>
            <td>${formatOutcome(breakdown[0])}</td>
            <td>${formatOutcome(breakdown[1])}</td>
            <td class="open-cell"><button type="button" class="secondary-btn open-books-btn" ${hasOpenTargets ? '' : 'disabled'}>${openLabel}</button></td>`;
          const openBtn = row.querySelector('.open-books-btn');
          if (openBtn) {
            openBtn.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (!hasOpenTargets) {
                showStatusKey('open_books_missing', 'error');
                return;
              }
              openBookmakerTabs(opp);
            });
          }
          resultsBody.appendChild(row);
        });
        tableCount.textContent = t('results_profit', {
          count: filtered.length,
          profit: formatCurrency(runningProfit),
        });
      }
      const summary = arbData?.summary;
      if (summary) {
        statOpps.textContent = filtered.length;
        statEvents.textContent = summary.events_scanned;
        statSports.textContent = summary.sports_scanned;
        statCalls.textContent = summary.api_calls_used;
        const totalProfit = filtered.reduce((sum, item) => sum + (item.profitValue || 0), 0);
        const totalStaked = stakeValue > 0 ? stakeValue * filtered.length : 0;
        const commissionPercent = formatCommissionPercent(lastCommissionRate);
        const regionsLabel = formatRegionList(lastScanData?.regions);
        const totalCount = arbData.opportunities_count || opportunities.length;
        const filtersActive = minRoi !== 0;
        const shownCount = filtersActive ? filtered.length : totalCount;
        const countText = `<strong>${shownCount}</strong>`;
        const eventsText = `<strong>${summary.events_scanned}</strong>`;
        const sportsText = `<strong>${summary.sports_scanned}</strong>`;
        const profitText = `<strong>${formatCurrency(totalProfit)}</strong>`;
        const stakedText = totalStaked
          ? t('summary_profit_staked', { staked: `<strong>${formatCurrency(totalStaked)}</strong>` })
          : '';
        const regionsSuffix = regionsLabel ? t('summary_regions_suffix', { regions: regionsLabel }) : '';
        const callsText = t('summary_calls', { calls: summary.api_calls_used, regions: regionsSuffix });
        const filtersNote =
          filtersActive && totalCount !== filtered.length
            ? `<p class="helper">${t('filters_applied', { shown: filtered.length, total: totalCount })}</p>`
            : '';
        summaryEl.classList.remove('hidden');
        summaryEl.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('summary_found', { count: countText, events: eventsText, sports: sportsText })}</p>
          <p>${t('summary_profit', { profit: profitText, staked: stakedText })}</p>
          <p>${callsText}</p>
          <p>${t('summary_commission', { commission: commissionPercent })}</p>
          <p class="helper">${t('summary_roi_note')}</p>
          ${filtersNote}
        `;
      } else {
        statOpps.textContent = statEvents.textContent = statSports.textContent = statCalls.textContent = '0';
        summaryEl.classList.add('hidden');
        summaryEl.innerHTML = '';
      }
    }

    function renderMiddles() {
      const data = lastScanData?.middles;
      const opportunities = data?.opportunities || [];
      const minGap = parseFloat(minGapInput.value) || 0;
      const positiveOnly = positiveEvToggle.checked;
      const sortKey = middleSortSelect.value || 'ev';
      updateMiddlesSortLabel();
      const scannedStake = data?.stake_amount || 0;
      const desiredStake = parseFloat(stakeInput.value) || scannedStake || 100;
      const stakeRatio = scannedStake > 0 ? desiredStake / scannedStake : 1;
      const filtered = opportunities.filter((opp) => {
        const gapPoints = opp.gap?.points ?? 0;
        if (gapPoints < minGap) return false;
        if (positiveOnly && opp.ev_percent <= 0) return false;
        return true;
      });
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'probability':
            return (b.middle_probability || 0) - (a.middle_probability || 0);
          case 'gap':
            return (b.gap?.integer_count || 0) - (a.gap?.integer_count || 0);
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'ev':
          default:
            return (b.ev_percent || 0) - (a.ev_percent || 0);
        }
      });
      const stats = buildMiddleStats(filtered);
      middleStatCount.textContent = stats.count;
      middleStatPositive.textContent = stats.positive_count;
      middleStatAvg.textContent = formatPercent(stats.average_ev_percent);
      middleStatBest.textContent = formatPercent(stats.best_ev_percent);
      if (stats.count > 0) {
        middleSummaryInfo.classList.remove('hidden');
        const countText = `<strong>${stats.count}</strong>`;
        const positiveText = `<strong>${stats.positive_count}</strong>`;
        const avgText = `<strong>${formatPercent(stats.average_ev_percent)}</strong>`;
        const bestText = stats.best_event ? t('middle_summary_best', { event: stats.best_event }) : '';
        middleSummaryInfo.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('middle_summary_counts', { count: countText, positive: positiveText })}</p>
          <p>${t('middle_summary_avg', { avg: avgText, best: bestText })}</p>
        `;
        renderBars(middleSportBars, stats.by_sport, 'sport');
        if (Object.keys(stats.key_numbers).length) {
          middleKeyCard.classList.remove('hidden');
          renderBars(middleKeyBars, stats.key_numbers, 'sport');
        } else {
          middleKeyCard.classList.add('hidden');
          middleKeyBars.innerHTML = `<p class="muted">${t('middle_spreads_only')}</p>`;
        }
      } else {
        middleSummaryInfo.classList.add('hidden');
        middleSummaryInfo.innerHTML = '';
        middleSportBars.innerHTML = '';
        middleKeyCard.classList.add('hidden');
        middleKeyBars.innerHTML = `<p class="muted">${t('middle_spreads_only')}</p>`;
      }

      middlesTableBody.innerHTML = '';
      middlesTableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        middlesEmpty.classList.remove('hidden');
      } else {
        middlesEmpty.classList.add('hidden');
        filtered.forEach((opp) => {
          const row = document.createElement('tr');
          const evClass = evBandClass(opp.ev_percent);
          if (evClass) row.classList.add(evClass);
          if (opp.has_exchange) row.classList.add('has-exchange');
          const commence = formatDateTime(opp.commence_time);
          const stakeA = (opp.stakes?.side_a?.stake || 0) * stakeRatio;
          const stakeB = (opp.stakes?.side_b?.stake || 0) * stakeRatio;
          const winBoth = (opp.outcomes?.win_both_profit || 0) * stakeRatio;
          const miss = (opp.outcomes?.typical_miss_profit || 0) * stakeRatio;
          const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
          const marketLabel = translateMarketLabel(opp.market || '');
          row.innerHTML = `
            <td>${formatPercent(opp.ev_percent)}${opp.has_exchange && typeof opp.gross_ev_percent === 'number' ? `<span class="ev-gross">${t('gross')} ${formatPercent(opp.gross_ev_percent)}</span>` : ''}</td>
            <td>${formatPercent(opp.probability_percent)}</td>
            <td>${formatGapCell(opp)}</td>
            <td>${sportLabel}</td>
            <td>${opp.event || ''}</td>
            <td>${commence}</td>
            <td>${marketLabel}</td>
            <td>${formatMiddleSide(opp.side_a, stakeA)}</td>
            <td>${formatMiddleSide(opp.side_b, stakeB)}</td>
            <td>${opp.middle_zone || ''}</td>
            <td class="profit-cell">${formatProfit(winBoth)}</td>
            <td class="profit-cell">${formatProfit(miss)}</td>
          `;
          middlesTableBody.appendChild(row);
        });
      }
    }

    function renderPlusEv() {
      const plusData = lastScanData?.plus_ev;
      const opportunities = plusData?.opportunities || [];
      const minEdge = parseFloat(minEdgeInput.value) || appConfig.defaultMinEdgePercent || 1;
      const bankroll = parseFloat(bankrollInput.value) || appConfig.defaultBankroll || 1000;
      const kellyFraction = parseFloat(kellySelect.value) || appConfig.defaultKellyFraction || 0.25;
      const sortKey = plusEvSortSelect.value || 'edge';
      updatePlusEvSortLabel();
      const filtered = opportunities.filter((opp) => (opp.edge_percent || 0) >= minEdge);
      filtered.sort((a, b) => {
        switch (sortKey) {
          case 'ev':
            return (b.ev_per_100 || 0) - (a.ev_per_100 || 0);
          case 'kelly': {
            const bkA = calculateKellyStake(oppTrueProb(a), oppEffectiveOdds(a), bankroll, kellyFraction);
            const bkB = calculateKellyStake(oppTrueProb(b), oppEffectiveOdds(b), bankroll, kellyFraction);
            return bkB.recommended - bkA.recommended;
          }
          case 'time': {
            const timeA = a.commence_time ? new Date(a.commence_time).getTime() : 0;
            const timeB = b.commence_time ? new Date(b.commence_time).getTime() : 0;
            return timeA - timeB;
          }
          case 'edge':
          default:
            return (b.edge_percent || 0) - (a.edge_percent || 0);
        }
      });
      const stats = buildPlusEvStats(filtered);
      plusEvCount.textContent = stats.count;
      plusEvAvg.textContent = formatPercent(stats.average_edge_percent);
      plusEvBest.textContent = formatPercent(stats.best_edge_percent);
      plusEvTotal.textContent = formatCurrency(stats.total_ev_per_100);
      if (stats.count > 0) {
        plusEvSummaryInfo.classList.remove('hidden');
        const countText = `<strong>${stats.count}</strong>`;
        const avgText = `<strong>${formatPercent(stats.average_edge_percent)}</strong>`;
        const bestText = stats.best_event ? t('plus_summary_best', { event: stats.best_event }) : '';
        plusEvSummaryInfo.innerHTML = `
          <h3>${t('summary_title')}</h3>
          <p>${t('plus_summary', { count: countText, avg: avgText, best: bestText })}</p>
        `;
        renderBars(plusEvSportBars, stats.by_sport, 'sport');
        renderBars(plusEvEdgeBars, stats.by_edge_band, 'roi');
      } else {
        plusEvSummaryInfo.classList.add('hidden');
        plusEvSummaryInfo.innerHTML = '';
        plusEvSportBars.innerHTML = `<p class="muted">${t('no_data')}</p>`;
        plusEvEdgeBars.innerHTML = `<p class="muted">${t('no_data')}</p>`;
      }

      plusEvTableBody.innerHTML = '';
      plusEvTableCount.textContent = t('results_count', { count: filtered.length });
      if (!filtered.length) {
        plusEvEmpty.classList.remove('hidden');
        return;
      }
      plusEvEmpty.classList.add('hidden');
      filtered.forEach((opp) => {
        const row = document.createElement('tr');
        if (opp.has_exchange) row.classList.add('has-exchange');
        const commence = formatDateTime(opp.commence_time);
        const kellyData = calculateKellyStake(oppTrueProb(opp), oppEffectiveOdds(opp), bankroll, kellyFraction);
        const sportLabel = translateSportLabel(opp.sport_display || opp.sport || '');
        row.innerHTML = `
          <td>${formatEdgeCell(opp)}</td>
          <td class="profit-cell">${formatProfit(opp.ev_per_100 || 0)}</td>
          <td>${formatKellyCell(kellyData)}</td>
          <td>${sportLabel}</td>
          <td>${opp.event || ''}</td>
          <td>${commence}</td>
          <td>${formatPlusMarket(opp)}</td>
          <td>${formatPlusBet(opp)}</td>
          <td>${formatOddsDisplay(opp.bet?.soft_odds)}</td>
          <td>${formatOddsDisplay(opp.sharp?.fair_odds)}</td>
          <td>${formatPercent(opp.sharp?.true_probability_percent)}</td>
        `;
        plusEvTableBody.appendChild(row);
      });
    }

    function oppTrueProb(opp) {
      return opp?.sharp?.true_probability ?? (opp?.sharp?.true_probability_percent || 0) / 100;
    }

    function oppEffectiveOdds(opp) {
      return opp?.bet?.effective_odds || opp?.bet?.soft_odds || 0;
    }

    function calculateKellyStake(prob, odds, bankroll, fraction) {
      if (!prob || !odds || bankroll <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      const p = Math.max(0, Math.min(prob, 1));
      const q = 1 - p;
      const b = odds - 1;
      if (b <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      let full = (b * p - q) / b;
      if (full <= 0) return { fullPercent: 0, fractionPercent: 0, recommended: 0 };
      const frac = Math.max(0, Math.min(fraction, 1));
      const adjusted = full * frac;
      const recommended = Math.max(0, bankroll * adjusted);
      return {
        fullPercent: full * 100,
        fractionPercent: adjusted * 100,
        recommended: Number(recommended.toFixed(2)),
      };
    }

    function formatEdgeCell(opp) {
      const net = formatPercent(opp.edge_percent);
      if (opp.has_exchange && typeof opp.gross_edge_percent === 'number' && opp.gross_edge_percent !== opp.edge_percent) {
        return `${net}<span class="ev-gross">${t('gross')} ${formatPercent(opp.gross_edge_percent)}</span>`;
      }
      return net;
    }

    function formatKellyCell(kellyData) {
      if (!kellyData) return '';
      const stake = kellyData.recommended || 0;
      const frac = kellyData.fractionPercent || 0;
      const rollText = t('kelly_roll', { percent: frac.toFixed(2) });
      return `<div class="kelly-cell">${formatCurrency(stake)}<span class="mono">${rollText}</span></div>`;
    }

    function formatPlusMarket(opp) {
      if (!opp) return '';
      if ((opp.market === 'spreads' || opp.market === 'totals') && opp.market_point !== undefined && opp.market_point !== null) {
        const label = translateMarketLabel(opp.market || '');
        return `${label} (${formatLine(opp.market_point)})`;
      }
      return translateMarketLabel(opp.market || '');
    }

    function formatPlusBet(opp) {
      if (!opp?.bet) return '';
      const exchangeBadge = opp.bet.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const book = opp.bet.soft_book ? ` @ ${opp.bet.soft_book}` : '';
      const point = opp.bet.point !== undefined && opp.bet.point !== null ? ` (${formatLine(opp.bet.point)})` : '';
      return `<span class="outcome">${exchangeBadge}<strong>${opp.bet.outcome || ''}${point}</strong><span>${book}</span></span>`;
    }

    function updateOddsToggle() {
      if (!oddsToggle) return;
      oddsToggle.querySelectorAll('span').forEach((span) => {
        const format = span.dataset.format;
        span.classList.toggle('active', format === oddsFormat);
      });
    }

    function formatOddsDisplay(value) {
      if (!value && value !== 0) return '-';
      if (oddsFormat === 'american') {
        const american = decimalToAmerican(value);
        return american > 0 ? `+${american}` : `${american}`;
      }
      return Number(value).toFixed(2);
    }

    function decimalToAmerican(decimal) {
      if (!decimal || decimal <= 1) return 0;
      if (decimal >= 2) {
        return Math.round((decimal - 1) * 100);
      }
      return Math.round(-100 / (decimal - 1));
    }

    function formatOutcome(item) {
      if (!item) return '';
      const point = item.point !== undefined && item.point !== null ? ` (${item.point})` : '';
      const stake = item.stake !== undefined ? formatCurrency(item.stake) : '';
      const book = item.bookmaker ? ` @ ${item.bookmaker}` : '';
      const exchangeBadge = item.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const effectiveNote =
        item.is_exchange && item.effective_price && item.effective_price !== item.price
          ? `<span class="mono net-note">${t('net_at', { odds: formatOddsDisplay(item.effective_price) })}</span>`
          : '';
      return `<span class="outcome">${exchangeBadge}<strong>${item.outcome || ''}${point}</strong><span>${stake}${book}</span><span class="mono">@ ${formatOddsDisplay(item.price)}</span>${effectiveNote}</span>`;
    }

    function collectBookTargets(opp) {
      const odds = Array.isArray(opp?.best_odds) ? opp.best_odds : [];
      const seen = new Set();
      const entries = [];
      odds.forEach((item) => {
        const key = (item.bookmaker_key || '').trim();
        const name = (item.bookmaker || '').trim();
        const id = key || name;
        if (!id || seen.has(id)) return;
        seen.add(id);
        const eventId = `${item.book_event_id ?? opp?.event_id ?? ''}`.trim();
        const eventUrl = `${item.book_event_url ?? ''}`.trim();
        entries.push({ key, name, eventId, eventUrl });
      });
      return entries;
    }

    function normalizeUrl(value) {
      const trimmed = (value || '').trim();
      if (!trimmed) return '';
      if (/^https?:\/\//i.test(trimmed)) return trimmed;
      return `https://${trimmed}`;
    }

    function openExternalTab(url) {
      const target = normalizeUrl(url);
      if (!target) return 0;
      const opened = window.open(target, '_blank', 'noopener,noreferrer');
      return opened ? 1 : 0;
    }

    function resolveBookmakerLink(book) {
      const key = (book?.key || '').trim();
      const name = (book?.name || '').trim();
      const candidates = [key, key.toLowerCase(), name, name.toLowerCase()].filter(Boolean);
      for (const candidate of candidates) {
        const baseUrl = bookmakerLinks[candidate];
        if (normalizeUrl(baseUrl)) return baseUrl;
      }
      return '';
    }

    function withTemplatePlaceholders(url, book, opp) {
      const normalized = normalizeUrl(url);
      if (!normalized) return '';
      const eventId = `${book?.eventId ?? opp?.event_id ?? ''}`.trim();
      const values = {
        event_id: eventId,
        book_event_id: `${book?.eventId ?? ''}`.trim(),
        home_team: `${opp?.home_team ?? ''}`.trim(),
        away_team: `${opp?.away_team ?? ''}`.trim(),
        event: `${opp?.event ?? ''}`.trim(),
      };
      return normalized.replace(/\{(event_id|book_event_id|home_team|away_team|event)\}/gi, (_, token) => {
        const value = values[(token || '').toLowerCase()] ?? '';
        return encodeURIComponent(value);
      });
    }

    function isPurebetBook(book) {
      const key = (book?.key || '').trim().toLowerCase();
      const name = (book?.name || '').trim().toLowerCase();
      return key === 'purebet' || name === 'purebet';
    }

    function isPurebetHost(url) {
      try {
        const host = new URL(url).hostname.toLowerCase();
        return host === 'purebet.io' || host.endsWith('.purebet.io');
      } catch (err) {
        return false;
      }
    }

    function resolveBookmakerOpenUrl(book, opp) {
      const eventId = `${book?.eventId ?? opp?.event_id ?? ''}`.trim();
      const isPurebet = isPurebetBook(book);
      const purebetEventPage = isPurebet && eventId
        ? `https://purebet.io/event/${encodeURIComponent(eventId)}`
        : '';
      if (purebetEventPage) return purebetEventPage;
      const directEventUrl = normalizeUrl(book?.eventUrl);
      if (directEventUrl) return directEventUrl;
      const baseUrl = resolveBookmakerLink(book);
      const templated = withTemplatePlaceholders(baseUrl, book, opp);
      if (!templated) {
        return '';
      }
      if (!isPurebet || !isPurebetHost(templated)) {
        return templated;
      }
      try {
        const parsed = new URL(templated);
        const path = (parsed.pathname || '/').replace(/\/+$/, '');
        if (!path || path === '/' || path === '/event') {
          return templated;
        }
      } catch (err) {
        return templated;
      }
      return templated;
    }

    function openBookmakerTabs(opp) {
      const books = collectBookTargets(opp);
      if (!books.length) {
        showStatusKey('open_books_missing', 'error');
        return;
      }
      let openedCount = 0;
      let availableLinks = 0;
      books.forEach((book) => {
        const targetUrl = resolveBookmakerOpenUrl(book, opp);
        if (!normalizeUrl(targetUrl)) return;
        availableLinks += 1;
        openedCount += openExternalTab(targetUrl);
      });
      if (!availableLinks) {
        showStatusKey('open_books_missing', 'error');
        return;
      }
      if (!openedCount) {
        showStatusKey('open_books_blocked', 'error');
      }
    }

    function formatMarket(opp) {
      const marketLabel = translateMarketLabel(opp.market || '');
      if (opp.market === 'spreads' || opp.market === 'totals') {
        const point = opp.best_odds?.[0]?.point ?? opp.point;
        if (point !== undefined && point !== null) {
          return `${marketLabel} (${point})`;
        }
      }
      return marketLabel;
    }

    function formatPrice(value) {
      if (!value && value !== 0) return '';
      return Number(value).toFixed(2);
    }

    function calculateStakes(opp, totalStake, useEffectivePrices = true) {
      const odds = (opp.best_odds || []).slice(0, 2);
      if (!totalStake || totalStake <= 0 || odds.length < 2) return null;
      const inverses = odds.map((o) => {
        if (!o) return 0;
        const price = useEffectivePrices
          ? Number(o.effective_price ?? o.price)
          : Number(o.price);
        return price > 0 ? 1 / price : 0;
      });
      const sumInv = inverses.reduce((a, b) => a + b, 0);
      if (sumInv <= 0) return null;
      const breakdown = odds.map((o, idx) => {
        if (!o || !o.price) return null;
        const fraction = inverses[idx] / sumInv;
        const stake = Number((totalStake * fraction).toFixed(2));
        const displayPrice = Number(o.price);
        const effectivePrice = Number(o.effective_price ?? o.price);
        const priceUsed = useEffectivePrices ? effectivePrice : displayPrice;
        if (!priceUsed || priceUsed <= 0) return null;
        const payout = Number((stake * priceUsed).toFixed(2));
        return {
          outcome: o.outcome,
          bookmaker: o.bookmaker,
          price: displayPrice,
          effective_price: effectivePrice,
          point: o.point,
          stake,
          payout,
          fraction,
          is_exchange: Boolean(o.is_exchange),
        };
      });
      if (breakdown.includes(null)) return null;
      const minPayout = Math.min(...breakdown.map((b) => b.payout));
      const guaranteed_profit = Number((minPayout - totalStake).toFixed(2));
      const roi_percent = totalStake ? (guaranteed_profit / totalStake) * 100 : 0;
      return { breakdown, guaranteed_profit, roi_percent };
    }

    function formatCurrency(value) {
      return currencyFormatter.format(value || 0);
    }

    function formatProfit(value) {
      const formatted = formatCurrency(Math.abs(value || 0));
      return `${value >= 0 ? '+' : '-'}${formatted}`;
    }

    function renderPartialWarning(data) {
      if (data && data.partial && Array.isArray(data.sport_errors) && data.sport_errors.length) {
        const details = data.sport_errors
          .map((err) => `${err.sport || err.sport_key || t('unknown')} (${err.error || t('unknown_error')})`)
          .join(', ');
        partialWarning.innerHTML = t('partial_results', { details });
        partialWarning.classList.remove('hidden');
        if (scanErrors) {
          scanErrors.innerHTML = t('scan_errors', { details });
          scanErrors.classList.remove('hidden');
        }
      } else {
        partialWarning.classList.add('hidden');
        partialWarning.textContent = '';
        if (scanErrors) {
          scanErrors.classList.add('hidden');
          scanErrors.textContent = '';
        }
      }
    }

    function formatCommissionPercent(rate) {
      if (typeof rate !== 'number') return `${defaultCommissionPercent.toFixed(1)}%`;
      const percent = (rate * 100).toFixed(2);
      return `${percent.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1')}%`;
    }

    function formatExchangeCell(opp) {
      if (!opp || !opp.has_exchange) return `<span class="exchange-flag none">${t('no')}</span>`;
      const names = Array.isArray(opp.exchange_books) && opp.exchange_books.length
        ? opp.exchange_books.join(', ')
        : t('exchange');
      const commissionText = formatCommissionPercent(lastCommissionRate);
      return `<span class="exchange-flag">${names}<span class="exchange-note">${commissionText}</span></span>`;
    }

    function setActiveTab(tab) {
      activeTab = tab;
      tabs.forEach((btn) => btn.classList.toggle('active', btn.dataset.tab === tab));
      arbitragePanel.classList.toggle('hidden', tab !== 'arbitrage');
      middlesPanel.classList.toggle('hidden', tab !== 'middles');
      plusEvPanel.classList.toggle('hidden', tab !== 'plus-ev');
      if (arbitrageConfig) {
        arbitrageConfig.classList.toggle('hidden', tab !== 'arbitrage');
      }
      middlesConfig.classList.toggle('hidden', tab !== 'middles');
      plusEvConfig.classList.toggle('hidden', tab !== 'plus-ev');
      if (tab === 'arbitrage') {
        renderArbitrage();
      } else if (tab === 'middles') {
        renderMiddles();
      } else {
        renderPlusEv();
      }
    }

    function formatGapCell(opp) {
      const integers = opp.gap?.middle_integers || [];
      const keyFlag = opp.gap?.includes_key_number ? ' 🏈' : '';
      const points =
        typeof opp.gap?.points === 'number' ? t('gap_points', { points: opp.gap.points.toFixed(1) }) : '';
      let range = '';
      if (integers.length) {
        range = integers.length === 1 ? `${integers[0]}` : `${integers[0]}-${integers[integers.length - 1]}`;
      }
      const pieces = [range, points].filter(Boolean);
      return `${pieces.join(t('gap_separator'))}${keyFlag}`;
    }

    function formatMiddleSide(side, stakeValue) {
      if (!side) return '';
      const line = side.line !== undefined && side.line !== null ? formatLine(side.line) : '';
      const book = side.bookmaker ? ` @ ${side.bookmaker}` : '';
      const odds = side.effective_price ? formatOddsDisplay(side.effective_price) : formatOddsDisplay(side.price);
      const stake = stakeValue ? t('stake_label', { stake: formatCurrency(stakeValue) }) : '';
      const exchangeBadge = side.is_exchange ? `<span class="exchange-badge">${t('exchange')}</span>` : '';
      const oddsText = t('odds_label', { odds });
      return `<span class="outcome">${exchangeBadge}<strong>${side.team || ''} ${line}</strong><span>${oddsText}${book}</span><span>${stake}</span></span>`;
    }

    function formatLine(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      const num = Number(value);
      const sign = num > 0 ? '+' : '';
      return `${sign}${num.toFixed(1)}`;
    }

    function roiBandClass(roi) {
      if (roi >= 2) return 'band-hot';
      if (roi >= 1) return 'band-warm';
      return 'band-cool';
    }

    function renderBars(container, data, type) {
      if (!container) return;
      if (!data || Object.keys(data).length === 0) {
        container.innerHTML = `<p class="muted">${t('no_data')}</p>`;
        return;
      }
      const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
      const max = entries[0][1] || 1;
      container.innerHTML = entries
        .map(([label, value]) => {
          const width = Math.max((value / max) * 100, 8);
          const bandClass = type === 'roi' ? roiBandLabelClass(label) : '';
          const displayLabel = type === 'sport' ? translateSportLabel(label) : label;
          return `
            <div class="bar-row">
              <span>${displayLabel}</span>
              <div class="bar-track">
                <div class="bar-fill ${bandClass}" style="width: ${width}%"></div>
              </div>
              <span class="bar-value">${value}</span>
            </div>`;
        })
        .join('');
    }

    function roiBandLabelClass(label) {
      if (label.includes('10')) return 'band-hot';
      if (label.includes('5')) return 'band-warm';
      return 'band-cool';
    }

    function formatPercent(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '-';
      return `${Number(value).toFixed(2)}%`;
    }

    function formatRoiBadge(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return '';
      return `<span class="roi-badge secondary">${formatPercent(value)}</span>`;
    }

    function evBandClass(evPercent) {
      if (evPercent >= 10) return 'ev-hot';
      if (evPercent >= 5) return 'ev-warm';
      if (evPercent >= 1) return 'ev-cool';
      if (evPercent < 0) return 'ev-negative';
      return '';
    }

    function buildMiddleStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          positive_count: 0,
          average_ev_percent: 0,
          best_ev_percent: 0,
          best_event: '',
          by_sport: {},
          key_numbers: {},
        };
      }
      let positive = 0;
      let evSum = 0;
      let best = list[0];
      const bySport = {};
      const keyNumbers = {};
      list.forEach((opp) => {
        const ev = Number(opp.ev_percent) || 0;
        if (ev > 0) positive += 1;
        evSum += ev;
        if (!best || ev > (best.ev_percent || 0)) {
          best = opp;
        }
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        (opp.gap?.key_numbers_crossed || []).forEach((num) => {
          const key = String(num);
          keyNumbers[key] = (keyNumbers[key] || 0) + 1;
        });
      });
      return {
        count,
        positive_count: positive,
        average_ev_percent: evSum / count,
        best_ev_percent: best?.ev_percent || 0,
        best_event: best?.event || '',
        by_sport: bySport,
        key_numbers: keyNumbers,
      };
    }

    function buildPlusEvStats(list) {
      const count = list.length;
      if (!count) {
        return {
          count: 0,
          average_edge_percent: 0,
          best_edge_percent: 0,
          best_event: '',
          total_ev_per_100: 0,
          by_sport: {},
          by_edge_band: {},
        };
      }
      let edgeSum = 0;
      let best = list[0];
      let totalEv = 0;
      const bySport = {};
      const byEdge = {};
      list.forEach((opp) => {
        const edge = Number(opp.edge_percent) || 0;
        edgeSum += edge;
        totalEv += Number(opp.ev_per_100) || 0;
        if (!best || edge > (best.edge_percent || 0)) best = opp;
        const sport = opp.sport_display || opp.sport || 'Other';
        bySport[sport] = (bySport[sport] || 0) + 1;
        const bandLabel = edge >= 10 ? '10%+' : edge >= 5 ? '5-10%' : edge >= 3 ? '3-5%' : '1-3%';
        byEdge[bandLabel] = (byEdge[bandLabel] || 0) + 1;
      });
      return {
        count,
        average_edge_percent: edgeSum / count,
        best_edge_percent: best?.edge_percent || 0,
        best_event: best?.event || '',
        total_ev_per_100: totalEv,
        by_sport: bySport,
        by_edge_band: byEdge,
      };
    }
  </script>
</body>
</html>
